module Msf::Exploit::Payload
  require 'msf/core/exploit/payload/encoder'
  include Msf::Exploit::Payload::Encoder

  require 'msf/core/exploit/payload/generation'
  include Msf::Exploit::Payload::Generation

  require 'msf/core/exploit/payload/handler'
  include Msf::Exploit::Payload::Handler

  require 'msf/core/exploit/payload/nop'
  include Msf::Exploit::Payload::Nop

  #
  # Attributes
  #

  # @!attribute [rw] payload
  #   The encoded payload.
  #
  #   @return [Msf::EncodedPayload]
  attr_accessor :payload

  # @!attribute [rw] payload_info
  #   Payloads requirements hash.
  #
  #   @return [Hash]
  attr_accessor :payload_info

  # @!attribute [rw] payload_instance
  #   The active payload instance.
  #
  #   @return [Msf::Payload]
  attr_accessor :payload_instance

  #
  # Methods
  #

  #
  # Return any text that should be appended to the payload.  The payload
  # module is passed so that the exploit can take a guess at architecture
  # and platform if it's a multi exploit.
  #
  def payload_append(explicit_target = nil)
    explicit_target ||= target

    if (explicit_target and explicit_target.payload_append)
      explicit_target.payload_append
    else
      payload_info['Append'] || ''
    end
  end

  #
  # Returns the payload extended options hash which is used to provide
  # a location to store extended information that may be useful to
  # a particular type of payload or mixin.
  #
  def payload_extended_options(explicit_target = nil)
    explicit_target ||= target

    if explicit_target and explicit_target.payload_extended_options
      explicit_target.payload_extended_options
    else
      payload_info['ExtendedOptions']
    end
  end

  #
  # Return any text that should be prepended to the payload.  The payload
  # module is passed so that the exploit can take a guess at architecture
  # and platform if it's a multi exploit.  This automatically takes into
  # account any require stack adjustments.
  #
  def payload_prepend(explicit_target = nil)
    explicit_target ||= target

    if (explicit_target and explicit_target.payload_prepend)
      p = explicit_target.payload_prepend
    else
      p = payload_info['Prepend'] || ''
    end

    stack_adjustment + p
  end

  #
  # Returns the maximum amount of room the exploit has for a payload.
  #
  def payload_space(explicit_target = nil)
    explicit_target ||= target

    if (explicit_target and explicit_target.payload_space)
      explicit_target.payload_space
    elsif (payload_info['Space'])
      payload_info['Space'].to_i
    else
      nil
    end
  end


  #
  # This method returns the number of bytes that should be adjusted to the
  # stack pointer prior to executing any code.  The number of bytes to adjust
  # is indicated to the routine through the payload 'StackAdjustment'
  # attribute or through a target's payload 'StackAdjustment' attribute.
  #
  def stack_adjustment
    if (target and target.payload_stack_adjustment)
      adj = target.payload_stack_adjustment
    else
      adj = payload_info['StackAdjustment']
    end

    # Get the architecture for the current target or use the one specific to
    # this exploit
    arch = (target and target.arch) ? target.arch : self.arch

    # Default to x86 if we can't find a list of architectures
    if (arch and arch.empty? == false)
      arch = arch.join(", ")
    else
      arch = 'x86'
    end

    (adj != nil) ? Rex::Arch::adjust_stack_pointer(arch, adj) || '' : ''
  end
end