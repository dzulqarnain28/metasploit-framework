# -*- coding: binary -*-

module Msf

###
#
# This module exposes methods for querying a remote LDAP service
#
###
module Exploit::Remote::LDAP
module Server
  include Exploit::Remote::SocketServer

  #
  # Initializes an exploit module that serves LDAP requests
  #
  def initialize(info = {})
    super

    register_options(
      [
        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 389]),
        OptPath.new('LDIF_FILE', [ false, "Directory LDIF file path"]),
      ], Exploit::Remote::LDAP::Server
    )

    register_advanced_options(
      [
        OptBool.new('LdapServerUdp', [true, "Serve UDP LDAP requests", true]),
        OptBool.new('LdapServerTcp', [true, "Serve TCP LDAP requests", true])
      ], Exploit::Remote::LDAP::Server
    )
  end

  attr_accessor :ldap_service # :nodoc:

  #
  # Read LDIF file - from https://github.com/ruby-ldap/ruby-net-ldap/blob/master/testserver/ldapserver.rb#L162
  #
  # @ return [Hash] parsed ldif file
  def read_ldif
    return if datastore['LDIF_FILE'].blank? || !File.exists?(datastore['LDIF_FILE'])
    ary = File.readlines(datastore['LDIF_FILE'])
    ldif = {}
    while (line = ary.shift) && line.chomp!
      if line =~ /^dn:[\s]*/i
        dn = $'
        ldif[dn] = {}
        while (attrib = ary.shift) && attrib.chomp! && attrib =~ /^([\w]+)[\s]*:[\s]*/
          ldif[dn][$1] ||= []
          ldif[dn][$1] << $'
        end
      end
    end
    ldif
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def on_dispatch_request(cli, data)
    ldap_service.default_dispatch_request(cli,data)
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def on_send_response(cli, data)
    cli.write(data)
  end

  #
  # Starts the server
  #
  def start_service
    begin
      comm = _determine_server_comm(datastore['SRVHOST'])
      self.ldap_service = Rex::ServiceManager.start(
        Rex::Proto::LDAP::Server,
        datastore['SRVHOST'],
        datastore['SRVPORT'],
        datastore['LdapServerUdp'],
        datastore['LdapServerTcp'],
        read_ldif,
        comm,
        {'Msf' => framework, 'MsfExploit' => self}
      )

      self.ldap_service.dispatch_request_proc = Proc.new do |cli, data|
        on_dispatch_request(cli,data)
      end
      self.ldap_service.send_response_proc = Proc.new do |cli, data|
        on_send_response(cli,data)
      end
    rescue ::Errno::EACCES => e
      raise Rex::BindFailed.new(e.message)
    end
  end
  alias :start_ldap_service :start_service

  #
  # Stops the server
  #
  def stop_service
    Rex::ServiceManager.stop_service(self.ldap_service) if self.ldap_service
    super
  end
  alias :stop_ldap_service :stop_service

  #
  # Resets the LDAP server
  #
  def reset_service
    cleanup
    start_service
  end

  # Backwards compatibility for #service accessor, override in consumers/mixins
  def service
    ldap_service
  end

end
end
end
