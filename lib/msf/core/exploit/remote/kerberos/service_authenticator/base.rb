# -*- coding: binary -*-

#
# This class acts as standalone authenticator for Kerberos
#
class Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base
  extend Forwardable
  include Msf::Exploit::Remote::Kerberos::Client
  include Msf::Auxiliary::Report
  include Rex::Proto::Gss::Asn1

  # @!attribute [r] realm
  #   @return [String] the realm to use
  attr_reader :realm

  # @!attribute [r] username
  #   @return [String] the username to use
  attr_reader :username

  # @!attribute [r] password
  #   @return [String] the password to use
  attr_reader :password

  # @!attribute [r] hostname
  #   @return [String] the unresolved name of the host that the ticket will be used against
  attr_reader :hostname

  # @!attribute [r] host
  #   @return [String] the kerberos host to request a ticket from
  attr_reader :host

  # @!attribute [r] host
  #   @return [Integer] the kerberos port to request a ticket from
  attr_reader :port

  # @!attribute [r] timeout
  #   @return [Integer] the kerberos timeout
  attr_reader :timeout

  # @!attribute [r] framework
  #   @return [Msf::Framework] the Metasploit framework instance
  attr_reader :framework

  # @!attribute [r] framework
  #   @return [Msf::Module] the Metasploit framework module that is associated with the authentication instance
  attr_reader :framework_module

  # @!attribute [r] mutual_auth
  #   @return [Boolean] whether to use mutual authentication
  attr_reader :mutual_auth

  # @!attribute [r] use_gss_checksum
  #   @return [Boolean] whether to use an RFC4121-compliant checksum
  attr_reader :use_gss_checksum

  # @!attribute [r] mechanism
  #   @return [String] the GSS mechanism being used (from Rex::Proto::Gss::Mechanism)
  attr_reader :mechanism

  # @!attribute [r] send_delegated_creds
  #   @return [String] whether to send delegated creds (from the set Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base::Delegation)
  attr_reader :send_delegated_creds

  # @!attribute [r] use_cached_credentials
  #   @return [String] whether to use cached Kerberos credentials from the database
  attr_reader :use_cached_credentials

  # @!attribute [r] store_credential_cache
  #   @return [String] whether to store Kerberos TGS MIT Credential Cache to the database
  attr_reader :store_credential_cache

  def_delegators :@framework_module,
                :print_status,
                :print_good,
                :vprint_error,
                :workspace

  # Flags - https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1.1
  GSS_DELEGATE      = 1
  GSS_MUTUAL        = 2
  GSS_REPLAY_DETECT = 4
  GSS_SEQUENCE      = 8
  GSS_CONFIDENTIAL  = 16
  GSS_INTEGRITY     = 32

  module Delegation
    ALWAYS = 'always' # Always send delegated creds
    NEVER = 'never' # Never send delegated creds
    WHEN_UNCONSTRAINED = 'when_unconstrained' # Send delegated creds when service is unconstrained delegation account
  end

  def initialize(
      realm: nil,
      hostname: nil,
      username: nil,
      password: nil,
      host: nil,
      port: 88,
      timeout: 25,
      framework: nil,
      framework_module: nil,
      mutual_auth: false,
      use_gss_checksum: false,
      mechanism: Rex::Proto::Gss::Mechanism::SPNEGO,
      send_delegated_creds: Delegation::ALWAYS,
      cache_file: nil,
      use_cached_credentials: true,
      store_credential_cache: true
  )
    @realm = realm
    @hostname = hostname
    @host = host
    @port = port
    @timeout = timeout
    @username = username
    @password = password
    @framework = framework
    @framework_module = framework_module
    @mutual_auth = mutual_auth
    @use_gss_checksum = use_gss_checksum
    @mechanism = mechanism
    @send_delegated_creds = send_delegated_creds
    @use_cached_credentials = use_cached_credentials
    @store_credential_cache = store_credential_cache

    credential = nil
    if cache_file.present?
      # the cache file is only used for loading credentials, it is *not* written to
      credential = load_credential_from_file(cache_file)
      if credential.nil? && hostname.present?
        credential = load_credential_from_file(cache_file, sname: "krbtgt/#{hostname.split('.', 2).last}")
      end
      if credential.nil?
        vprint_error("Failed to load a credential from ticket file: #{cache_file}")
      end
    end
    @credential = credential
  end

  # Returns the target host
  #
  # @return [String]
  def rhost
    host
  end

  # Returns the remote port
  #
  # @return [Integer]
  def rport
    port
  end

  # @param [Hash] options
  # @option options [String] :credential An explicit credential object to use for authentication.
  # @option options [Rex::Proto::Kerberos::Model::PrincipalName] :sname The target service principal name.
  # @option options [String] :mechanism The authentication mechanism. One of the Rex::Proto::Gss::Mechanism constants.
  # @return [Hash] The security_blob SPNEGO GSS and TGS session key
  def authenticate(options = {})
    options[:sname] = options.fetch(:sname) { build_spn(options) }

    unless options[:credential]
      if @credential
        # use an explicit credential
        options[:credential] = @credential
      elsif use_cached_credentials
        # load a cached TGS
        options[:credential] = get_cached_credential(options)
        unless options[:credential]
          # load a cached TGT
          options[:credential] = get_cached_credential(
            options.merge(
              sname: Rex::Proto::Kerberos::Model::PrincipalName.new(
                name_type: Rex::Proto::Kerberos::Model::NameType::NT_SRV_INST,
                name_string: [
                  "krbtgt",
                  realm
                ]
              )
            )
          )
        end
        if options[:credential]
          print_status("#{peer} - Using cached credential for #{options[:credential].server} #{options[:credential].client}")
        end
      end
    end

    if options[:credential] && options[:credential].server.to_s.start_with?('krbtgt/')
      auth_context = authenticate_via_krb5_ccache_credential_tgt(options[:credential], options)
    elsif options[:credential]
      auth_context = authenticate_via_krb5_ccache_credential_tgs(options[:credential], options)
    else
      auth_context = authenticate_via_kdc(options)
    end

    ap_request_asn1 = auth_context.delete(:service_ap_request).to_asn1

    mechanism = options.fetch(:mechanism) { self.mechanism }
    if mechanism == Rex::Proto::Gss::Mechanism::SPNEGO
      security_blob = encode_gss_spnego_ap_request(ap_request_asn1)
    elsif mechanism == Rex::Proto::Gss::Mechanism::KERBEROS
      security_blob = encode_gss_kerberos_ap_request(ap_request_asn1)
    else
      raise RuntimeError, "Unknown GSS mechanism: #{mechanism}"
    end

    auth_context[:security_blob] = security_blob
    auth_context
  end

  def get_message_encryptor(key, client_sequence_number, server_sequence_number)
    Rex::Proto::Gss::Kerberos::MessageEncryptor.new(key,
                                            client_sequence_number,
                                            server_sequence_number,
                                            is_initiator: true,
                                            use_acceptor_subkey: true)
  end

  def parse_gss_init_response(token, session_key, mechanism: 'kerberos')
    mech_id, encapsulated_token = unwrap_pseudo_asn1(token)

    if mech_id.value == Rex::Proto::Gss::OID_KERBEROS_5.value
      tok_id = encapsulated_token[0,2]
      data = encapsulated_token[2, encapsulated_token.length]
      case tok_id
      when TOK_ID_KRB_AP_REP
        ap_req = Rex::Proto::Kerberos::Model::ApRep.decode(data)
        print_good("#{peer} - Received AP-REQ. Extracting session key...")

        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError, 'Mismatching etypes' if session_key.type != ap_req.enc_part.etype

        decrypted = ap_req.decrypt_enc_part(session_key.value)

        result = {
          ap_rep_subkey: decrypted.subkey,
          server_sequence_number: decrypted.sequence_number
        }
      when TOK_ID_KRB_ERROR
        krb_err = Rex::Proto::Kerberos::Model::KrbError.decode(data)
        print_error("#{peer} - Received KRB-ERR.")

        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: krb_err)
      else
        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError, "Unknown token id: #{tok_id.inspect}"
      end
    else
      raise ::NotImplementedError, "Parsing mechtype #{mech_id.value} not supported"
    end

  end

  # @param [String] security_buffer SPNEGO GSS Blob
  # @raise [Rex::Proto::Kerberos::Model::Error::KerberosDecodingError] if the response was not successful
  def validate_response!(security_blob)
    gss_api = OpenSSL::ASN1.decode(security_blob)
    neg_result = ::RubySMB::Gss.asn1dig(gss_api, 0, 0, 0)&.value.to_i
    supported_neg = ::RubySMB::Gss.asn1dig(gss_api, 0, 1, 0)&.value

    is_success = neg_result == NEG_TOKEN_ACCEPT_COMPLETED &&
      supported_neg == ::Rex::Proto::Gss::OID_MICROSOFT_KERBEROS_5.value

    raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new('Failed to negotiate Kerberos GSS') unless is_success

    is_success
  end

  def build_spn(options = {})
    nil
  end

  private

  # Authenticate with credentials to the key distribution center (KDC). This will request a TGT before then pass it to
  # #authenticate_via_krb5_ccache_credential_tgt.
  #
  # @param [Hash] options
  def authenticate_via_kdc(options = {})
    realm = self.realm.upcase
    client_name = username
    server_name = "krbtgt/#{realm}"

    ticket_options = Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
      [
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE_OK
      ]
    )

    tgt_result = send_request_tgt(
      server_name: server_name,
      client_name: client_name,
      password: password,
      realm: realm,
      options: ticket_options
    )

    if !tgt_result.preauth_required
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(
        'Kerberos ticket does not require preauthentication. It is not possible to decrypt the encrypted message to request further TGS tickets. Try cracking the password via AS-REP Roasting techniques.',
      )
    end

    print_status("#{peer} - Received a valid TGT-Response")

    cache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.from_responses(tgt_result.as_rep, tgt_result.decrypted_part)
    credential = cache.credentials.first
    authenticate_via_krb5_ccache_credential_tgt(credential, options)
  end

  # Authenticate with a ticket-granting-service (TGS). This method will not contact the KDC and can not request a
  # delegation ticket.
  #
  # @param [Rex::Proto::Kerberos::CredentialCache::Krb5CcacheCredential] credential
  # @param [Hash] _options
  def authenticate_via_krb5_ccache_credential_tgs(credential, _options = {})
    unless credential.is_a?(Rex::Proto::Kerberos::CredentialCache::Krb5CcacheCredential)
      raise TypeError, 'credential must be a Krb5CcacheCredential instance'
    end

    tgs_auth_key = Rex::Proto::Kerberos::Model::EncryptionKey.new(
      type: credential.keyblock.enctype.to_i,
      value: credential.keyblock.data.to_s
    )
    tgs_ticket = Rex::Proto::Kerberos::Model::Ticket.decode(credential.ticket.to_s)

    case send_delegated_creds
    when Delegation::ALWAYS
      do_delegation = true
    when Delegation::WHEN_UNCONSTRAINED
      do_delegation = credential.ticket_flags.include?(Rex::Proto::Kerberos::Model::KdcOptionFlag::OK_AS_DELEGATE)
    end

    if do_delegation
      # the cache is currently backed by a looted ccache file (see #authenticate_via_kdc) and the MIT ccache file format
      # does not have a documented means to store a delegation ticket which is a Microsoft-specific extension
      wlog('Can not process delegation when using a cached credential at this time')
    end

    ## Service Authentication
    checksum = nil
    checksum = build_gss_ap_req_checksum_value(mutual_auth, nil, nil, nil, nil, nil) if use_gss_checksum

    sequence_number = rand(1 << 32)
    service_ap_request = build_service_ap_request(
      session_key: tgs_auth_key,
      checksum: checksum,
      ticket: tgs_ticket,
      realm: self.realm.upcase,
      client_name: username,
      options: Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
        [
          Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE_OK
        ]
      ),
      sequence_number: sequence_number
    )

    {
      service_ap_request: service_ap_request,
      session_key: tgs_auth_key,
      client_sequence_number: sequence_number
    }
  end

  # Authenticate with a ticket-granting-ticket (TGT). This method will contact the KDC and can request a delegation
  # ticket.
  #
  # @param [Rex::Proto::Kerberos::CredentialCache::Krb5CcacheCredential] credential
  # @param [Hash] options
  def authenticate_via_krb5_ccache_credential_tgt(credential, options = {})
    realm = self.realm.upcase
    sname = options.fetch(:sname)
    client_name = username

    now = Time.now.utc
    expiry_time = now + 1.day

    ticket = Rex::Proto::Kerberos::Model::Ticket.decode(credential.ticket.value)
    session_key = Rex::Proto::Kerberos::Model::EncryptionKey.new(
      type: credential.keyblock.enctype.value,
      value: credential.keyblock.data.value
    )

    tgs_ticket, tgs_auth = request_service_ticket(
      session_key,
      ticket,
      realm,
      client_name,
      ticket.enc_part.etype,
      expiry_time,
      now,
      sname
    )

    case send_delegated_creds
    when Delegation::ALWAYS
      do_delegation = true
    when Delegation::NEVER
      do_delegation = false
    when Delegation::WHEN_UNCONSTRAINED
      do_delegation = tgs_auth.flags.include?(Rex::Proto::Kerberos::Model::KdcOptionFlag::OK_AS_DELEGATE)
    end

    if do_delegation
      delegated_tgs_ticket, delegated_tgs_auth = request_delegation_ticket(
        session_key,
        ticket,
        realm,
        client_name,
        ticket.enc_part.etype,
        expiry_time,
        now
      )
    end

    ## Service Authentication
    checksum = nil
    if use_gss_checksum
      checksum = build_gss_ap_req_checksum_value(
        mutual_auth,
        delegated_tgs_ticket,
        delegated_tgs_auth,
        tgs_auth.key,
        realm,
        client_name
      )
    end

    sequence_number = rand(1 << 32)
    service_ap_request = build_service_ap_request(
      session_key: tgs_auth.key,
      checksum: checksum,
      ticket: tgs_ticket,
      realm: realm,
      client_name: client_name,
      options: Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
        [
          Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
          Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE_OK
        ]
      ),
      sequence_number: sequence_number,
      subkey_type: ticket.enc_part.etype # The AP-REP will come back with this same type of subkey
    )

    {
      service_ap_request: service_ap_request,
      session_key: tgs_auth.key,
      client_sequence_number: sequence_number
    }
  end

  def build_gss_ap_req_checksum_value(mutual_auth, ticket, decrypted_part, session_key, realm, client_name)
    # @see https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1
    # No channel binding
    channel_binding_info = "\x00" * 16
    channel_binding_info_len = [channel_binding_info.length].pack('V')

    flags = GSS_REPLAY_DETECT | GSS_SEQUENCE | GSS_CONFIDENTIAL | GSS_INTEGRITY
    flags |= GSS_MUTUAL if mutual_auth
    flags |= GSS_DELEGATE if ticket

    flags = [flags].pack('V')

    checksum_val = channel_binding_info_len + channel_binding_info + flags

    if ticket
      krb_cred = Rex::Proto::Kerberos::Model::KrbCred.new
      krb_cred.pvno = 5
      krb_cred.msg_type = 0x16
      krb_cred.tickets = [ticket]
      ticket_info = Rex::Proto::Kerberos::Model::KrbCredInfo.new
      ticket_info.key = decrypted_part.key
      ticket_info.prealm = realm
      ticket_info.pname = build_client_name(client_name: client_name)
      ticket_info.flags = decrypted_part.flags
      ticket_info.auth_time = decrypted_part.auth_time
      ticket_info.start_time = decrypted_part.start_time
      ticket_info.end_time = decrypted_part.end_time
      ticket_info.renew_till = decrypted_part.renew_till
      ticket_info.sname = decrypted_part.sname
      ticket_info.srealm = decrypted_part.srealm

      enc_part = Rex::Proto::Kerberos::Model::EncKrbCredPart.new
      enc_part.ticket_info = [ticket_info]

      krb_cred.enc_part = enc_part.encrypt(session_key)

      dlg_opt = [1].pack('v')
      dlg_val = krb_cred.encode
      dlg_length = [dlg_val.length].pack('v')
      checksum_val += dlg_opt + dlg_length + dlg_val
    end

    checksum = Rex::Proto::Kerberos::Model::Checksum.new(
      type: Rex::Proto::Gss::KRB_AP_REQ_CHKSUM_TYPE,
      checksum: checksum_val)
  end

  # @param [Rex::Proto::Kerberos::Model::EncryptionKey] session_key
  # @param [Rex::Proto::Kerberos::Model::Ticket] tgt_ticket
  # @param [String] realm
  # @param [String] client_name
  # @param [Integer] tgt_etype
  # @param [Time] expiry_time
  # @param [Time] now
  def request_delegation_ticket(session_key, tgt_ticket, realm, client_name, tgt_etype, expiry_time, now)
    ticket_options = Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
      [
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDED,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
      ]
    )

    krbtgt_sname = Rex::Proto::Kerberos::Model::PrincipalName.new(
      name_type: Rex::Proto::Kerberos::Model::NameType::NT_SRV_INST,
      name_string: [
        "krbtgt",
        realm
      ]
    )
    delegated_tgs_res = send_request_tgs(
      req: build_tgs_request(
        {
          session_key: session_key,
          subkey: nil,
          checksum: nil,
          ticket: tgt_ticket,
          realm: realm,
          client_name: client_name,
          options: ticket_options,

          body: build_tgs_request_body(
            cname: nil,
            sname: krbtgt_sname,
            realm: realm,
            etype: [tgt_etype],
            options: ticket_options,

            # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
            from: nil,
            till: expiry_time,
            rtime: nil,

            # certificate time
            ctime: now
          )
        }
      )
    )

    # Verify error codes
    if delegated_tgs_res.msg_type != Rex::Proto::Kerberos::Model::KRB_ERROR
      print_good("#{peer} - Received a valid delegation TGS-Response")
    end

    delegated_tgs_ticket = delegated_tgs_res.ticket
    delegated_tgs_auth = decrypt_kdc_tgs_rep_enc_part(
      delegated_tgs_res,
      session_key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )

    [delegated_tgs_ticket, delegated_tgs_auth]
  end

  # @param [Rex::Proto::Kerberos::Model::EncryptionKey] session_key
  # @param [Rex::Proto::Kerberos::Model::Ticket] tgt_ticket
  # @param [String] realm
  # @param [String] client_name
  # @param [Integer] tgt_etype
  # @param [Time] expiry_time
  # @param [Time] now
  # @param [Rex::Proto::Kerberos::Model::PrincipalName] sname
  # @raise [Rex::Proto::Kerberos::Model::Error::KerberosError]
  def request_service_ticket(session_key, tgt_ticket, realm, client_name, tgt_etype, expiry_time, now, sname)
    ticket_options = Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
      [
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
      ]
    )

    tgs_res = send_request_tgs(
      req: build_tgs_request(
        {
          session_key: session_key,
          subkey: nil,
          checksum: nil,
          ticket: tgt_ticket,
          realm: realm,
          client_name: client_name,
          options: ticket_options,

          body: build_tgs_request_body(
            cname: nil,
            sname: sname,
            realm: realm,
            etype: [tgt_etype],
            options: ticket_options,

            # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
            from: nil,
            till: expiry_time,
            rtime: nil,

            # certificate time
            ctime: now
          )
        }
      )
    )

    # Verify error codes
    if tgs_res.msg_type == Rex::Proto::Kerberos::Model::KRB_ERROR
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: tgs_res)
    end

    print_good("#{peer} - Received a valid TGS-Response")

    if store_credential_cache
      cache = extract_kerb_creds(
        tgs_res,
        session_key.value,
        msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
      )
      path = store_loot('mit.kerberos.ccache', 'application/octet-stream', rhost, cache.encode, nil, loot_info(sname: sname))
      print_status("#{peer} - TGS MIT Credential Cache saved to #{path}")
    end

    tgs_ticket = tgs_res.ticket
    tgs_auth = decrypt_kdc_tgs_rep_enc_part(
      tgs_res,
      session_key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )

    [tgs_ticket, tgs_auth]
  end

  # Search the database for a credential object that can be used for authentication.
  #
  # @param [Hash] options
  # @return [Rex::Proto::Kerberos::CredentialCache::Krb5CacheCredential] the credential object for authentication
  # @return [nil] returned if the database is not connected or no usable credentials are found
  def get_cached_credential(options = {})
    return nil unless active_db?

    now = Time.now.utc
    host = report_host(workspace: myworkspace, host: @host)
    framework.db.loot(workspace: myworkspace, host: host, ltype: 'mit.kerberos.ccache', info: loot_info(options)).each do |stored_loot|
      ccache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.read(stored_loot.data)
      # at this time Metasploit stores 1 credential per ccache file, so no need to iterate through them
      credential = ccache.credentials.first

      tkt_start = credential.starttime == Time.at(0).utc ? credential.authtime : credential.starttime
      tkt_end = credential.endtime
      return credential if tkt_start < now && now < tkt_end
    end

    nil
  end

  # Load a credential object from a file for authentication. Credentials in the file will be filtered by multiple
  # attributes including their timestamps to ensure that the returned credential appears usable.
  #
  # @param [String] file_path The file path to load a credential object from
  # @return [Rex::Proto::Kerberos::CredentialCache::Krb5CacheCredential] the credential object for authentication
  def load_credential_from_file(file_path, options = {})
    unless File.readable?(file_path.to_s)
      wlog("Failed to load ticket file '#{file_path}' (file not readable)")
      return nil
    end

    begin
      cache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.read(File.binread(file_path))
    rescue StandardError => e
      elog("Failed to load ticket file '#{file_path}' (parsing failed)", error: e)
      return nil
    end

    sname = options.fetch(:sname) { build_spn&.to_s }
    now = Time.now.utc

    cache.credentials.to_ary.each.with_index(1) do |credential, index|
      tkt_start = credential.starttime == Time.at(0).utc ? credential.authtime : credential.starttime
      tkt_end = credential.endtime

      unless tkt_start < now
        wlog("Filtered credential #{file_path} ##{index} reason: Ticket start time is before now (start: #{tkt_start})")
        next
      end

      unless now < tkt_end
        wlog("Filtered credential #{file_path} ##{index} reason: Ticket is expired (expiration: #{tkt_end})")
        next
      end

      unless !@realm || @realm.casecmp?(credential.server.realm.to_s)
        wlog("Filtered credential #{file_path} ##{index} reason: Realm does not match (realm: #{credential.server.realm})")
        next
      end

      unless !sname || sname.to_s.casecmp?(credential.server.components.snapshot.join('/'))
        wlog("Filtered credential #{file_path} ##{index} reason: SPN does not match (spn: #{credential.server.components.snapshot.join('/')})")
        next
      end

      unless !@username || @username.casecmp?(credential.client.components.last.to_s)
        wlog("Filtered credential #{file_path} ##{index} reason: Username does not match (username: #{credential.client.components.last})")
        next
      end

      return credential
    end

    nil
  end

  # Build a loot info string that can later be used in a lookup.
  #
  # @param [Hash] options
  # @option options [Rex::Proto::Kerberos::Model::PrincipalName] :sname the service name (optional)
  # @return [String] the info string
  def loot_info(options = {})
    info = []

    info << "realm: #{self.realm.upcase}" if self.realm
    info << "serviceName: #{options[:sname].to_s.downcase}" if options[:sname]
    info << "username: #{self.username.downcase}" if self.username

    info.join(', ')
  end
end
