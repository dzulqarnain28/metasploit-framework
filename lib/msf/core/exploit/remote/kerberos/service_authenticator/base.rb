# -*- coding: binary -*-

#
# This class acts as standalone authenticator for Kerberos
#
class Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base
  extend Forwardable
  include Msf::Exploit::Remote::Kerberos::Client
  include Msf::Auxiliary::Report
  include Rex::Proto::Gss::Asn1

  # https://datatracker.ietf.org/doc/html/rfc4121#section-4.1
  TOK_ID_KRB_AP_REQ = "\x01\x00"
  TOK_ID_KRB_AP_REP = "\x02\x00"
  TOK_ID_KRB_ERROR  = "\x03\x00"

  # https://datatracker.ietf.org/doc/html/rfc4178#section-4.2.2
  NEG_TOKEN_ACCEPT_COMPLETED      = 0
  NEG_TOKEN_ACCEPT_INCOMPLETE     = 1
  NEG_TOKEN_REJECT                = 2
  NEG_TOKEN_REQUEST_MIC           = 3

  # @!attribute [r] realm
  #   @return [String] the realm to use
  attr_reader :realm

  # @!attribute [r] username
  #   @return [String] the username to use
  attr_reader :username

  # @!attribute [r] password
  #   @return [String] the password to use
  attr_reader :password

  # @!attribute [r] hostname
  #   @return [String] the unresolved name of the host that the ticket will be used against
  attr_reader :hostname

  # @!attribute [r] host
  #   @return [String] the kerberos host to request a ticket from
  attr_reader :host

  # @!attribute [r] host
  #   @return [Integer] the kerberos port to request a ticket from
  attr_reader :port

  # @!attribute [r] timeout
  #   @return [Integer] the kerberos timeout
  attr_reader :timeout

  # @!attribute [r] framework
  #   @return [Msf::Framework] the Metasploit framework instance
  attr_reader :framework

  # @!attribute [r] framework
  #   @return [Msf::Module] the Metasploit framework module that is associated with the authentication instance
  attr_reader :framework_module

  # @!attribute [r] mutual_auth
  #   @return [Boolean] whether to use mutual authentication 
  attr_reader :mutual_auth

  # @!attribute [r] use_gss_checksum
  #   @return [Boolean] whether to use an RFC4121-compliant checksum
  attr_reader :use_gss_checksum

  def_delegators :@framework_module,
                :print_status,
                :print_good,
                :workspace

    # Flags - RFC4121 Section 4.1.1.1
    GSS_DELEGATE      = 1
    GSS_MUTUAL        = 2
    GSS_REPLAY_DETECT = 4
    GSS_SEQUENCE      = 8
    GSS_CONFIDENTIAL  = 16
    GSS_INTEGRITY     = 32

    # RFC4120 section 5.5.1
    AP_USE_SESSION_KEY = 0x40000000
    AP_MUTUAL_REQUIRED = 0x20000000

  def initialize(
      realm: nil,
      hostname: nil,
      username: nil,
      password: nil,
      host: nil,
      port: 88,
      timeout: 25,
      framework: nil,
      framework_module: nil,
      mutual_auth: false,
      use_gss_checksum: false
  )
    @realm = realm
    @hostname = hostname
    @host = host
    @port = port
    @timeout = timeout
    @username = username
    @password = password
    @framework = framework
    @framework_module = framework_module
    @mutual_auth = mutual_auth
    @use_gss_checksum = use_gss_checksum
  end

  # Returns the target host
  #
  # @return [String]
  def rhost
    host
  end

  # Returns the remote port
  #
  # @return [Integer]
  def rport
    port
  end

  # @param [Hash] options
  # @return [Hash] The security_blob SPNEGO GSS and TGS session key
  def authenticate(options = {})
    realm = self.realm.upcase
    sname = options.fetch(:sname)

    server_name = "krbtgt/#{realm}"
    client_name = username
    mechanism = options.fetch(:mechanism) {'spnego'}

    tgt_result = send_request_tgt(
      server_name: server_name,
      client_name: client_name,
      password: password,
      realm: realm,
    )

    if !tgt_result.preauth_required
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(
        'Kerberos ticket does not require preauthentication. It is not possible to decrypt the encrypted message to request further TGS tickets. Try cracking the password via AS-REP Roasting techniques.',
      )
    end

    print_status("#{peer} - Received a valid TGT-Response")
    tgt_etype = tgt_result.as_rep.enc_part.etype

    now = Time.now.utc
    expiry_time = now + 1.day

    options = Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
      [
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE_OK,
      ]
    )

    # TODO: From [MS-KILE]:
    #     The subkey in the EncAPRepPart of the KRB_AP_REP message (defined in [RFC4120] section 5.5.2) is used as the
    #     session key when MutualAuthentication is requested. When DES and RC4 are used, the implementation is as defined
    #     in [RFC1964]. With DES and RC4, the subkey in the KRB_AP_REQ message can be used as the session key, as it is
    #     the same as the subkey in KRB_AP_REP message. However, when AES is used (see [RFC4121]), the subkeys are different
    #     and the subkey in the KRB_AP_REP message is used. (The KRB_AP_REQ message is defined in [RFC4120] section 5.5.1).
    #   So for now, we set the subkey to nil
    subkey = nil

    tgs_res = send_request_tgs(
      req: build_tgs_request(
        {
          session_key: tgt_result.decrypted_part.key,
          subkey: subkey,
          checksum: nil,
          ticket: tgt_result.ticket,
          realm: realm,
          client_name: client_name,
          options: options,

          body: build_tgs_request_body(
            cname: nil,
            sname: sname,
            realm: realm,
            etype: [tgt_etype],
            options: options,

            # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
            from: nil,
            till: expiry_time,
            rtime: nil,

            # certificate time
            ctime: now,
          )
        }
      )
    )

    # Verify error codes
    if tgs_res.msg_type == Rex::Proto::Kerberos::Model::KRB_ERROR
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: tgs_res)
    end

    print_good("#{peer} - Received a valid TGS-Response")
    cache = extract_kerb_creds(
      tgs_res,
      tgt_result.decrypted_part.key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )
    path = store_loot('mit.kerberos.ccache', 'application/octet-stream', rhost, cache.encode)
    print_status("#{peer} - TGS MIT Credential Cache saved to #{path}")

    tgs_ticket = tgs_res.ticket
    tgs_auth = decrypt_kdc_tgs_rep_enc_part(
      tgs_res,
      tgt_result.decrypted_part.key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )

    ## Service Authentication

    checksum = nil
    checksum = build_gss_ap_req_checksum_value(mutual_auth) if use_gss_checksum

    sequence_number = rand(1 << 32)

    service_ap_request = build_service_ap_request(
      session_key: tgs_auth.key,
      checksum: checksum,
      ticket: tgs_ticket,
      realm: realm,
      client_name: client_name,
      options: options,
      sequence_number: sequence_number,
      subkey_type: tgt_etype # The AP-REP will come back with this same type of subkey
    )

    ap_request_asn1 = service_ap_request.to_asn1
    
    if mechanism == 'spnego'
      security_blob = encode_gss_spnego_ap_request(ap_request_asn1)
    elsif mechanism == 'kerberos'
      security_blob = encode_gss_kerberos_ap_request(ap_request_asn1)
    end

    {
      security_blob: security_blob,
      session_key: tgs_auth.key,
      client_sequence_number: sequence_number
    }
  end

  def get_message_encryptor(key, client_sequence_number, server_sequence_number)
    Rex::Proto::Gss::Kerberos::MessageEncryptor.new(key, 
                                            client_sequence_number, 
                                            server_sequence_number, 
                                            true, # is_initiator
                                            use_acceptor_subkey: true)
  end

  def parse_gss_init_response(token, session_key, mechanism: 'kerberos')
    mech_id, encapsulated_token = unwrap_pseudo_asn1(token)

    if mech_id.value == Rex::Proto::Gss::OID_KERBEROS_5.value
      tok_id = encapsulated_token[0,2]
      data = encapsulated_token[2, encapsulated_token.length]
      case tok_id
      when "\x02\x00" # AP_REP
        ap_req = Rex::Proto::Kerberos::Model::ApRep.decode(data)
        print_good("#{peer} - Received AP-REQ. Extracting session key...")

        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError, 'Mismatching etypes' if session_key.type != ap_req.enc_part.etype

        decrypted = ap_req.decrypt_enc_part(session_key.value)
        
        result = {
          :ap_rep_subkey => decrypted.subkey,
          :server_sequence_number => decrypted.sequence_number
        }
      when "\x03\x00" # KRB_ERR
        krb_err = Rex::Proto::Kerberos::Model::KrbError.decode(data)
        print_error("#{peer} - Received KRB-ERR.")

        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: krb_err)
      else
        raise ::Rex::Proto::Kerberos::Model::Error::KerberosError, "Unknown token id: #{tok_id.inspect}"
      end
    else
      raise ::NotImplementedError, "Parsing mechtype #{mech_id.value} not supported"
    end

  end

  def build_gss_ap_req_checksum_value(mutual_auth)
    # No channel binding
    channel_binding_info = "\x00" * 16
    channel_binding_info_len = [channel_binding_info.length].pack('V')

    flags = GSS_REPLAY_DETECT | GSS_SEQUENCE | GSS_CONFIDENTIAL | GSS_INTEGRITY
    flags |= GSS_MUTUAL if mutual_auth

    flags = [flags].pack('V')

    checksum_val = channel_binding_info_len + channel_binding_info + flags

    checksum = Rex::Proto::Kerberos::Model::Checksum.new(
      type: Rex::Proto::Gss::KRB_AP_REQ_CHKSUM_TYPE,
      checksum: checksum_val)
  end

  def build_service_ap_request(opts = {})
    authenticator = opts.fetch(:authenticator) do
      build_authenticator(opts.merge(
        subkey: nil,
        authenticator_enc_key_usage: Rex::Proto::Kerberos::Crypto::KeyUsage::AP_REQ_AUTHENTICATOR
      ))
    end

    ap_req_options = 0
    ap_req_options |= AP_MUTUAL_REQUIRED if mutual_auth

    ap_req = opts.fetch(:ap_req) do
      build_ap_req(opts.merge(:authenticator => authenticator, :ap_req_options => ap_req_options))
    end

    ap_req
  end

  # @param [string] security_buffer SPNEGO GSS Blob
  # @raise [Rex::Proto::Kerberos::Model::Error::KerberosDecodingError] if the response was not successful
  def validate_response!(security_blob)
    gss_api = OpenSSL::ASN1.decode(security_blob)
    neg_result = ::RubySMB::Gss.asn1dig(gss_api, 0, 0, 0)&.value.to_i
    supported_neg = ::RubySMB::Gss.asn1dig(gss_api, 0, 1, 0)&.value

    is_success = neg_result == NEG_TOKEN_ACCEPT_COMPLETED &&
      supported_neg == ::Rex::Proto::Gss::OID_MICROSOFT_KERBEROS_5.value

    raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new('Failed to negotiate Kerberos GSS') unless is_success

    is_success
  end

  def encode_gss_kerberos_ap_request(ap_request_asn1)
    ap_request_mech = wrap_pseudo_asn1(
        ::Rex::Proto::Gss::OID_KERBEROS_5,
        # a 2-byte TOK_ID field containing 01 00 for KRB_AP_REQ messages
        TOK_ID_KRB_AP_REQ + ap_request_asn1.to_der
    )
  end

  # @param [Object] encoded_ap_req The ASN1 KRB_AP_REQ as defined in https://datatracker.ietf.org/doc/html/rfc1964#section-1.1.1
  # @return [String] SPNEGO GSS Blob
  def encode_gss_spnego_ap_request(ap_request_asn1)
    ap_request_mech = encode_gss_kerberos_ap_request(ap_request_asn1)

    OpenSSL::ASN1::ASN1Data.new([
      ::Rex::Proto::Gss::OID_SPNEGO,
      OpenSSL::ASN1::ASN1Data.new([
        OpenSSL::ASN1::Sequence.new([
          OpenSSL::ASN1::ASN1Data.new([
            OpenSSL::ASN1::Sequence.new([
              ::Rex::Proto::Gss::OID_MICROSOFT_KERBEROS_5
            ])
          ], 0, :CONTEXT_SPECIFIC),
          OpenSSL::ASN1::ASN1Data.new([
            OpenSSL::ASN1::OctetString.new(ap_request_mech)
          ], 2, :CONTEXT_SPECIFIC)
        ])
      ], 0, :CONTEXT_SPECIFIC)
    ], 0, :APPLICATION).to_der
  end
end
