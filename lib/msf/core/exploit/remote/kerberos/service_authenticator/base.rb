# -*- coding: binary -*-

#
# This class acts as standalone authenticator for Kerberos
#
class Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base
  extend Forwardable
  include Msf::Exploit::Remote::Kerberos::Client
  include Msf::Auxiliary::Report

  # https://datatracker.ietf.org/doc/html/rfc4121#section-4.1
  TOK_ID_KRB_AP_REQ = "\x01\x00"
  TOK_ID_KRB_AP_REP = "\x02\x00"
  TOK_ID_KRB_ERROR  = "\x03\x00"

  # https://datatracker.ietf.org/doc/html/rfc4178#section-4.2.2
  NEG_TOKEN_ACCEPT_COMPLETED      = 0
  NEG_TOKEN_ACCEPT_INCOMPLETE     = 1
  NEG_TOKEN_REJECT                = 2
  NEG_TOKEN_REQUEST_MIC           = 3

  # @!attribute [r] realm
  #   @return [String] the realm to use
  attr_reader :realm

  # @!attribute [r] username
  #   @return [String] the username to use
  attr_reader :username

  # @!attribute [r] password
  #   @return [String] the password to use
  attr_reader :password

  # @!attribute [r] hostname
  #   @return [String] the unresolved name of the host that the ticket will be used against
  attr_reader :hostname

  # @!attribute [r] host
  #   @return [String] the kerberos host to request a ticket from
  attr_reader :host

  # @!attribute [r] host
  #   @return [Integer] the kerberos port to request a ticket from
  attr_reader :port

  # @!attribute [r] timeout
  #   @return [Integer] the kerberos timeout
  attr_reader :timeout

  # @!attribute [r] framework
  #   @return [Msf::Framework] the Metasploit framework instance
  attr_reader :framework

  # @!attribute [r] framework
  #   @return [Msf::Module] the Metasploit framework module that is associated with the authentication instance
  attr_reader :framework_module

  def_delegators :@framework_module,
                :print_status,
                :print_good,
                :workspace

  def initialize(
      realm: nil,
      hostname: nil,
      username: nil,
      password: nil,
      host: nil,
      port: 88,
      timeout: 25,
      framework: nil,
      framework_module: nil
  )
    @realm = realm
    @hostname = hostname
    @host = host
    @port = port
    @timeout = timeout
    @username = username
    @password = password
    @framework = framework
    @framework_module = framework_module
  end

  # Returns the target host
  #
  # @return [String]
  def rhost
    host
  end

  # Returns the remote port
  #
  # @return [Integer]
  def rport
    port
  end

  # @param [Hash] options
  # @return [Hash] The security_blob SPNEGO GSS and TGS session key
  def authenticate(options = {})
    realm = self.realm.upcase
    sname = options.fetch(:sname)

    server_name = "krbtgt/#{realm}"
    client_name = username

    tgt_result = send_request_tgt(
      server_name: server_name,
      client_name: client_name,
      password: password,
      realm: realm,
    )

    if !tgt_result.preauth_required
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(
        'Kerberos ticket does not require preauthentication. It is not possible to decrypt the encrypted message to request further TGS tickets. Try cracking the password via AS-REP Roasting techniques.',
      )
    end

    print_status("#{peer} - Received a valid TGT-Response")

    now = Time.now.utc
    expiry_time = now + 1.day

    options = Rex::Proto::Kerberos::Model::KdcOptionFlags.from_flags(
      [
        Rex::Proto::Kerberos::Model::KdcOptionFlag::FORWARDABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::CANONICALIZE,
        Rex::Proto::Kerberos::Model::KdcOptionFlag::RENEWABLE_OK,
      ]
    )

    # TODO: From [MS-KILE]:
    #     The subkey in the EncAPRepPart of the KRB_AP_REP message (defined in [RFC4120] section 5.5.2) is used as the
    #     session key when MutualAuthentication is requested. When DES and RC4 are used, the implementation is as defined
    #     in [RFC1964]. With DES and RC4, the subkey in the KRB_AP_REQ message can be used as the session key, as it is
    #     the same as the subkey in KRB_AP_REP message. However, when AES is used (see [RFC4121]), the subkeys are different
    #     and the subkey in the KRB_AP_REP message is used. (The KRB_AP_REQ message is defined in [RFC4120] section 5.5.1).
    #   So for now, we set the subkey to nil
    subkey = nil

    tgs_res = send_request_tgs(
      req: build_tgs_request(
        {
          session_key: tgt_result.decrypted_part.key,
          subkey: subkey,
          checksum: nil,
          ticket: tgt_result.ticket,
          realm: realm,
          client_name: client_name,
          options: options,

          body: build_tgs_request_body(
            cname: nil,
            sname: sname,
            realm: realm,
            options: options,

            # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
            from: nil,
            till: expiry_time,
            rtime: nil,

            # certificate time
            ctime: now,
          )
        }
      )
    )

    # Verify error codes
    if tgs_res.msg_type == Rex::Proto::Kerberos::Model::KRB_ERROR
      raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: tgs_res)
    end

    print_good("#{peer} - Received a valid TGS-Response")
    cache = extract_kerb_creds(
      tgs_res,
      tgt_result.decrypted_part.key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )
    path = store_loot('mit.kerberos.ccache', 'application/octet-stream', rhost, cache.encode)
    print_status("#{peer} - TGS MIT Credential Cache saved to #{path}")

    tgs_ticket = tgs_res.ticket
    tgs_auth = decrypt_kdc_tgs_rep_enc_part(
      tgs_res,
      tgt_result.decrypted_part.key.value,
      msg_type: Rex::Proto::Kerberos::Crypto::KeyUsage::TGS_REP_ENCPART_SESSION_KEY
    )

    ## Service Authentication

    service_ap_request = build_service_ap_request(
      session_key: tgs_auth.key,
      subkey: subkey,
      checksum: nil,
      ticket: tgs_ticket,
      realm: realm,
      client_name: client_name,
      options: options,
    )

    ap_request_asn1 = service_ap_request.to_asn1

    {
      security_blob: encode_gss_ap_request(ap_request_asn1),
      session_key: tgs_auth.key
    }
  end

  def build_service_ap_request(opts = {})
    authenticator = opts.fetch(:authenticator) do
      build_authenticator(opts.merge(
        subkey: nil,
        checksum: nil,
        authenticator_enc_key_usage: Rex::Proto::Kerberos::Crypto::KeyUsage::AP_REQ_AUTHENTICATOR
      ))
    end

    ap_req = opts.fetch(:ap_req) do
      build_ap_req(opts.merge(:authenticator => authenticator))
    end

    ap_req
  end

  # @param [string] security_buffer SPNEGO GSS Blob
  # @raise [Rex::Proto::Kerberos::Model::Error::KerberosDecodingError] if the response was not successful
  def validate_response!(security_blob)
    gss_api = OpenSSL::ASN1.decode(security_blob)
    neg_result = ::RubySMB::Gss.asn1dig(gss_api, 0, 0, 0)&.value.to_i
    supported_neg = ::RubySMB::Gss.asn1dig(gss_api, 0, 1, 0)&.value

    is_success = neg_result == NEG_TOKEN_ACCEPT_COMPLETED &&
      supported_neg == ::Rex::Proto::Gss::OID_MICROSOFT_KERBEROS_5.value

    raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new('Failed to negotiate Kerberos GSS') unless is_success

    is_success
  end

  # @param [Object] encoded_ap_req The ASN1 KRB_AP_REQ as defined in https://datatracker.ietf.org/doc/html/rfc1964#section-1.1.1
  # @return [String] SPNEGO GSS Blob
  def encode_gss_ap_request(ap_request_asn1)
    ap_request_mech = OpenSSL::ASN1::ASN1Data.new(
      [
        ::Rex::Proto::Gss::OID_KERBEROS_5,
        # a 2-byte TOK_ID field containing 01 00 for KRB_AP_REQ messages
        TOK_ID_KRB_AP_REQ,
        ap_request_asn1
      ],
      0,
      :APPLICATION
    ).to_der

    OpenSSL::ASN1::ASN1Data.new([
      ::Rex::Proto::Gss::OID_SPNEGO,
      OpenSSL::ASN1::ASN1Data.new([
        OpenSSL::ASN1::Sequence.new([
          OpenSSL::ASN1::ASN1Data.new([
            OpenSSL::ASN1::Sequence.new([
              ::Rex::Proto::Gss::OID_MICROSOFT_KERBEROS_5
            ])
          ], 0, :CONTEXT_SPECIFIC),
          OpenSSL::ASN1::ASN1Data.new([
            OpenSSL::ASN1::OctetString.new(ap_request_mech)
          ], 2, :CONTEXT_SPECIFIC)
        ])
      ], 0, :CONTEXT_SPECIFIC)
    ], 0, :APPLICATION).to_der
  end
end
