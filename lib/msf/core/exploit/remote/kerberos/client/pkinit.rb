# -*- coding: binary -*-

module Msf
  class Exploit
    class Remote
      module Kerberos
        module Client
          module Pkinit
            def build_dh
              dh_p = '00ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b' +
                     '22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec' + 
                     '6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381' +
                     'ffffffffffffffff'
              dh = OpenSSL::PKey::DH.new
              dh.set_pqg(dh_p.to_i(16), 0, 2)
              priv_key = SecureRandom.random_bytes(32).unpack('H*')[0].to_i(16)
              pub_key = dh.g.mod_exp(priv_key, dh.p)
              dh.set_key(pub_key, priv_key)
              dh_nonce = SecureRandom.random_bytes(32)
              [dh, dh_nonce]
            end

            def k_truncate(data, etype)
              if etype == Rex::Proto::Kerberos::Crypto::Encryption::AES256
                keysize = 32
              elsif etype == Rex::Proto::Kerberos::Crypto::Encryption::AES128
                keysize = 16
              else
                # This is unsupported per the spec
                raise 'Unsupported DH Key exchange encryption type'
              end

              result = ''
              x = 0
              while result.length < keysize
                digest = Digest::SHA1.digest(x.chr + data)
                if result.length + digest.length > keysize
                  result += digest[0..(keysize-result.length-1)] # Just take the first few bytes until we reach the desired length
                  return result
                end
                result += digest
                x += 1
              end

              result
            end

            def calculate_shared_key(pa_pk_as_rep, dh, dh_nonce, etype)
              dh_rep_info = pa_pk_as_rep.dh_rep_info
              signed_data = dh_rep_info.signed_data
              dh_key_info = signed_data[:encap_content_info].econtent
              server_public_key = RASN1::Types::Integer.parse(dh_key_info[:subject_public_key].value).value
              shared_key = dh.compute_key(server_public_key.to_bn)
              server_nonce = pa_pk_as_rep[:server_dh_nonce].value
              full_key = shared_key + dh_nonce + server_nonce
              truncated_key = k_truncate(full_key, etype)
              result = Rex::Proto::Kerberos::Model::EncryptionKey.new
              result.type = etype
              result.value = truncated_key
            end

            def build_pa_pk_as_req(pfx, dh, dh_nonce, request_body, opts)
              certificate = pfx.certificate
              now_time = Time.now.utc
              now_ctime = now_time.round
              ctime = opts.fetch(:ctime) { now_ctime }
              cusec = opts.fetch(:cusec) { now_time&.usec || 0 }
              nonce = opts.fetch(:nonce) { rand(1 << 31) }
              # Request body needs to be tagged prior to encoding
              request_body = OpenSSL::ASN1::ASN1Data.new([request_body.encode], 4, :CONTEXT_SPECIFIC)
              data = request_body.to_der
              checksum = Digest::SHA1.digest(data)
              pub_key_encoded = RASN1::Types::Integer.new(value: dh.pub_key.to_i).to_der
              auth_pack = Rex::Proto::Kerberos::Model::Pkinit::AuthPack.new(
                pk_authenticator: {
                  cusec: cusec,
                  ctime: ctime,
                  nonce: nonce,
                  pa_checksum: checksum
                },
                client_public_value: {
                  algorithm: {
                    algorithm: '1.2.840.10046.2.1', # Diffie-Hellman
                    parameters: Rex::Proto::Kerberos::Model::Pkinit::DomainParameters.new(
                      p: dh.p.to_i,
                      g: dh.g.to_i,
                      q: 0
                    )
                  },
                  subject_public_key: pub_key_encoded
                },
                client_dh_nonce: RASN1::Types::OctetString.new(value: dh_nonce)
              )

              auth_pack[:client_public_value][:subject_public_key].bit_length = pub_key_encoded.length * 8

              signed_auth_pack = sign_auth_pack(auth_pack, pfx.key, certificate)

              pa_as_req = Rex::Proto::Kerberos::Model::PreAuthPkAsReq.new

              pa_as_req.signed_auth_pack = signed_auth_pack

              Rex::Proto::Kerberos::Model::PreAuthDataEntry.new(type: Rex::Proto::Kerberos::Model::PreAuthType::PA_PK_AS_REQ,
                                                                value: pa_as_req.to_der
                                                               )
            end

            def sign_auth_pack(auth_pack, key, certificate)

              signer_info = Rex::Proto::Kerberos::Model::Pkinit::SignerInfo.new(
                version: 1,
                sid: {
                  issuer: certificate.issuer,
                  serial_number: certificate.serial.to_i
                },
                digest_algorithm: {
                  algorithm: '1.3.14.3.2.26',
                },
                signed_attrs: [
                  {
                    attribute_type: '1.2.840.113549.1.9.3', # Content Type
                    attribute_values: [RASN1::Types::Any.new(value: RASN1::Types::ObjectId.new(value: '1.3.6.1.5.2.3.1'))]
                  },
                  {
                    attribute_type: '1.2.840.113549.1.9.4', # Message Digest
                    attribute_values: [RASN1::Types::Any.new(value: RASN1::Types::OctetString.new(value: Digest::SHA1.digest(auth_pack.to_der)))]
                  }
                ],
                signature_algorithm: {
                  algorithm: '1.2.840.113549.1.1.5'
                },
              )
              data = RASN1::Types::Set.new(value: signer_info[:signed_attrs].value).to_der
              signature = key.sign(OpenSSL::Digest::SHA1.new, data)

              signer_info[:signature] = signature

              signed_data = Rex::Proto::Kerberos::Model::Pkinit::SignedData.new(
                version: 3,
                digest_algorithms: [
                  {
                    algorithm: '1.3.14.3.2.26',
                }],
                encap_content_info: {
                  econtent_type: '1.3.6.1.5.2.3.1',
                  econtent: auth_pack.to_der
                },
                certificates: [{openssl_certificate: certificate}],
                signer_infos: [signer_info]
              )

              signed_auth_pack = Rex::Proto::Kerberos::Model::Pkinit::ContentInfo.new(
                content_type: '1.2.840.113549.1.7.2',
                signed_data: signed_data
              )
            end
          end
        end
      end
    end
  end
end
