# -*- coding: binary -*-

module Msf
  ###
  #
  # This module provides methods for exploiting an LDAP client by acting
  # as an LDAP server.
  #
  ###
  module Exploit::Remote::LdapServer
    SEARCH_REQUEST = 3
    SEARCH_RES_ENTRY = 4
    SEARCH_RES_DONE = 5
    ABANDON_REQUEST = 16

    def aseq(x, tag)
      s = seq(x)
      s.tag_class = :APPLICATION
      s.tag = tag
      s
    end

    def seq(x)
      OpenSSL::ASN1::Sequence.new(x)
    end

    def int(x)
      OpenSSL::ASN1::Integer.new(x)
    end

    def string(x)
      OpenSSL::ASN1::OctetString.new(x)
    end

    def set(x)
      OpenSSL::ASN1::Set.new(x)
    end

    def enum(x)
      OpenSSL::ASN1::Enumerated.new(x)
    end

    def java_string(s)
      length = s.length
      packed_length = [length].pack('S>')
      "#{packed_length}#{s}"
    end

    def search_res_done(message_id)
      s = seq([
        int(message_id),
        aseq([enum(0), string(''), string('')], SEARCH_RES_DONE)
      ])
      s.to_der
    end

    def read_ldap_packet(socket)
      buffer = ''

      bytes = socket.read(2)
      if bytes[0] != '0'
        raise "NOT_LDAP: #{bytes.inspect} #{bytes[0]}"
      end

      buffer << bytes

      length = bytes[1].ord
      if (length & (1 << 7)) != 0
        length_bytes_length = length ^ (1 << 7)

        length_bytes = socket.read(length_bytes_length)
        buffer << length_bytes
        length = length_bytes.bytes.reduce(0) { |c, e| (c << 8) + e }
      end

      buffer << socket.read(length)
      buffer
    end
  end
end
