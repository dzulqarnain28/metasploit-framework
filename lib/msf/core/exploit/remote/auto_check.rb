# -*- coding: binary -*-

module Msf
module Exploit::Remote::AutoCheck

  AUTO_CHECK_LEVEL_OPTIONAL = 0   # the check itself can be ignored by the user
  AUTO_CHECK_LEVEL_BYPASSABLE = 1 # the check must be run but the result can be ignored by the user
  AUTO_CHECK_LEVEL_REQUIRED = 2   # nothing can be ignored by the user

  def self.included(_base)
    raise NotImplementedError, "#{name} should not be included, it should be prepended"
  end

  def initialize(info = {})
    super(
      update_info(
        info,
        'AutoCheckLevel' => AUTO_CHECK_LEVEL_OPTIONAL
      )
    )


    if auto_check_level <= AUTO_CHECK_LEVEL_BYPASSABLE
      register_advanced_options([
          OptBool.new('ForceExploit', [false, 'Override check result', false])
      ])
      if auto_check_level <= AUTO_CHECK_LEVEL_OPTIONAL
        register_advanced_options([
          OptBool.new('AutoCheck', [false, 'Run check before exploit', true])
        ])
      end
    end
  end

  def run
    with_prepended_auto_check do
      super
    end
  end

  def exploit
    with_prepended_auto_check do
      super
    end
  end

  private

  def auto_check_level
    module_info['AutoCheckLevel']
  end

  def with_prepended_auto_check
    if auto_check_level <= AUTO_CHECK_LEVEL_OPTIONAL && !datastore['AutoCheck']
      print_warning('AutoCheck is disabled, proceeding with exploitation')
      return yield
    end

    if auto_check_level <= AUTO_CHECK_LEVEL_OPTIONAL
      print_status('Running automatic check. Run "set AutoCheck false" to disable.')
    else
      print_status('Running automatic check.')
    end

    check_code = check
    case check_code
    when Exploit::CheckCode::Vulnerable, Exploit::CheckCode::Appears
      print_good(check_code.message)
      return yield
    when Exploit::CheckCode::Detected
      print_warning(check_code.message)
      return yield
    when Exploit::CheckCode::Safe
      failure_type = Module::Failure::NotVulnerable
    when Exploit::CheckCode::Unsupported
      failure_type = Module::Failure::BadConfig
    else
      failure_type = Module::Failure::Unknown
    end

    if auto_check_level <= AUTO_CHECK_LEVEL_BYPASSABLE && datastore['ForceExploit']
      print_warning("#{check_code.message} ForceExploit is enabled, proceeding with exploitation.")
      return yield
    end

    if auto_check_level <= AUTO_CHECK_LEVEL_BYPASSABLE
      fail_with(failure_type, "#{check_code.message} Run \"set ForceExploit true\" to override check result.")
    else
      fail_with(failure_type, check_code.message)
    end
  end

  def merge_info_autochecklevel(info, val)
    info['AutoCheckLevel'] = val
  end

end
end
