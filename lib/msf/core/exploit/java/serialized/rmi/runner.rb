# -*- coding: binary -*-

module Msf
  module Exploit::Java::Serialized::RMI

    class RMICheck
      attr_reader :jmxprober

      def initialize(host, port, ssl: false, username: nil, password: nil, rc: RunConfig.new)
        @host = host
        @port = port
        @ssl = ssl
        @jmxcreds = nil
        if !username.nil? && !password.nil?
          @jmxcreds = Rex::Java::Serialization::Metamodel::JavaArray.new('Ljava/lang/String;',
                                                                         %w[test test])
        end

        @rc = rc

        @reg = Rex::Java::Serialization::Metamodel::Registry.new()
        @reg.load('model/base-java9.json')
        @reg.load('model/rmi.json')
      end


      def check_referenced_objects(foundobjects)
        vectors = []
        Util.info 'Found ' + foundobjects.length.to_s + ' referenced objects, following references'
        foundobjects.each do |name, obj|
          unless @rc.follow_remote_refs?
            if obj['host'] != @host && !obj['host'].start_with?('127.')
              Util.info 'Skipping possibly remote object ' + name + ' pointing to ' + obj['host'] + ":" + obj['port']
              return
            end
          end

          if name == 'jmxrmi'
            prober = JMXProber.new(name, obj, @reg, @host, jmxcreds: @jmxcreds, rc: @rc)
            @jmxprober = prober
          else
            Util.info 'Custom object found ' + name
            prober = ReferenceProber.new(name, obj, @reg, @host, rc: @rc)
          end

          begin
            v = prober.run
            vectors += v unless v.nil?
          rescue Rex::Java::JRMP::JRMPError => e
            root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
            Util.error 'Probe failed: ' + root.to_s
            Util.error e.ex.to_s
          rescue ::Exception => e
            Util.error 'Probe failed: ' + e.to_s
            prober.close
            raise
          end
          prober.close
        end
        vectors
      end

      def run
        prober = RMIProber.new(@host, @port, @reg, ssl: @ssl, rc: @rc)
        vectors = prober.run
        foundobjects = prober.objects

        if @rc.check_refs? and !foundobjects.empty?
          vectors.push(*check_referenced_objects(foundobjects))
        end

        dedupvecs = []
        dedup = Set[]
        gadgets = Set[]
        vectors.sort { |a, b| a.prio - b.prio }.each do |vector|
          i = vector.id
          if !dedup.include?(i)
            dedup.add(i)
          else
            next
          end
          gadgets += vector.context.gadgets if vector.respond_to?('context')
          dedupvecs.push(vector)
        end
        Util.info format('Identified %d attack vector(s), gadgets %s', dedupvecs.length, gadgets.to_a.to_s)
        dedupvecs
      end
    end
  end
end
