require 'spec_helper'
require 'msf/core'
require 'msf/core/exploit/remote/browser_exploit_server'

describe Msf::Exploit::Remote::BrowserExploitServer do

  subject(:server) do
    mod = Msf::Exploit.allocate
    mod.extend described_class
    mod.send(:initialize, {})
    mod
  end

  let(:service_double) do
    service = double("service")
    service.stub(:server_name=)
    service.stub(:add_resource)

    service
  end

  let(:profile_name) do
    "random"
  end

  let(:expected_os_name) do
    "linux"
  end

  let(:expected_user_agent) do
    "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
  end

  # What the module expects
  let(:expected_profile) do
    {
      :source=>"script",
      :os_name=>/win/i,
      :os_flavor=>"XP",
      :ua_name=>"MSIE",
      :ua_ver=>"8.0",
      :arch=>"x86",
      :office=>"null",
      :activex=>"true",
      :proxy=>false,
      :language=>"en-us",
      :tried=>true
    }
  end

  # What the client actually returns
  let(:client_profile) do
    {
      :source=>"script",
      :os_name=>"Microsoft Windows",
      :os_flavor=>"XP",
      :ua_name=>"MSIE",
      :ua_ver=>"8.0",
      :arch=>"x86",
      :office=>"null",
      :activex=>"true",
      :proxy=>false,
      :language=>"en-us",
      :tried=>true
    }
  end

  before do
    Rex::ServiceManager.stub(:start => service_double)
  end

  before(:each) do
    server.start_service
  end

  describe ".get_module_resource" do
    it "should give me a URI to access the exploit page" do
      ivar_exploit_page = server.instance_variable_get(:@exploit_receiver_page)
      module_resource = server.get_module_resource
      module_resource.should match(ivar_exploit_page)
    end
  end

  describe ".get_module_uri" do
    it "should return a module URI" do
      server.get_module_uri.should match(/http/)
    end
  end

  describe ".get_bad_requirements" do
    let(:rejected_requirements) do
      server.get_bad_requirements(fake_profile)
    end

    context 'when given the expected profile' do
      it "should not contain any bad requirements" do
        server.get_bad_requirements(expected_profile).should eq([])
      end
    end

    context 'when attempting to match :os_name' do
      let(:fake_profile) do
        { :os_name => expected_os_name }
      end

      before do
        server.instance_variable_set(:@requirements, {:os_name => /win/i})
      end

      it "should have identify :os_name as a requirement not met" do
        rejected_requirements.should eq([:os_name])
      end
    end

    context 'when attempting to match :ua_ver' do
      context 'against version 25.0' do
        let(:expected_ua_ver) { '25.0' }
        let(:fake_profile) do
          { :ua_ver => expected_ua_ver }
        end

        before do
          server.instance_variable_set(:@requirements, {:ua_ver => ua_ver})
        end

        context "with the regex /26\.0$/" do
          let(:ua_ver) { /26\.0$/ }
          it "should reject :ua_ver" do
            rejected_requirements.should include(:ua_ver)
          end
        end

        context "with the regex /25\.0$/" do
          let(:ua_ver) { /25\.0$/ }
          it "should accept :ua_ver" do
            rejected_requirements.should_not include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 1-5" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(1, 5) } }
          it "should reject :ua_ver" do
            rejected_requirements.should include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 20-26" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(20, 26) } }
          it "should accept :ua_ver" do
            rejected_requirements.should_not include(:ua_ver)
          end
        end
      end
    end
  end

  describe ".init_profile" do
    it "should initialize an empety profile for tag 'random'" do
      server.init_profile(profile_name)
      ivar_target_profile = server.instance_variable_get(:@target_profiles)
      ivar_target_profile.should eq({profile_name=>{}})
    end
  end

  describe ".retrieve_tag" do
    let(:client_request) do
      double(Rex::Proto::Http::Request)
    end

    let(:user_agent) do
      'USER_AGENT_VALUE'
    end

    it "should return a cookie-based tag for the client" do
      unique_cookie_value = 'COOKIE_VALUE'

      http_headers = {
        'Cookie'     => unique_cookie_value,
        'User-Agent' => user_agent
      }

      client_request.stub(:headers).and_return(http_headers)
      server.retrieve_tag(client_request).should eq(unique_cookie_value)
    end

    it "should return user-agent + IP-based tag for the client" do
      peerhost = "127.0.0.1"
      

      http_headers = {
        'Cookie'     => '',
        'User-Agent' => user_agent
      }

      expected_hash = Rex::Text.md5("#{peerhost}#{user_agent}")

      sock = double(Socket)
      sock.stub(:peerhost).and_return(peerhost)
      client_request.stub(:headers).and_return(http_headers)
      server.stub(:cli).and_return(sock)
      server.retrieve_tag(client_request).should eq(expected_hash)
    end
  end

  describe ".get_profile" do
    it "should return nil when a profile isn't found" do
      server.init_profile(profile_name)
      p = server.get_profile("non_existent_profile")
      p.should be_nil
    end

    it "should return a profile if found" do
      server.init_profile(profile_name)
      p = server.get_profile(profile_name)
      p.should eq({})
    end
  end

  describe ".update_profile" do
    it "should update my target profile's :os_name information" do
      server.init_profile(profile_name)
      profile = server.get_profile(profile_name)
      server.update_profile(profile, :os_name, expected_os_name)
      profile = server.get_profile(profile_name)
      profile[:os_name].should eq(expected_os_name)
    end
  end

  describe ".has_proxy" do
    it "should return false" do
      req = double(Rex::Proto::Http::Request)
      req.stub(:headers).and_return({})
      server.has_proxy?(req).should eq(false)
    end
  end

  describe ".get_detection_html" do
    it "should return the detection code that the client will get" do
      html = server.get_detection_html(expected_user_agent)
      html.should_not eq('')
    end
  end

  describe ".on_request_exploit" do
    it "should raise a NoMethodError if called" do
      fake_cli = nil
      fake_request = nil
      fake_browser_info = nil
      lambda {
        server.on_request_exploit(fake_cli, fake_request, fake_browser_info)
      }.should raise_error
    end
  end

  describe ".send_exploit_html" do
    it "should process an ERB template" do
      template = %Q|
      <html>
      <%='Hello, world'%>
      </html>
      |
      cli = double(Socket)
      server.stub(:send_response).with(an_instance_of(cli.class), an_instance_of(String), an_instance_of(Hash))
      server.send_exploit_html(cli, template)
    end

    it "should raise a NameError exception due to a bad template" do
      template = %Q|
      <html>
      <%=name_error_due_to_bad_var%>
      </html>
      |

      cli = double(Socket)
      server.stub(:send_response).with(an_instance_of(cli.class), an_instance_of(String), an_instance_of(Hash))
      expect { server.send_exploit_html(cli, template) }.to raise_error(NameError)
    end
  end

  describe ".get_target" do
    it "should return a target" do
      expected_object = double(Msf::Module::Target)
      server.instance_variable_set(:@target, expected_object)
      server.get_target.instance_variable_get(:@name).should eq(Msf::Module::Target)
    end
  end

  describe ".try_set_target" do
    let(:target_object) do
      Msf::Module::Target
    end

    it "should try to set a target based on requirements" do
      fake_target = double(target_object)
      fake_target.stub(:opts).and_return(expected_profile)
      server.stub(:targets).and_return([fake_target])
      server.try_set_target(client_profile)
      server.get_target.instance_variable_get(:@name).should eq(target_object)
    end

    it "should set nothing because there are no met requirements" do
      expected_profile = {}
      fake_target = double(target_object)
      fake_target.stub(:opts).and_return(expected_profile)
      server.stub(:targets).and_return([fake_target])
      server.try_set_target(client_profile)
      server.get_target.should eq(nil)
    end
  end

  describe ".extract_requirements" do
    it "should find all the recognizable keys" do
      requirements = {:os_flavor=>"XP", :ua_name=>"MSIE", :ua_ver=>"8.0"}
      matches = server.extract_requirements(requirements)
      matches.should eq(requirements)
    end

    it "should make sure the keys are always symbols" do
      requirements = {'os_flavor'=>"XP", 'ua_name'=>"MSIE"}
      matches = server.extract_requirements(requirements)
      matches.each do |k,v|
        k.class.should eq(Symbol)
      end
    end
  end

end