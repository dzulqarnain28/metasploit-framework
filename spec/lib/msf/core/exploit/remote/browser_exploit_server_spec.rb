require 'spec_helper'
require 'msf/core'
require 'msf/core/exploit/remote/browser_exploit_server'

describe Msf::Exploit::Remote::BrowserExploitServer do

  subject(:server) do
    mod = Msf::Exploit.allocate
    mod.extend described_class
    mod.send(:initialize, {})
    mod
  end

  let(:service_double) do
    service = double("service")
    service.stub(:server_name=)
    service.stub(:add_resource)

    service
  end

  let(:profile_name) do
    "random"
  end

  let(:expected_os_name) do
    "linux"
  end

  let(:expected_user_agent) do
    "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
  end

  # What the module expects
  let(:expected_profile) do
    {
      :source    => "script",
      :os_name   => /win/i,
      :os_flavor => "XP",
      :ua_name   => "MSIE",
      :ua_ver    => "8.0",
      :arch      => "x86",
      :office    => "null",
      :activex   => "true",
      :proxy     => false,
      :language  => "en-us",
      :tried     => true
    }
  end

  # What the client actually returns
  let(:client_profile) do
    {
      :source    => "script",
      :os_name   => "Microsoft Windows",
      :os_flavor => "XP",
      :ua_name   => "MSIE",
      :ua_ver    => "8.0",
      :arch      => "x86",
      :office    => "null",
      :activex   => "true",
      :proxy     => false,
      :language  => "en-us",
      :tried     => true
    }
  end

  let(:expected_target) do
    double(Msf::Module::Target)
  end

  let(:peerhost) do
    '127.0.0.1'
  end

  let(:sock) do
    s = double(Socket)
    s.stub(:peerhost).and_return(peerhost)
    s.stub(:peerport).and_return(8080)
    return s
  end

  before do
    Rex::ServiceManager.stub(:start => service_double)
  end

  before(:each) do
    server.start_service
  end

  describe ".get_module_resource" do
    it "should give me a URI to access the exploit page" do
      ivar_exploit_page = server.instance_variable_get(:@exploit_receiver_page)
      module_resource = server.get_module_resource
      module_resource.should match(ivar_exploit_page)
    end
  end

  describe ".get_module_uri" do
    it "should return a module URI" do
      server.get_module_uri.should match(/http/)
    end
  end

  describe ".get_bad_requirements" do
    let(:rejected_requirements) do
      server.get_bad_requirements(fake_profile)
    end

    context 'when given the expected profile' do
      it "should not contain any bad requirements" do
        server.get_bad_requirements(expected_profile).should eq([])
      end
    end

    context 'when attempting to match :os_name' do
      let(:fake_profile) do
        { :os_name => expected_os_name }
      end

      before do
        server.instance_variable_set(:@requirements, {:os_name => /win/i})
      end

      it "should have identify :os_name as a requirement not met" do
        rejected_requirements.should eq([:os_name])
      end
    end

    context 'when attempting to match :ua_ver' do
      context 'against version 25.0' do
        let(:expected_ua_ver) { '25.0' }
        let(:fake_profile) do
          { :ua_ver => expected_ua_ver }
        end

        before do
          server.instance_variable_set(:@requirements, {:ua_ver => ua_ver})
        end

        context "with the regex /26\.0$/" do
          let(:ua_ver) { /26\.0$/ }
          it "should reject :ua_ver" do
            rejected_requirements.should include(:ua_ver)
          end
        end

        context "with the regex /25\.0$/" do
          let(:ua_ver) { /25\.0$/ }
          it "should accept :ua_ver" do
            rejected_requirements.should_not include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 1-5" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(1, 5) } }
          it "should reject :ua_ver" do
            rejected_requirements.should include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 20-26" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(20, 26) } }
          it "should accept :ua_ver" do
            rejected_requirements.should_not include(:ua_ver)
          end
        end
      end
    end
  end

  describe ".init_profile" do
    it "should initialize an empety profile for tag 'random'" do
      server.init_profile(profile_name)
      ivar_target_profile = server.instance_variable_get(:@target_profiles)
      ivar_target_profile.should eq({profile_name=>{}})
    end
  end

  describe ".retrieve_tag" do
    let(:client_request) do
      double(Rex::Proto::Http::Request)
    end

    let(:user_agent) do
      'USER_AGENT_VALUE'
    end

    it "should return a cookie-based tag for the client" do
      unique_cookie_value = 'COOKIE_VALUE'

      http_headers = {
        'Cookie'     => unique_cookie_value,
        'User-Agent' => user_agent
      }

      client_request.stub(:headers).and_return(http_headers)
      server.retrieve_tag(client_request).should eq(unique_cookie_value)
    end

    it "should return user-agent + IP-based tag for the client" do
      http_headers = {
        'Cookie'     => '',
        'User-Agent' => user_agent
      }

      expected_hash = Rex::Text.md5("#{peerhost}#{user_agent}")
      client_request.stub(:headers).and_return(http_headers)
      server.stub(:cli).and_return(sock)
      server.retrieve_tag(client_request).should eq(expected_hash)
    end
  end

  describe ".process_browser_info" do
    let(:req) do
      http_headers = {
        'Cookie'     => 'UNIQUE_VALUE',
        'User-Agent' => expected_user_agent
      }
      req = double(Rex::Proto::Http::Request)
      req.stub(:headers).and_return(http_headers)
      req.stub(:body).and_return("")
      return req
    end

    before do
      server.stub(:get_profile).and_return(client_profile)
      server.stub(:cli).and_return(sock)
      server.stub(:report_client).with(an_instance_of(Hash))
    end

    it "should update the profile based on source :script" do
      server.process_browser_info(:script, sock, req)
    end

    it "should update the profile based on source :headers" do
      server.process_browser_info(:headers, sock, req)
    end
  end

  describe ".get_profile" do
    it "should return nil when a profile isn't found" do
      server.init_profile(profile_name)
      p = server.get_profile("non_existent_profile")
      p.should be_nil
    end

    it "should return a profile if found" do
      server.init_profile(profile_name)
      p = server.get_profile(profile_name)
      p.should eq({})
    end
  end

  describe ".update_profile" do
    it "should update my target profile's :os_name information" do
      server.init_profile(profile_name)
      profile = server.get_profile(profile_name)
      server.update_profile(profile, :os_name, expected_os_name)
      profile = server.get_profile(profile_name)
      profile[:os_name].should eq(expected_os_name)
    end
  end

  describe ".has_proxy" do
    it "should return false" do
      req = double(Rex::Proto::Http::Request)
      req.stub(:headers).and_return({})
      server.has_proxy?(req).should eq(false)
    end
  end

  describe ".get_detection_html" do
    it "should return the detection code that the client will get" do
      html = server.get_detection_html(expected_user_agent)
      html.should_not be_blank
    end
  end

  describe ".on_request_uri" do
    let(:req) do
      http_headers = {
        'Cookie'     => 'UNIQUE_VALUE',
        'User-Agent' => expected_user_agent
      }
      req = double(Rex::Proto::Http::Request)
      req.stub(:headers).and_return(http_headers)
      req.stub(:body).and_return('')
      return req
    end

    let(:resource) do
      double('resource')
    end


    before do
      server.stub(:send_redirect).with(an_instance_of(sock.class), an_instance_of(String))
      server.stub(:send_not_found).with(an_instance_of(sock.class))
      server.stub(:get_profile).with(an_instance_of(String)).and_return(client_profile)
      server.stub(:report_client).with(an_instance_of(Hash))
    end

    context "info_gathering" do
      before do
        uri = 'base_uri'
        resource.stub(:uri).and_return(uri)
        req.stub(:uri).and_return(uri)
        server.stub(:get_resource).and_return(uri)
      end

      it "should send the detection code to the browser" do
        server.stub(:get_profile).with(an_instance_of(String)).and_return(nil)
        server.stub(:send_response).with(an_instance_of(sock.class), an_instance_of(String), an_instance_of(Hash))
        server.on_request_uri(sock, req)
      end

      it "should redirect the user to the exploit page" do
        server.on_request_uri(sock, req)
      end
    end

    it "should send a response for the regular info receiver" do
      server.stub(:send_response).with(an_instance_of(sock.class), an_instance_of(String))
      uri = server.instance_variable_get(:@info_receiver_page)
      resource.stub(:uri).and_return(uri)
      req.stub(:uri).and_return(uri)
      server.on_request_uri(sock, req)
    end

    it "should send a response for the noscript info receiver" do
      server.stub(:send_response).with(an_instance_of(sock.class), an_instance_of(String))
      uri = server.instance_variable_get(:@noscript_receiver_page)
      resource.stub(:uri).and_return(uri)
      req.stub(:uri).and_return(uri)
      server.on_request_uri(sock, req)
    end

    it "should send an exploit" do
      server.stub(:send_response).with(an_instance_of(sock.class), an_instance_of(String))
      server.stub(:on_request_exploit)
      uri = server.instance_variable_get(:@exploit_receiver_page)
      resource.stub(:uri).and_return(uri)
      req.stub(:uri).and_return(uri)
      server.on_request_uri(sock, req)
    end

    it "should send a 404" do
      uri = "BAD"
      resource.stub(:uri).and_return(uri)
      req.stub(:uri).and_return(uri)
      server.on_request_uri(sock, req)
    end
  end

  describe ".on_request_exploit" do
    it "should raise a NoMethodError if called" do
      fake_cli = nil
      fake_request = nil
      fake_browser_info = nil
      lambda {
        server.on_request_exploit(fake_cli, fake_request, fake_browser_info)
      }.should raise_error
    end
  end

  describe ".send_exploit_html" do
    before do
      server.stub(:send_response).with(
        an_instance_of(sock.class),
        an_instance_of(String),
        an_instance_of(Hash)
      )
    end

    it "should process an ERB template" do
      template = %Q|
      <html>
      <%='Hello, world'%>
      </html>
      |
      
      server.send_exploit_html(sock, template)
    end

    it "should raise a NameError exception due to a bad template" do
      template = %Q|
      <html>
      <%=name_error_due_to_bad_var%>
      </html>
      |

      expect { server.send_exploit_html(cli, template) }.to raise_error(NameError)
    end
  end

  describe ".get_target" do
    it "should return a target" do
      server.instance_variable_set(:@target, expected_target)
      server.get_target.instance_variable_get(:@name).should eq(Msf::Module::Target)
    end
  end

  describe ".try_set_target" do
    let(:target_object) do
      Msf::Module::Target
    end

    it "should try to set a target based on requirements" do
      fake_target = double(target_object)
      fake_target.stub(:opts).and_return(expected_profile)
      server.stub(:targets).and_return([fake_target])
      server.try_set_target(client_profile)
      server.get_target.instance_variable_get(:@name).should eq(target_object)
    end

    it "should set nothing because there are no met requirements" do
      expected_profile = {}
      fake_target = double(target_object)
      fake_target.stub(:opts).and_return(expected_profile)
      server.stub(:targets).and_return([fake_target])
      server.try_set_target(client_profile)
      server.get_target.should eq(nil)
    end
  end

  describe ".extract_requirements" do
    it "should find all the recognizable keys" do
      requirements = {:os_flavor=>"XP", :ua_name=>"MSIE", :ua_ver=>"8.0"}
      matches = server.extract_requirements(requirements)
      matches.should eq(requirements)
    end

    it "should make sure the keys are always symbols" do
      requirements = {'os_flavor'=>"XP", 'ua_name'=>"MSIE"}
      matches = server.extract_requirements(requirements)
      matches.each do |k,v|
        k.class.should eq(Symbol)
      end
    end
  end

  describe ".get_payload" do
    it "should generate a payload" do
      fake_payload = "PAYLOAD"
      server.stub(:target).and_return(expected_target)
      p = double('payload')
      p.stub(:encoded).and_return(fake_payload)

      server.stub(:regenerate_payload).with(
        an_instance_of(sock.class),
        an_instance_of(String),
        an_instance_of(String)
      ).and_return(p)

      server.get_payload(sock, client_profile).should eq(fake_payload)
    end
  end

end