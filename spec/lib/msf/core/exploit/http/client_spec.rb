# -*- coding:binary -*-
require 'spec_helper'
require 'msf/core'
require 'msf/core/exploit/http/client'

describe Msf::Exploit::Remote::HttpClient do

  let(:http_response) { Rex::Proto::Http::Response.new }

  subject do
    db = double(Msf::DBManager)
    db.stub(:active).and_return(true)
    framework = double(Msf::Framework)
    framework.stub(:db).and_return(db)

    # Fake a connection
    conn_block = double('conn_block')
    conn_pool = double("pool")
    conn_pool.stub(:with_connection)
    ar_base = double('Base')
    ar_base.stub(:connection_pool).and_return(conn_pool)
    stub_const('ActiveRecord::Base', ar_base)

    mod = Module.new
    mod.extend described_class
    mod.stub(:framework).and_return(framework)
    mod.stub(:connect).with(an_instance_of(Hash))
    mod.stub(:send_request_raw).with(an_instance_of(Hash)).and_return(http_response)
    mod.stub(:report_web_site).with(an_instance_of(Hash))
    mod.stub(:fail_with).with(anything, an_instance_of(String)).and_raise(RuntimeError)

    return mod
  end

  context "Methods" do
    context ".validate_fingerprint" do
      it "should raise an error for an invalid match" do
        opts = {'FingerprintCheck'=>true}
        opts.stub(:default?).and_return(true)
        subject.stub(:datastore).and_return(opts)
        stub_const('HttpFingerprint', {:pattern => [/pattern/]})
        expect { subject.validate_fingerprint }.to raise_error(RuntimeError)
      end
    end

    context '.normalize_uri' do
      let(:expected_normalized_uri) { '/a/b/c' }
      let(:normalized_uri)          { subject.normalize_uri(unnormalized_uri) }

      context "with just '/'" do
        let(:unnormalized_uri) { '/' }

        it "should be '/'" do
          unnormalized_uri.should eq('/')
        end

        it "should return '/'" do
          normalized_uri.should eq('/')
        end
      end

      context "with starting '/'" do
        let(:unnormalized_uri) { expected_normalized_uri }

        it "should start with '/'" do
          unnormalized_uri[0, 1].should eq('/')
        end

        it "should not add another starting '/'" do
          normalized_uri.should eq(expected_normalized_uri)
        end

        context "with multiple internal '/'" do
          let(:unnormalized_uri) { "/#{expected_normalized_uri.gsub("/", "////")}" }

          it "should remove doubled internal '/'" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end

        context "with multiple starting '/'" do
          let(:unnormalized_uri) { "/#{expected_normalized_uri}" }

          it "should have at least 2 starting '/'" do
            unnormalized_uri[0, 2].should eq('//')
          end

          it "should return with one starting '/'" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end

        context "with trailing '/'" do
          let(:expected_normalized_uri) { '/a/b/c/' }
          let(:unnormalized_uri)        { "#{expected_normalized_uri}/" }

          it "should end with '/'" do
            normalized_uri[-1, 1].should eq('/')
          end

          context "with multiple trailing '/'" do
            let(:unnormalized_uri) { "#{expected_normalized_uri}/" }

            it "should have multiple trailing '/'" do
              unnormalized_uri[-2,2].should eq('//')
            end

            it "should return only one trailing '/'" do
              normalized_uri.should eq(expected_normalized_uri)
            end
          end
        end

        context "without trailing '/'" do
          let(:unnormalized_uri) { expected_normalized_uri }

          it "should not have a trailing '/'" do
            unnormalized_uri[-1, 1].should_not eq('/')
          end

          it "should return original string" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end
      end

      context "without starting '/'" do
        context "with trailing '/'" do
          let(:unnormalized_uri)        { 'a/b/c/' }
          let(:expected_normalized_uri) { '/a/b/c/' }

          it "should have trailing '/'" do
            unnormalized_uri[-1, 1].should eq('/')
          end

          it "should add starting '/'" do
            normalized_uri[0, 1].should eq('/')
          end

          it "should not remove trailing '/'" do
            normalized_uri[-1, 1].should eq('/')
          end

          it 'should normalize the uri' do
            normalized_uri.should eq("#{expected_normalized_uri}")
          end

          context "with multiple internal '/'" do
            let(:unnormalized_uri) { "/#{expected_normalized_uri.gsub("/", "////")}" }

            it "should remove doubled internal '/'" do
              normalized_uri.should eq(expected_normalized_uri)
            end
          end
        end

        context "without trailing '/'" do
          let(:unnormalized_uri) { 'a/b/c' }

          it "should not have trailing '/'" do
            unnormalized_uri[-1, 1].should_not eq('/')
          end

          it "should add starting '/'" do
            normalized_uri[0, 1].should eq('/')
          end

          it "should add trailing '/'" do
            normalized_uri[-1, 1].should_not eq('/')
          end
        end
      end

      context 'with empty string' do
        let(:unnormalized_uri) { '' }

        it "should be empty" do
          unnormalized_uri.should be_empty
        end

        it "should return '/'" do
          normalized_uri.should eq('/')
        end
      end

      context 'with nil' do
        let(:unnormalized_uri) { nil }

        it 'should be nil' do
          unnormalized_uri.should be_nil
        end

        it "should return '/" do
          normalized_uri.should eq('/')
        end
      end
    end
  end
end
