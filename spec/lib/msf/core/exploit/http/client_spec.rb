# -*- coding:binary -*-
require 'spec_helper'
require 'msf/core'
require 'msf/core/exploit/http/client'

describe Msf::Exploit::Remote::HttpClient do

  let(:http_response) { Rex::Proto::Http::Response.new }
  let(:rhost)         { '127.0.0.1' }
  let(:rport)         { 80 }

  subject do

    datastore_opts = {
      'SSL'                         => false,
      'UserAgent'                   => 'useragent',
      'RHOST'                       => rhost,
      'RPORT'                       => rport,
      'HTTP::uri_encode_mode'       => 'u-normal',
      'HTTP::uri_full_url'          => '/',
      'HTTP::pad_method_uri_count'  => 0,
      'HTTP::pad_uri_version_count' => 0,
      'HTTP::pad_method_uri_type'   => 'tab',
      'HTTP::pad_uri_version_type'  => 'tab',
      'FingerprintCheck'            => true
    }
    datastore_opts.stub(:default?).and_return(true)

    db = double(Msf::DBManager)
    db.stub(:active).and_return(true)
    framework = double(Msf::Framework)
    framework.stub(:db).and_return(db)

    # Fake a connection
    conn_block = double('conn_block')
    conn_pool = double("pool")
    conn_pool.stub(:with_connection)
    ar_base = double('Base')
    ar_base.stub(:connection_pool).and_return(conn_pool)
    stub_const('ActiveRecord::Base', ar_base)

    mod = Module.new
    mod.extend described_class
    mod.stub(:framework).and_return(framework)
    mod.stub(:report_web_site).with(an_instance_of(Hash))
    mod.stub(:fail_with).with(anything, an_instance_of(String)).and_raise(RuntimeError)
    mod.stub(:datastore).and_return(datastore_opts)

    return mod
  end

  context "Methods" do
    context ".validate_fingerprint" do
      it "should raise an error for an invalid match" do
        subject.stub(:connect).with(an_instance_of(Hash))
        subject.stub(:send_request_raw).with(an_instance_of(Hash)).and_return(http_response)
        stub_const('HttpFingerprint', {:pattern => [/pattern/]})
        expect { subject.validate_fingerprint }.to raise_error(RuntimeError)
      end
    end

    context ".connect" do
      it "should connect" do
        Rex::Proto::Http::Client.stub(:set_config)
        subject.connect.should be_a_kind_of(Rex::Proto::Http::Client)
      end
    end

    context "HTTP requests" do
      let(:cli) do
        Rex::Proto::Http::Client.new(rhost, rport)
      end

      it ".send_request_raw" do
        cli.stub(:send_recv).and_return('')
        subject.stub(:connect).with(an_instance_of(Hash)).and_return(cli)
        subject.send_request_raw({'uri'=>'/'}, 1).should be_empty
      end

      it "should return nil due to a timeout (raw request)" do
        cli.stub(:send_recv).and_raise(Timeout::Error)
        subject.stub(:connect).with(an_instance_of(Hash)).and_return(cli)
        subject.send_request_raw({'uri'=>'/'}, 1).should be_nil
      end

      it ".send_request_cgi" do
        cli.stub(:send_recv).and_return('')
        subject.stub(:connect).with(an_instance_of(Hash)).and_return(cli)
        subject.send_request_cgi({'uri'=>'/'}, 1).should be_empty
      end

      it "should return nil due to a timeout (cgi request)" do
        cli.stub(:send_recv).and_raise(Timeout::Error)
        subject.stub(:connect).with(an_instance_of(Hash)).and_return(cli)
        subject.send_request_cgi({'uri'=>'/'}, 1).should be_nil
      end
    end

    context ".basic_auth" do
      it "should return a basic_auth string" do
        username = 'user'
        password = 'pass'
        base64_auth_str = ''
        subject.basic_auth(username, password).should eq('Basic dXNlcjpwYXNz')
      end
    end

    context ".target_uri" do
      it "should return a uri object" do
        subject.target_uri.should be_a_kind_of(URI)
      end
    end

    context ".full_uri" do
      it "should return a full uri" do
        subject.full_uri.should eq("http://#{rhost}/")
      end
    end

    context ".path_from_uri" do
      it "should return a path from uri" do
        path = '/dir/file.php'
        subject.path_from_uri(path).should eq(path)
      end
    end

    context ".strip_tags" do
      it "should remove html tags" do
        expected_message = 'hello, world'
        html = %Q|
        <html>
        #{expected_message}
        </html>
        |

        subject.strip_tags(html).should eq(expected_message)
      end
    end

    context ".peer" do
      it "should return rhost:rport" do
        subject.peer.should eq("#{rhost}:#{rport}")
      end
    end

    context '.normalize_uri' do
      let(:expected_normalized_uri) { '/a/b/c' }
      let(:normalized_uri)          { subject.normalize_uri(unnormalized_uri) }

      context "with just '/'" do
        let(:unnormalized_uri) { '/' }

        it "should be '/'" do
          unnormalized_uri.should eq('/')
        end

        it "should return '/'" do
          normalized_uri.should eq('/')
        end
      end

      context "with starting '/'" do
        let(:unnormalized_uri) { expected_normalized_uri }

        it "should start with '/'" do
          unnormalized_uri[0, 1].should eq('/')
        end

        it "should not add another starting '/'" do
          normalized_uri.should eq(expected_normalized_uri)
        end

        context "with multiple internal '/'" do
          let(:unnormalized_uri) { "/#{expected_normalized_uri.gsub("/", "////")}" }

          it "should remove doubled internal '/'" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end

        context "with multiple starting '/'" do
          let(:unnormalized_uri) { "/#{expected_normalized_uri}" }

          it "should have at least 2 starting '/'" do
            unnormalized_uri[0, 2].should eq('//')
          end

          it "should return with one starting '/'" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end

        context "with trailing '/'" do
          let(:expected_normalized_uri) { '/a/b/c/' }
          let(:unnormalized_uri)        { "#{expected_normalized_uri}/" }

          it "should end with '/'" do
            normalized_uri[-1, 1].should eq('/')
          end

          context "with multiple trailing '/'" do
            let(:unnormalized_uri) { "#{expected_normalized_uri}/" }

            it "should have multiple trailing '/'" do
              unnormalized_uri[-2,2].should eq('//')
            end

            it "should return only one trailing '/'" do
              normalized_uri.should eq(expected_normalized_uri)
            end
          end
        end

        context "without trailing '/'" do
          let(:unnormalized_uri) { expected_normalized_uri }

          it "should not have a trailing '/'" do
            unnormalized_uri[-1, 1].should_not eq('/')
          end

          it "should return original string" do
            normalized_uri.should eq(expected_normalized_uri)
          end
        end
      end

      context "without starting '/'" do
        context "with trailing '/'" do
          let(:unnormalized_uri)        { 'a/b/c/' }
          let(:expected_normalized_uri) { '/a/b/c/' }

          it "should have trailing '/'" do
            unnormalized_uri[-1, 1].should eq('/')
          end

          it "should add starting '/'" do
            normalized_uri[0, 1].should eq('/')
          end

          it "should not remove trailing '/'" do
            normalized_uri[-1, 1].should eq('/')
          end

          it 'should normalize the uri' do
            normalized_uri.should eq("#{expected_normalized_uri}")
          end

          context "with multiple internal '/'" do
            let(:unnormalized_uri) { "/#{expected_normalized_uri.gsub("/", "////")}" }

            it "should remove doubled internal '/'" do
              normalized_uri.should eq(expected_normalized_uri)
            end
          end
        end

        context "without trailing '/'" do
          let(:unnormalized_uri) { 'a/b/c' }

          it "should not have trailing '/'" do
            unnormalized_uri[-1, 1].should_not eq('/')
          end

          it "should add starting '/'" do
            normalized_uri[0, 1].should eq('/')
          end

          it "should add trailing '/'" do
            normalized_uri[-1, 1].should_not eq('/')
          end
        end
      end

      context 'with empty string' do
        let(:unnormalized_uri) { '' }

        it "should be empty" do
          unnormalized_uri.should be_empty
        end

        it "should return '/'" do
          normalized_uri.should eq('/')
        end
      end

      context 'with nil' do
        let(:unnormalized_uri) { nil }

        it 'should be nil' do
          unnormalized_uri.should be_nil
        end

        it "should return '/" do
          normalized_uri.should eq('/')
        end
      end
    end
  end
end
