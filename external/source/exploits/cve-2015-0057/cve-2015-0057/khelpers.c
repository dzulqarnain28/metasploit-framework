/*
 * khelpers.c
 */

#include "khelpers.h"

#include <TlHelp32.h>

/* functions resolved by init_kernel_help */
lNtAllocateVirtualMemory pNtAllocateVirtualMemory = NULL;
lNtCurrentTeb pNtCurrentTeb = NULL;
lNtQueryInformationProcess pNtQueryInformationProcess = NULL;
lNtQuerySystemInformation pNtQuerySystemInformation = NULL;

#ifdef DEBUGGING
void dprintf(char *pszFormat, ...)
{
	char s_acBuf[2048];
	size_t len;
	va_list args;

	_snprintf_s(s_acBuf, sizeof(s_acBuf), sizeof(s_acBuf) - 1, "[0x%08x] ", GetCurrentThreadId());
	len = strlen(s_acBuf);
	va_start(args, pszFormat);
	vsnprintf_s(s_acBuf + len, sizeof(s_acBuf) - len, sizeof(s_acBuf) - len - 3, pszFormat, args);
	va_end(args);
	strcat_s(s_acBuf, sizeof(s_acBuf), "\r\n");
	printf(s_acBuf);
}
#endif

/*!
 * @brief Get a pointer to the SHAREDINFO structure.
 */
PSHAREDINFO get_shared_info(void) {
	HMODULE hUser32 = NULL;
	PSHAREDINFO pSharedInfo = NULL;

	hUser32 = LoadLibrary("user32");
	pSharedInfo = (PSHAREDINFO)GetProcAddress(hUser32, "gSharedInfo");
	FreeLibrary(hUser32);
	return pSharedInfo;
}

/*!
 * @brief Get the address of the win32k!tagSHAREDINFO in the current process.
 */
PHANDLEENTRY get_ahe_list(void)
{
	PSHAREDINFO pSharedInfo = NULL;

	pSharedInfo = get_shared_info();
	if (pSharedInfo == NULL) {
		return NULL;
	}
	return pSharedInfo->aheList;
}

/*!
 * @brief Get the address of an object in the kernel from it's handle.
 * @param hHandle The handle to get the kernel address of.
 * @return The kernel address of the object associated with the handle.
 */
PVOID get_kernel_address(HANDLE hHandle)
{
	PHANDLEENTRY aheList = get_ahe_list();
	if (aheList == NULL) {
		return NULL;
	}
	PHANDLEENTRY target_handle = &aheList[((DWORD)hHandle & 0xffff)];
	return target_handle->Head;
}

BOOL pause_all_other_threads(void) {
	HANDLE hThread = INVALID_HANDLE_VALUE;
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;
	DWORD dwThisPid = GetCurrentProcessId();
	DWORD dwThisTid = GetCurrentThreadId();

	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	te32.dwSize = sizeof(THREADENTRY32);
	if (!Thread32First(hThreadSnap, &te32)) {
		CloseHandle(hThreadSnap);
		return FALSE;
	}

	do {
		if ((te32.th32ThreadID == dwThisTid)) {
			continue;
		}
		hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
		if ((hThread == NULL) || (hThread == INVALID_HANDLE_VALUE)) {
			continue;
		}
		SuspendThread(hThread);
	} while (Thread32Next(hThreadSnap, &te32));

	CloseHandle(hThreadSnap);
	return TRUE;
}

BOOL resume_all_other_threads(void) {
	HANDLE hThread = INVALID_HANDLE_VALUE;
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;
	DWORD dwThisPid = GetCurrentProcessId();
	DWORD dwThisTid = GetCurrentThreadId();

	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	te32.dwSize = sizeof(THREADENTRY32);
	if (!Thread32First(hThreadSnap, &te32)) {
		CloseHandle(hThreadSnap);
		return FALSE;
	}

	do {
		if ((te32.th32ThreadID == dwThisTid)) {
			continue;
		}
		hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
		if ((hThread == NULL) || (hThread == INVALID_HANDLE_VALUE)) {
			continue;
		}
		ResumeThread(hThread);
	} while (Thread32Next(hThreadSnap, &te32));

	CloseHandle(hThreadSnap);
	return TRUE;
}

/*!
 * @brief Get the userland address of an object in the kernel from it's handle.
 * @param bDesktopHeap TRUE if the object is in the desktop heap, FALSE if it is in the session heap.
 */
PVOID get_userland_address(HANDLE hHandle, BOOL bDesktopHeap) {
	PVOID pKAddress = NULL;
	ULONG ulDelta = 0;

	pKAddress = get_kernel_address(hHandle);
	if (pKAddress == NULL) {
		return NULL;
	}
	
	if (bDesktopHeap) {
		/* 442 = offset for Windows 7 SP1 x86 */
		ulDelta = ((PULONG)pNtCurrentTeb())[442];
	}
	else {
		ulDelta = get_shared_info()->ulSharedDelta;
	}

	return (PVOID)((ULONG)pKAddress - ulDelta);
}

/*!
 * @brief Initialize necessary things for kernel helper functions.
 */
BOOL init_kernel_help(void)
{
	HMODULE hNtdll = LoadLibrary("ntdll");
	BOOL bStatus = FALSE;

	do {
		if (hNtdll == NULL)
		{
			break;
		}

		pNtAllocateVirtualMemory = (lNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
		if (pNtAllocateVirtualMemory == NULL)
		{
			break;
		}

		pNtCurrentTeb = (lNtCurrentTeb)GetProcAddress(hNtdll, "NtCurrentTeb");
		if (pNtCurrentTeb == NULL)
		{
			break;
		}

		pNtQueryInformationProcess = (lNtQueryInformationProcess)GetProcAddress(hNtdll, "NtQueryInformationProcess");
		if (pNtQueryInformationProcess == NULL)
		{
			break;
		}

		pNtQuerySystemInformation = (lNtQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
		if (pNtQuerySystemInformation == NULL)
		{
			break;
		}

		bStatus = TRUE;
	} while (FALSE);

	FreeLibrary(hNtdll);
	return bStatus;
}
